{
  "forks": [

  ],
  "user": {
    "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
    "login": "GerHobbelt",
    "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
    "url": "https://api.github.com/users/GerHobbelt",
    "id": 402462
  },
  "history": [
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-09T08:44:26Z",
      "version": "33cdb1fcef428d03176eb6bcbad5b25565c5c8b9",
      "url": "https://api.github.com/gists/2366983/33cdb1fcef428d03176eb6bcbad5b25565c5c8b9",
      "change_status": {
        "total": 46,
        "additions": 46,
        "deletions": 0
      }
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-04-12T12:43:57Z",
      "version": "7b53a0e9d335952e840a205eda9709b5516b79d6",
      "url": "https://api.github.com/gists/2366983/7b53a0e9d335952e840a205eda9709b5516b79d6",
      "change_status": {
        "total": 313,
        "additions": 313,
        "deletions": 0
      }
    }
  ],
  "description": "d3.bisect() usage to get Y value for mouse X where x axis is a timestamp/date",
  "comments": 0,
  "created_at": "2012-04-12T12:43:57Z",
  "git_pull_url": "git://gist.github.com/2366983.git",
  "public": true,
  "html_url": "https://gist.github.com/2366983",
  "git_push_url": "git@gist.github.com:2366983.git",
  "files": {
    "index.html": {
      "type": "text/html",
      "filename": "index.html",
      "raw_url": "https://gist.github.com/raw/2366983/1e2bb70eb2556c851602a7fb5fa72cd40f3837ab/index.html",
      "size": 11389,
      "content": "<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<title>Path Transitions</title>\n<style>\n\n.x.axis line {\n  shape-rendering: auto;\n}\n\n.line {\n  fill: none;\n  stroke: #000;\n  stroke-width: 1.5px;\n}\n\n</style>\n<script src=\"http://github.com/GerHobbelt/d3/raw/bleeding-edge/d3.latest.js\"></script>\n<script>\n\nvar n = 40,\n    random = d3.random.normal(0, .2);\n\nfunction chart(domain, interpolation, tick) {\n  var data = d3.range(n).map(random);\n\n  var margin = {top: 6, right: 0, bottom: 6, left: 40},\n      width = 960 - margin.right,\n      height = 120 - margin.top - margin.bottom;\n\n  var x = d3.scale.linear()\n      .domain(domain)\n      .range([0, width]);\n\n  var y = d3.scale.linear()\n      .domain([-1, 1])\n      .range([height, 0]);\n\n  var line = d3.svg.line()\n      .interpolate(interpolation)\n      .x(function(d, i) { return x(i); })\n      .y(function(d, i) { return y(d); });\n\n  var svg = d3.select(\"body\").append(\"p\").append(\"svg\")\n      .attr(\"width\", width + margin.left + margin.right)\n      .attr(\"height\", height + margin.top + margin.bottom)\n      .style(\"margin-left\", -margin.left + \"px\")\n    .append(\"g\")\n      .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n  svg.append(\"defs\").append(\"clipPath\")\n      .attr(\"id\", \"clip\")\n    .append(\"rect\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n  svg.append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .call(d3.svg.axis().scale(y).ticks(5).orient(\"left\"));\n\n  var path = svg.append(\"g\")\n      .attr(\"clip-path\", \"url(#clip)\")\n    .append(\"path\")\n      .data([data])\n      .attr(\"class\", \"line\")\n      .attr(\"d\", line);\n\n  tick(path, line, data, x);\n}\n\n</script>\n\n<h1>Path Transitions</h1>\n\n<p>When implementing realtime displays of time-series data, we often use the <i>x</i>-axis to encode time as position: as time progresses, new data comes in from the right, and old data slides out to the left. If you use D3’s built-in <a href=\"https://github.com/mbostock/d3/wiki/Transitions\" target=\"_blank\">path interpolators</a>, however, you may see some surprising behavior:\n\n<script>\n\nchart([0, n - 1], \"linear\", function tick(path, line, data) {\n\n  // push a new data point onto the back\n  data.push(random());\n\n  // pop the old data point off the front\n  data.shift();\n\n  // transition the line\n  path.transition()\n      .duration(750)\n      .ease(\"linear\")\n      .attr(\"d\", line)\n      .each(\"end\", function() { tick(path, line, data); });\n});\n\n</script>\n\n<p>Why the distracting wiggle? There are multiple valid interpretations when interpolating two paths. Here’s the relevant code from the above chart:\n\n<pre><code>// push a new data point onto the back\ndata.push(random());\n\n// pop the old data point off the front\ndata.shift();\n\n// transition the line\npath.transition().attr(\"d\", line);\n</code></pre>\n\n<p>One interpretation (the one shown above) is that the <i>y</i>-values are changing in-place; for example, you might use this when filtering the data or <a href=\"http://mbostock.github.com/d3/ex/stream.html\">transitioning between metrics</a>. Another interpretation (the one we want) is that the change represents a sliding window in <i>x</i>. But how do you tell D3 to interpolate in <i>x</i> rather than in <i>y</i>?\n\n<p>To start, you need to understand a bit about how  <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\">paths</a> are represented in SVG. Consider this path element, which draws a polyline (a <a href=\"http://en.wikipedia.org/wiki/Polygonal_chain\">piecewise linear curve</a>) of three points:\n\n<pre><code class=\"html\">&lt;path d=\"M0,0L1,6L2,4\"&gt;&lt;/path&gt;</code></pre>\n\n<p>The path data, stored in the <code>d</code> attribute, is a string which contains various commands such as <i>moveto</i> (M) and <i>lineto</i> (L). This path starts at the origin ⟨0,0⟩, draws a line segment to ⟨1,6⟩, and finally another line segment to ⟨2,4⟩; these positions are called the <i>control points</i>. Now say you wanted to shift the old points left and add a new point, resulting in a new path:\n\n<pre><code class=\"html\">&lt;path d=\"M0,6L1,4L2,5\"&gt;&lt;/path&gt;</code></pre>\n\n<p>The old path had three control points, and the new path has three control points, so the naïve approach is to interpolate each control point from the old to the new:\n\n<ul>\n  <li>⟨0,0⟩ ↦ ⟨0,6⟩\n  <li>⟨1,6⟩ ↦ ⟨1,4⟩\n  <li>⟨2,4⟩ ↦ ⟨2,5⟩\n</ul>\n\n<p>Since only the <i>y</i>-values change, this interpretation results in a vertical wiggle. When you tell D3 to transition between two paths, it takes exactly this simple approach: it finds numbers embedded in the associated path data strings, pairs them in order, and interpolates. Thus, the transition interpolates six numbers (for the three control points) and produces the same wiggle.\n\n<p>To eliminate the wiggle, <b>interpolate the transform</b> rather than the path. This makes sense if you think of the chart as visualizing a function—its value isn’t changing, we’re just showing a different part of the domain. By sliding the visible window at the same rate that new data arrives, we can seamlessly display realtime data:\n\n<script>\n\nchart([0, n - 1], \"linear\", function tick(path, line, data, x) {\n\n  // push a new data point onto the back\n  data.push(random());\n\n  // redraw the line, and then slide it to the left\n  path\n      .attr(\"d\", line)\n      .attr(\"transform\", null)\n    .transition()\n      .duration(750)\n      .ease(\"linear\")\n      .attr(\"transform\", \"translate(\" + x(-1) + \")\")\n      .each(\"end\", function() { tick(path, line, data, x); });\n\n  // pop the old data point off the front\n  data.shift();\n\n});\n\n</script>\n\n<p>The relevant code is only slightly changed from the original excerpt:\n\n<pre><code>// push a new data point onto the back\ndata.push(random());\n\n// redraw the line, and then slide it to the left\npath\n    .attr(\"d\", line)\n    .attr(\"transform\", null)\n  .transition()\n    .ease(\"linear\")\n    .attr(\"transform\", \"translate(\" + x(-1) + \")\");\n\n// pop the old data point off the front\ndata.shift();\n</code></pre>\n\n<aside>Here <code>x</code> is a <a href=\"https://github.com/mbostock/d3/wiki/Quantitative-Scales\">quantitative scale</a> that encodes the <i>x</i>-position. The value of <code>x(-1)</code> is about -24, which is the distance between control points in <i>x</i>.</aside>\n\n<p>When a new data point arrives, we redraw the line instantaneously and remove the previous transform (if any). The new data point is thus initially invisible off the right edge of the chart. Then, we animate the <i>x</i>-offset of the path element from 0 to some negative value, causing it to slide left.\n\n<p>While conceptually simple, there are some nuances of this approach:\n\n<p>First, you should use <b>linear easing</b> so that the speed of the continuously-changing transform remains constant. If you use the default cubic-in-out easing, then the transition velocity will oscillate and again be distracting.\n\n<p>Second, since the entering data point is drawn off the right edge, you’ll need a <b><a href=\"http://www.w3.org/TR/SVG/masking.html#ClippingPaths\">clip path</a></b>. In the above example, we use:\n\n<pre><code class=\"html\">&lt;defs&gt;\n  &lt;clipPath id=\"clip\"&gt;\n    &lt;rect width=\"950\" height=\"90\"&gt;&lt;/rect&gt;\n  &lt;/clipPath&gt;\n&lt;/defs&gt;</code></pre>\n\n<p>Lastly, if you’re using <b>spline interpolation</b> for the path data, then note that adding a control data point changes the tangents of the previous control point, and thus the shape of the associated segments. To avoid another wiggle when the control points are changed, further restrict the visible region (the <i>x</i>-domain) so that the extra control point is hidden:\n\n<script>\n\nchart([1, n - 2], \"basis\", function tick(path, line, data, x) {\n\n  // push a new data point onto the back\n  data.push(random());\n\n  // redraw the line, and then slide it to the left\n  path\n      .attr(\"d\", line)\n      .attr(\"transform\", null)\n    .transition()\n      .duration(750)\n      .ease(\"linear\")\n      .attr(\"transform\", \"translate(\" + x(0) + \")\")\n      .each(\"end\", function() { tick(path, line, data, x); });\n\n  // pop the old data point off the front\n  data.shift();\n\n});\n\n</script>\n\n<p>If you like, you can also combine this technique with D3’s built-in <a href=\"https://github.com/mbostock/d3/wiki/SVG-Axes\">axes</a> and <a href=\"https://github.com/mbostock/d3/wiki/Time-Scales\">time scales</a>. This chart, for example, shows your scrolling activity while reading this document over the last three minutes:\n\n<script>(function() {\n\nvar n = 243,\n    duration = 750,\n    now = new Date(Date.now() - duration),\n    count = 0,\n    data = d3.range(n).map(function() { return 0; });\n\nvar margin = {top: 6, right: 0, bottom: 20, left: 40},\n    width = 960 - margin.right,\n    height = 120 - margin.top - margin.bottom;\n\nvar x = d3.time.scale()\n    .domain([now - (n - 2) * duration, now - duration])\n    .range([0, width]);\n\nvar y = d3.scale.linear()\n    .range([height, 0]);\n\nvar line = d3.svg.line()\n    .interpolate(\"basis\")\n    .x(function(d, i) { return x(now - (n - 1 - i) * duration); })\n    .y(function(d, i) { return y(d); });\n\nvar svg = d3.select(\"body\").append(\"p\").append(\"svg\")\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .style(\"margin-left\", -margin.left + \"px\")\n  .append(\"g\")\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nsvg.append(\"defs\").append(\"clipPath\")\n    .attr(\"id\", \"clip\")\n  .append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\nvar axis = svg.append(\"g\")\n    .attr(\"class\", \"x axis\")\n    .attr(\"transform\", \"translate(0,\" + height + \")\")\n    .call(x.axis = d3.svg.axis().scale(x).orient(\"bottom\"));\n\nvar path = svg.append(\"g\")\n    .attr(\"clip-path\", \"url(#clip)\")\n  .append(\"path\")\n    .data([data])\n    .attr(\"class\", \"line\");\n\ntick();\n\nd3.select(window)\n    .on(\"scroll\", function() { ++count; });\n\nfunction tick() {\n\n  // update the domains\n  now = new Date();\n  x.domain([now - (n - 2) * duration, now - duration]);\n  y.domain([0, d3.max(data)]);\n\n  // push the accumulated count onto the back, and reset the count\n  data.push(Math.min(30, count));\n  count = 0;\n\n  // redraw the line\n  svg.select(\".line\")\n      .attr(\"d\", line)\n      .attr(\"transform\", null);\n\n  // slide the x-axis left\n  axis.transition()\n      .duration(duration)\n      .ease(\"linear\")\n      .call(x.axis);\n\n  // slide the line left\n  path.transition()\n      .duration(duration)\n      .ease(\"linear\")\n      .attr(\"transform\", \"translate(\" + x(now - (n - 1) * duration) + \")\")\n      .each(\"end\", tick);\n\n  // pop the old data point off the front\n  data.shift();\n\n}\n\n})()</script>\n\n<p>Notice that the exiting tick marks smoothly fade-out, while the entering tick marks smoothly fade-in; this is handled automatically by the axis component. The process for transitioning the axis is the same as for the transform: update the scale’s domain, then apply linear easing.\n\n<p>Questions or comments? These examples are available as <a href=\"https://gist.github.com/1642874\">GitHub gists</a>. Find me on <a href=\"http://twitter.com/mbostock\">Twitter</a> or stop by the <a href=\"https://groups.google.com/group/d3-js\">d3-js group</a>.\n\n<footer>\n  <aside>January 19, 2012</aside>\n  <a href=\"http://bost.ocks.org/mike\">Mike Bostock</a>\n</footer>\n\n<script src=\"../highlight.min.js\"></script>\n",
      "language": "HTML"
    },
    ".gitignore": {
      "type": "text/plain",
      "filename": ".gitignore",
      "raw_url": "https://gist.github.com/raw/2366983/86ddb2374d1fac25691f714c9aa949986b8fecf9/.gitignore",
      "size": 623,
      "content": "*.bak\n*~\n*.exe\n*.o\n*.a\n*.depend\n*.layout\n*.res\n*.user\n*.ncb\n\nmongoose-hg/*\nmongoose-tmp/\ngerhobbelt-github-mongoose/\n\ngerhobbelt-mongoose-issue-360/\nmongoose-issue360/\ngerhobbelt-issue349/\nmongoose-issue349/\n\nbuild/msvc2010/bin/\nbuild/msvc2010/obj/\nbuild/msvc2010/ipch/\n\nbuild/msvc2008/bin/\nbuild/msvc2008/obj/\nbuild/msvc2008/ipch/\n\n*.suo\n*.sdf\n*.opensdf\n\nhtml/contact/images/_vti_cnf\nhtml/contact/_vti_cnf\nhtml/dev/_vti_cnf\nhtml/faking_it/_vti_cnf\nhtml/images/_vti_cnf\nhtml/overview/images/_vti_cnf\nhtml/overview/_vti_cnf\nhtml/styles/_vti_cnf\nhtml/trading/_vti_cnf\nhtml/_vti_cnf\nhtml/_vti_pvt\nhtml/mongoose/_vti_cnf\n\nlog/\n",
      "language": null
    }
  },
  "updated_at": "2012-09-09T08:49:29Z",
  "url": "https://api.github.com/gists/2366983",
  "id": "2366983"
}
