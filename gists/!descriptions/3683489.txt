{
  "forks": [

  ],
  "user": {
    "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
    "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
    "login": "GerHobbelt",
    "url": "https://api.github.com/users/GerHobbelt",
    "id": 402462
  },
  "git_pull_url": "git://gist.github.com/3683489.git",
  "history": [
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "login": "GerHobbelt",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "7ca48207fe49da07073afb6dd5e9ebe0b553e07f",
      "change_status": {
        "total": 7305,
        "additions": 7304,
        "deletions": 1
      },
      "url": "https://api.github.com/gists/3683489/7ca48207fe49da07073afb6dd5e9ebe0b553e07f",
      "committed_at": "2012-09-09T10:02:03Z"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "login": "GerHobbelt",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "5e2915d766cd7169d0bcca4feef9db8df650a90a",
      "change_status": {
        "total": 1,
        "additions": 1,
        "deletions": 0
      },
      "url": "https://api.github.com/gists/3683489/5e2915d766cd7169d0bcca4feef9db8df650a90a",
      "committed_at": "2012-09-09T09:35:53Z"
    }
  ],
  "description": "d3.js: Mike Bostocks talk (2011/09) as gist (force layout with multiple foci examples)",
  "html_url": "https://gist.github.com/3683489",
  "git_push_url": "git@gist.github.com:3683489.git",
  "comments": 0,
  "created_at": "2012-09-09T09:35:53Z",
  "public": true,
  "files": {
    "style.css": {
      "type": "text/css",
      "filename": "style.css",
      "size": 577,
      "content": "body {\n  overflow: hidden;\n  margin: 0;\n  font: 14px \"Helvetica Neue\";\n}\n\nsvg {\n  width: 1280px;\n  height: 800px;\n}\n\n#chart, #header {\n  position: absolute;\n  top: 0;\n}\n\n#header {\n  z-index: 1;\n  display: block;\n}\n\n#header {\n  top: 80px;\n  left: 140px;\n  font: 300 36px \"Helvetica Neue\";\n}\n\nrect {\n  fill: none;\n  pointer-events: all;\n}\n\npre {\n  font-size: 18px;\n}\n\nline {\n  stroke: #000;\n  stroke-width: 1.5px;\n}\n\n.string, .regexp {\n  color: #f39;\n}\n\n.keyword {\n  color: #00c;\n}\n\n.comment {\n  color: #555;\n}\n\n.number {\n  color: #369;\n}\n\n.class, .special {\n  color: #1181B8;\n}\n",
      "raw_url": "https://gist.github.com/raw/3683489/9a21e75b1e815f7d844b2b88b3dd85a0959a858d/style.css",
      "language": "CSS"
    },
    "d3.layout.js": {
      "type": "application/javascript",
      "filename": "d3.layout.js",
      "size": 47862,
      "content": "(function(){d3.layout = {};\n// Implements hierarchical edge bundling using Holten's algorithm. For each\n// input link, a path is computed that travels through the tree, up the parent\n// hierarchy to the least common ancestor, and then back down to the destination\n// node. Each path is simply an array of nodes.\nd3.layout.bundle = function() {\n  return function(links) {\n    var paths = [],\n        i = -1,\n        n = links.length;\n    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n    return paths;\n  };\n};\n\nfunction d3_layout_bundlePath(link) {\n  var start = link.source,\n      end = link.target,\n      lca = d3_layout_bundleLeastCommonAncestor(start, end),\n      points = [start];\n  while (start !== lca) {\n    start = start.parent;\n    points.push(start);\n  }\n  var k = points.length;\n  while (end !== lca) {\n    points.splice(k, 0, end);\n    end = end.parent;\n  }\n  return points;\n}\n\nfunction d3_layout_bundleAncestors(node) {\n  var ancestors = [],\n      parent = node.parent;\n  while (parent != null) {\n    ancestors.push(node);\n    node = parent;\n    parent = parent.parent;\n  }\n  ancestors.push(node);\n  return ancestors;\n}\n\nfunction d3_layout_bundleLeastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = d3_layout_bundleAncestors(a),\n      bNodes = d3_layout_bundleAncestors(b),\n      aNode = aNodes.pop(),\n      bNode = bNodes.pop(),\n      sharedNode = null;\n  while (aNode === bNode) {\n    sharedNode = aNode;\n    aNode = aNodes.pop();\n    bNode = bNodes.pop();\n  }\n  return sharedNode;\n}\nd3.layout.chord = function() {\n  var chord = {},\n      chords,\n      groups,\n      matrix,\n      n,\n      padding = 0,\n      sortGroups,\n      sortSubgroups,\n      sortChords;\n\n  function relayout() {\n    var subgroups = {},\n        groupSums = [],\n        groupIndex = d3.range(n),\n        subgroupIndex = [],\n        k,\n        x,\n        x0,\n        i,\n        j;\n\n    chords = [];\n    groups = [];\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(d3.range(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) {\n      groupIndex.sort(function(a, b) {\n        return sortGroups(groupSums[a], groupSums[b]);\n      });\n    }\n\n    // Sort subgroups…\n    if (sortSubgroups) {\n      subgroupIndex.forEach(function(d, i) {\n        d.sort(function(a, b) {\n          return sortSubgroups(matrix[i][a], matrix[i][b]);\n        });\n      });\n    }\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified.\n    // TODO Allow padding to be specified as percentage?\n    k = (2 * Math.PI - padding * n) / k;\n\n    // Compute the start and end angle for each group and subgroup.\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[i][j],\n            v = matrix[di][dj];\n        subgroups[di + \"-\" + dj] = {\n          index: di,\n          subindex: dj,\n          startAngle: x,\n          endAngle: x += v * k,\n          value: v\n        };\n      }\n      groups.push({\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: (x - x0) / k\n      });\n      x += padding;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[i + \"-\" + j],\n            target = subgroups[j + \"-\" + i];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    if (sortChords) resort();\n  }\n\n  function resort() {\n    chords.sort(function(a, b) {\n      return sortChords(a.target.value, b.target.value);\n    });\n  }\n\n  chord.matrix = function(x) {\n    if (!arguments.length) return matrix;\n    n = (matrix = x) && matrix.length;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.padding = function(x) {\n    if (!arguments.length) return padding;\n    padding = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortGroups = function(x) {\n    if (!arguments.length) return sortGroups;\n    sortGroups = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortSubgroups = function(x) {\n    if (!arguments.length) return sortSubgroups;\n    sortSubgroups = x;\n    chords = null;\n    return chord;\n  };\n\n  chord.sortChords = function(x) {\n    if (!arguments.length) return sortChords;\n    sortChords = x;\n    if (chords) resort();\n    return chord;\n  };\n\n  chord.chords = function() {\n    if (!chords) relayout();\n    return chords;\n  };\n\n  chord.groups = function() {\n    if (!groups) relayout();\n    return groups;\n  };\n\n  return chord;\n};\n// A rudimentary force layout using Gauss-Seidel.\nd3.layout.force = function() {\n  var force = {},\n      event = d3.dispatch(\"tick\"),\n      size = [1, 1],\n      drag,\n      alpha,\n      friction = .9,\n      linkDistance = d3_layout_forceLinkDistance,\n      linkStrength = d3_layout_forceLinkStrength,\n      charge = -30,\n      gravity = .1,\n      theta = .8,\n      interval,\n      nodes = [],\n      links = [],\n      distances,\n      strengths,\n      charges;\n\n  function repulse(node) {\n    return function(quad, x1, y1, x2, y2) {\n      if (quad.point !== node) {\n        var dx = quad.cx - node.x,\n            dy = quad.cy - node.y,\n            dn = 1 / Math.sqrt(dx * dx + dy * dy);\n\n        /* Barnes-Hut criterion. */\n        if ((x2 - x1) * dn < theta) {\n          var k = quad.charge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n          return true;\n        }\n\n        if (quad.point && isFinite(dn)) {\n          var k = quad.pointCharge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n        }\n      }\n      return !quad.charge;\n    };\n  }\n\n  function tick() {\n    var n = nodes.length,\n        m = links.length,\n        q,\n        i, // current index\n        o, // current object\n        s, // current source\n        t, // current target\n        l, // current distance\n        k, // current force\n        x, // x-distance\n        y; // y-distance\n\n    // gauss-seidel relaxation for links\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      s = o.source;\n      t = o.target;\n      x = t.x - s.x;\n      y = t.y - s.y;\n      if (l = (x * x + y * y)) {\n        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n        x *= l;\n        y *= l;\n        t.x -= x * (k = s.weight / (t.weight + s.weight));\n        t.y -= y * k;\n        s.x += x * (k = 1 - k);\n        s.y += y * k;\n      }\n    }\n\n    // apply gravity forces\n    if (k = alpha * gravity) {\n      x = size[0] / 2;\n      y = size[1] / 2;\n      i = -1; if (k) while (++i < n) {\n        o = nodes[i];\n        o.x += (x - o.x) * k;\n        o.y += (y - o.y) * k;\n      }\n    }\n\n    // compute quadtree center of mass and apply charge forces\n    if (charge) {\n      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n      i = -1; while (++i < n) {\n        if (!(o = nodes[i]).fixed) {\n          q.visit(repulse(o));\n        }\n      }\n    }\n\n    // position verlet integration\n    i = -1; while (++i < n) {\n      o = nodes[i];\n      if (o.fixed) {\n        o.x = o.px;\n        o.y = o.py;\n      } else {\n        o.x -= (o.px - (o.px = o.x)) * friction;\n        o.y -= (o.py - (o.py = o.y)) * friction;\n      }\n    }\n\n    event.tick.dispatch({type: \"tick\", alpha: alpha});\n\n    // simulated annealing, basically\n    return (alpha *= .99) < .005;\n  }\n\n  force.on = function(type, listener) {\n    event[type].add(listener);\n    return force;\n  };\n\n  force.nodes = function(x) {\n    if (!arguments.length) return nodes;\n    nodes = x;\n    return force;\n  };\n\n  force.links = function(x) {\n    if (!arguments.length) return links;\n    links = x;\n    return force;\n  };\n\n  force.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return force;\n  };\n\n  force.linkDistance = function(x) {\n    if (!arguments.length) return linkDistance;\n    linkDistance = d3.functor(x);\n    return force;\n  };\n\n  // For backwards-compatibility.\n  force.distance = force.linkDistance;\n\n  force.linkStrength = function(x) {\n    if (!arguments.length) return linkStrength;\n    linkStrength = d3.functor(x);\n    return force;\n  };\n\n  force.friction = function(x) {\n    if (!arguments.length) return friction;\n    friction = x;\n    return force;\n  };\n\n  force.charge = function(x) {\n    if (!arguments.length) return charge;\n    charge = typeof x === \"function\" ? x : +x;\n    return force;\n  };\n\n  force.gravity = function(x) {\n    if (!arguments.length) return gravity;\n    gravity = x;\n    return force;\n  };\n\n  force.theta = function(x) {\n    if (!arguments.length) return theta;\n    theta = x;\n    return force;\n  };\n\n  force.start = function() {\n    var i,\n        j,\n        n = nodes.length,\n        m = links.length,\n        w = size[0],\n        h = size[1],\n        neighbors,\n        o;\n\n    for (i = 0; i < n; ++i) {\n      (o = nodes[i]).index = i;\n      o.weight = 0;\n    }\n\n    distances = [];\n    strengths = [];\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      if (typeof o.source == \"number\") o.source = nodes[o.source];\n      if (typeof o.target == \"number\") o.target = nodes[o.target];\n      distances[i] = linkDistance.call(this, o, i);\n      strengths[i] = linkStrength.call(this, o, i);\n      ++o.source.weight;\n      ++o.target.weight;\n    }\n\n    for (i = 0; i < n; ++i) {\n      o = nodes[i];\n      if (isNaN(o.x)) o.x = position(\"x\", w);\n      if (isNaN(o.y)) o.y = position(\"y\", h);\n      if (isNaN(o.px)) o.px = o.x;\n      if (isNaN(o.py)) o.py = o.y;\n    }\n\n    charges = [];\n    if (typeof charge === \"function\") {\n      for (i = 0; i < n; ++i) {\n        charges[i] = +charge.call(this, nodes[i], i);\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        charges[i] = charge;\n      }\n    }\n\n    // initialize node position based on first neighbor\n    function position(dimension, size) {\n      var neighbors = neighbor(i),\n          j = -1,\n          m = neighbors.length,\n          x;\n      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;\n      return Math.random() * size;\n    }\n\n    // initialize neighbors lazily\n    function neighbor() {\n      if (!neighbors) {\n        neighbors = [];\n        for (j = 0; j < n; ++j) {\n          neighbors[j] = [];\n        }\n        for (j = 0; j < m; ++j) {\n          var o = links[j];\n          neighbors[o.source.index].push(o.target);\n          neighbors[o.target.index].push(o.source);\n        }\n      }\n      return neighbors[i];\n    }\n\n    return force.resume();\n  };\n\n  force.resume = function() {\n    alpha = .1;\n    d3.timer(tick);\n    return force;\n  };\n\n  force.stop = function() {\n    alpha = 0;\n    return force;\n  };\n\n  // use `node.call(force.drag)` to make nodes draggable\n  force.drag = function() {\n    if (!drag) drag = d3.behavior.drag()\n        .on(\"dragstart\", dragstart)\n        .on(\"drag\", d3_layout_forceDrag)\n        .on(\"dragend\", d3_layout_forceDragEnd);\n\n    this.on(\"mouseover.force\", d3_layout_forceDragOver)\n        .on(\"mouseout.force\", d3_layout_forceDragOut)\n        .call(drag);\n  };\n\n  function dragstart(d) {\n    d3_layout_forceDragOver(d3_layout_forceDragNode = d);\n    d3_layout_forceDragForce = force;\n  }\n\n  return force;\n};\n\nvar d3_layout_forceDragForce,\n    d3_layout_forceDragNode;\n\nfunction d3_layout_forceDragOver(d) {\n  d.fixed |= 2;\n}\n\nfunction d3_layout_forceDragOut(d) {\n  if (d !== d3_layout_forceDragNode) d.fixed &= 1;\n}\n\nfunction d3_layout_forceDragEnd() {\n  d3_layout_forceDrag();\n  d3_layout_forceDragNode.fixed &= 1;\n  d3_layout_forceDragForce = d3_layout_forceDragNode = null;\n}\n\nfunction d3_layout_forceDrag() {\n  d3_layout_forceDragNode.px += d3.event.dx;\n  d3_layout_forceDragNode.py += d3.event.dy;\n  d3_layout_forceDragForce.resume(); // restart annealing\n}\n\nfunction d3_layout_forceAccumulate(quad, alpha, charges) {\n  var cx = 0,\n      cy = 0;\n  quad.charge = 0;\n  if (!quad.leaf) {\n    var nodes = quad.nodes,\n        n = nodes.length,\n        i = -1,\n        c;\n    while (++i < n) {\n      c = nodes[i];\n      if (c == null) continue;\n      d3_layout_forceAccumulate(c, alpha, charges);\n      quad.charge += c.charge;\n      cx += c.charge * c.cx;\n      cy += c.charge * c.cy;\n    }\n  }\n  if (quad.point) {\n    // jitter internal nodes that are coincident\n    if (!quad.leaf) {\n      quad.point.x += Math.random() - .5;\n      quad.point.y += Math.random() - .5;\n    }\n    var k = alpha * charges[quad.point.index];\n    quad.charge += quad.pointCharge = k;\n    cx += k * quad.point.x;\n    cy += k * quad.point.y;\n  }\n  quad.cx = cx / quad.charge;\n  quad.cy = cy / quad.charge;\n}\n\nfunction d3_layout_forceLinkDistance(link) {\n  return 20;\n}\n\nfunction d3_layout_forceLinkStrength(link) {\n  return 1;\n}\nd3.layout.partition = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      size = [1, 1]; // width, height\n\n  function position(node, x, dx, dy) {\n    var children = node.children;\n    node.x = x;\n    node.y = node.depth * dy;\n    node.dx = dx;\n    node.dy = dy;\n    if (children) {\n      var i = -1,\n          n = children.length,\n          c,\n          d;\n      dx = node.value ? dx / node.value : 0;\n      while (++i < n) {\n        position(c = children[i], x, d = c.value * dx, dy);\n        x += d;\n      }\n    }\n  }\n\n  function depth(node) {\n    var children = node.children,\n        d = 0;\n    if (children) {\n      var i = -1,\n          n = children.length;\n      while (++i < n) d = Math.max(d, depth(children[i]));\n    }\n    return 1 + d;\n  }\n\n  function partition(d, i) {\n    var nodes = hierarchy.call(this, d, i);\n    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n    return nodes;\n  }\n\n  partition.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return partition;\n  };\n\n  return d3_layout_hierarchyRebind(partition, hierarchy);\n};\nd3.layout.pie = function() {\n  var value = Number,\n      sort = null,\n      startAngle = 0,\n      endAngle = 2 * Math.PI;\n\n  function pie(data, i) {\n\n    // Compute the start angle.\n    var a = +(typeof startAngle === \"function\"\n        ? startAngle.apply(this, arguments)\n        : startAngle);\n\n    // Compute the angular range (end - start).\n    var k = (typeof endAngle === \"function\"\n        ? endAngle.apply(this, arguments)\n        : endAngle) - startAngle;\n\n    // Optionally sort the data.\n    var index = d3.range(data.length);\n    if (sort != null) index.sort(function(i, j) {\n      return sort(data[i], data[j]);\n    });\n\n    // Compute the numeric values for each data element.\n    var values = data.map(value);\n\n    // Convert k into a scale factor from value to angle, using the sum.\n    k /= values.reduce(function(p, d) { return p + d; }, 0);\n\n    // Compute the arcs!\n    var arcs = index.map(function(i) {\n      return {\n        data: data[i],\n        value: d = values[i],\n        startAngle: a,\n        endAngle: a += d * k\n      };\n    });\n\n    // Return the arcs in the original data's order.\n    return data.map(function(d, i) {\n      return arcs[index[i]];\n    });\n  }\n\n  /**\n   * Specifies the value function *x*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `Number`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  pie.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return pie;\n  };\n\n  /**\n   * Specifies a sort comparison operator *x*. The comparator is passed two data\n   * elements from the data array, a and b; it returns a negative value if a is\n   * less than b, a positive value if a is greater than b, and zero if a equals\n   * b.\n   */\n  pie.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall start angle of the pie chart. Defaults to 0. The\n   * start angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.startAngle = function(x) {\n    if (!arguments.length) return startAngle;\n    startAngle = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall end angle of the pie chart. Defaults to 2π. The\n   * end angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.endAngle = function(x) {\n    if (!arguments.length) return endAngle;\n    endAngle = x;\n    return pie;\n  };\n\n  return pie;\n};\n// data is two-dimensional array of x,y; we populate y0\nd3.layout.stack = function() {\n  var values = Object,\n      order = d3_layout_stackOrders[\"default\"],\n      offset = d3_layout_stackOffsets[\"zero\"],\n      out = d3_layout_stackOut,\n      x = d3_layout_stackX,\n      y = d3_layout_stackY;\n\n  function stack(data, index) {\n\n    // Convert series to canonical two-dimensional representation.\n    var series = data.map(function(d, i) {\n      return values.call(stack, d, i);\n    });\n\n    // Convert each series to canonical [[x,y]] representation.\n    var points = series.map(function(d, i) {\n      return d.map(function(v, i) {\n        return [x.call(stack, v, i), y.call(stack, v, i)];\n      });\n    });\n\n    // Compute the order of series, and permute them.\n    var orders = order.call(stack, points, index);\n    series = d3.permute(series, orders);\n    points = d3.permute(points, orders);\n\n    // Compute the baseline…\n    var offsets = offset.call(stack, points, index);\n\n    // And propagate it to other series.\n    var n = series.length,\n        m = series[0].length,\n        i,\n        j,\n        o;\n    for (j = 0; j < m; ++j) {\n      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n      for (i = 1; i < n; ++i) {\n        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n      }\n    }\n\n    return data;\n  }\n\n  stack.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return stack;\n  };\n\n  stack.order = function(x) {\n    if (!arguments.length) return order;\n    order = typeof x === \"function\" ? x : d3_layout_stackOrders[x];\n    return stack;\n  };\n\n  stack.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = typeof x === \"function\" ? x : d3_layout_stackOffsets[x];\n    return stack;\n  };\n\n  stack.x = function(z) {\n    if (!arguments.length) return x;\n    x = z;\n    return stack;\n  };\n\n  stack.y = function(z) {\n    if (!arguments.length) return y;\n    y = z;\n    return stack;\n  };\n\n  stack.out = function(z) {\n    if (!arguments.length) return out;\n    out = z;\n    return stack;\n  };\n\n  return stack;\n}\n\nfunction d3_layout_stackX(d) {\n  return d.x;\n}\n\nfunction d3_layout_stackY(d) {\n  return d.y;\n}\n\nfunction d3_layout_stackOut(d, y0, y) {\n  d.y0 = y0;\n  d.y = y;\n}\n\nvar d3_layout_stackOrders = {\n\n  \"inside-out\": function(data) {\n    var n = data.length,\n        i,\n        j,\n        max = data.map(d3_layout_stackMaxIndex),\n        sums = data.map(d3_layout_stackReduceSum),\n        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),\n        top = 0,\n        bottom = 0,\n        tops = [],\n        bottoms = [];\n    for (i = 0; i < n; ++i) {\n      j = index[i];\n      if (top < bottom) {\n        top += sums[j];\n        tops.push(j);\n      } else {\n        bottom += sums[j];\n        bottoms.push(j);\n      }\n    }\n    return bottoms.reverse().concat(tops);\n  },\n\n  \"reverse\": function(data) {\n    return d3.range(data.length).reverse();\n  },\n\n  \"default\": function(data) {\n    return d3.range(data.length);\n  }\n\n};\n\nvar d3_layout_stackOffsets = {\n\n  \"silhouette\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        sums = [],\n        max = 0,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o > max) max = o;\n      sums.push(o);\n    }\n    for (j = 0; j < m; ++j) {\n      y0[j] = (max - sums[j]) / 2;\n    }\n    return y0;\n  },\n\n  \"wiggle\": function(data) {\n    var n = data.length,\n        x = data[0],\n        m = x.length,\n        max = 0,\n        i,\n        j,\n        k,\n        s1,\n        s2,\n        s3,\n        dx,\n        o,\n        o0,\n        y0 = [];\n    y0[0] = o = o0 = 0;\n    for (j = 1; j < m; ++j) {\n      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n        }\n        s2 += s3 * data[i][j][1];\n      }\n      y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n      if (o < o0) o0 = o;\n    }\n    for (j = 0; j < m; ++j) y0[j] -= o0;\n    return y0;\n  },\n\n  \"expand\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        k = 1 / n,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;\n      else for (i = 0; i < n; i++) data[i][j][1] = k;\n    }\n    for (j = 0; j < m; ++j) y0[j] = 0;\n    return y0;\n  },\n\n  \"zero\": function(data) {\n    var j = -1,\n        m = data[0].length,\n        y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n\n};\n\nfunction d3_layout_stackMaxIndex(array) {\n  var i = 1,\n      j = 0,\n      v = array[0][1],\n      k,\n      n = array.length;\n  for (; i < n; ++i) {\n    if ((k = array[i][1]) > v) {\n      j = i;\n      v = k;\n    }\n  }\n  return j;\n}\n\nfunction d3_layout_stackReduceSum(d) {\n  return d.reduce(d3_layout_stackSum, 0);\n}\n\nfunction d3_layout_stackSum(p, d) {\n  return p + d[1];\n}\nd3.layout.histogram = function() {\n  var frequency = true,\n      valuer = Number,\n      ranger = d3_layout_histogramRange,\n      binner = d3_layout_histogramBinSturges;\n\n  function histogram(data, i) {\n    var bins = [],\n        values = data.map(valuer, this),\n        range = ranger.call(this, values, i),\n        thresholds = binner.call(this, range, values, i),\n        bin,\n        i = -1,\n        n = values.length,\n        m = thresholds.length - 1,\n        k = frequency ? 1 : 1 / n,\n        x;\n\n    // Initialize the bins.\n    while (++i < m) {\n      bin = bins[i] = [];\n      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n      bin.y = 0;\n    }\n\n    // Fill the bins, ignoring values outside the range.\n    i = -1; while(++i < n) {\n      x = values[i];\n      if ((x >= range[0]) && (x <= range[1])) {\n        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n        bin.y += k;\n        bin.push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  // Specifies how to extract a value from the associated data. The default\n  // value function is `Number`, which is equivalent to the identity function.\n  histogram.value = function(x) {\n    if (!arguments.length) return valuer;\n    valuer = x;\n    return histogram;\n  };\n\n  // Specifies the range of the histogram. Values outside the specified range\n  // will be ignored. The argument `x` may be specified either as a two-element\n  // array representing the minimum and maximum value of the range, or as a\n  // function that returns the range given the array of values and the current\n  // index `i`. The default range is the extent (minimum and maximum) of the\n  // values.\n  histogram.range = function(x) {\n    if (!arguments.length) return ranger;\n    ranger = d3.functor(x);\n    return histogram;\n  };\n\n  // Specifies how to bin values in the histogram. The argument `x` may be\n  // specified as a number, in which case the range of values will be split\n  // uniformly into the given number of bins. Or, `x` may be an array of\n  // threshold values, defining the bins; the specified array must contain the\n  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`\n  // may be a function which is evaluated, being passed the range, the array of\n  // values, and the current index `i`, returning an array of thresholds. The\n  // default bin function will divide the values into uniform bins using\n  // Sturges' formula.\n  histogram.bins = function(x) {\n    if (!arguments.length) return binner;\n    binner = typeof x === \"number\"\n        ? function(range) { return d3_layout_histogramBinFixed(range, x); }\n        : d3.functor(x);\n    return histogram;\n  };\n\n  // Specifies whether the histogram's `y` value is a count (frequency) or a\n  // probability (density). The default value is true.\n  histogram.frequency = function(x) {\n    if (!arguments.length) return frequency;\n    frequency = !!x;\n    return histogram;\n  };\n\n  return histogram;\n};\n\nfunction d3_layout_histogramBinSturges(range, values) {\n  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n}\n\nfunction d3_layout_histogramBinFixed(range, n) {\n  var x = -1,\n      b = +range[0],\n      m = (range[1] - b) / n,\n      f = [];\n  while (++x <= n) f[x] = m * x + b;\n  return f;\n}\n\nfunction d3_layout_histogramRange(values) {\n  return [d3.min(values), d3.max(values)];\n}\nd3.layout.hierarchy = function() {\n  var sort = d3_layout_hierarchySort,\n      children = d3_layout_hierarchyChildren,\n      value = d3_layout_hierarchyValue;\n\n  // Recursively compute the node depth and value.\n  // Also converts the data representation into a standard hierarchy structure.\n  function recurse(data, depth, nodes) {\n    var childs = children.call(hierarchy, data, depth),\n        node = d3_layout_hierarchyInline ? data : {data: data};\n    node.depth = depth;\n    nodes.push(node);\n    if (childs && (n = childs.length)) {\n      var i = -1,\n          n,\n          c = node.children = [],\n          v = 0,\n          j = depth + 1;\n      while (++i < n) {\n        d = recurse(childs[i], j, nodes);\n        d.parent = node;\n        c.push(d);\n        v += d.value;\n      }\n      if (sort) c.sort(sort);\n      if (value) node.value = v;\n    } else if (value) {\n      node.value = +value.call(hierarchy, data, depth) || 0;\n    }\n    return node;\n  }\n\n  // Recursively re-evaluates the node value.\n  function revalue(node, depth) {\n    var children = node.children,\n        v = 0;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n,\n          j = depth + 1;\n      while (++i < n) v += revalue(children[i], j);\n    } else if (value) {\n      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;\n    }\n    if (value) node.value = v;\n    return v;\n  }\n\n  function hierarchy(d) {\n    var nodes = [];\n    recurse(d, 0, nodes);\n    return nodes;\n  }\n\n  hierarchy.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return hierarchy;\n  };\n\n  hierarchy.children = function(x) {\n    if (!arguments.length) return children;\n    children = x;\n    return hierarchy;\n  };\n\n  hierarchy.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return hierarchy;\n  };\n\n  // Re-evaluates the `value` property for the specified hierarchy.\n  hierarchy.revalue = function(root) {\n    revalue(root, 0);\n    return root;\n  };\n\n  return hierarchy;\n};\n\n// A method assignment helper for hierarchy subclasses.\nfunction d3_layout_hierarchyRebind(object, hierarchy) {\n  object.sort = d3.rebind(object, hierarchy.sort);\n  object.children = d3.rebind(object, hierarchy.children);\n  object.links = d3_layout_hierarchyLinks;\n  object.value = d3.rebind(object, hierarchy.value);\n\n  // If the new API is used, enabling inlining.\n  object.nodes = function(d) {\n    d3_layout_hierarchyInline = true;\n    return (object.nodes = object)(d);\n  };\n\n  return object;\n}\n\nfunction d3_layout_hierarchyChildren(d) {\n  return d.children;\n}\n\nfunction d3_layout_hierarchyValue(d) {\n  return d.value;\n}\n\nfunction d3_layout_hierarchySort(a, b) {\n  return b.value - a.value;\n}\n\n// Returns an array source+target objects for the specified nodes.\nfunction d3_layout_hierarchyLinks(nodes) {\n  return d3.merge(nodes.map(function(parent) {\n    return (parent.children || []).map(function(child) {\n      return {source: parent, target: child};\n    });\n  }));\n}\n\n// For backwards-compatibility, don't enable inlining by default.\nvar d3_layout_hierarchyInline = false;\nd3.layout.pack = function() {\n  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n      size = [1, 1];\n\n  function pack(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    // Recursively compute the layout.\n    root.x = 0;\n    root.y = 0;\n    d3_layout_packTree(root);\n\n    // Scale the layout to fit the requested size.\n    var w = size[0],\n        h = size[1],\n        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);\n    d3_layout_packTransform(root, w / 2, h / 2, k);\n\n    return nodes;\n  }\n\n  pack.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return pack;\n  };\n\n  return d3_layout_hierarchyRebind(pack, hierarchy);\n};\n\nfunction d3_layout_packSort(a, b) {\n  return a.value - b.value;\n}\n\nfunction d3_layout_packInsert(a, b) {\n  var c = a._pack_next;\n  a._pack_next = b;\n  b._pack_prev = a;\n  b._pack_next = c;\n  c._pack_prev = b;\n}\n\nfunction d3_layout_packSplice(a, b) {\n  a._pack_next = b;\n  b._pack_prev = a;\n}\n\nfunction d3_layout_packIntersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return (dr * dr - dx * dx - dy * dy) > .001; // within epsilon\n}\n\nfunction d3_layout_packCircle(nodes) {\n  var xMin = Infinity,\n      xMax = -Infinity,\n      yMin = Infinity,\n      yMax = -Infinity,\n      n = nodes.length,\n      a, b, c, j, k;\n\n  function bound(node) {\n    xMin = Math.min(node.x - node.r, xMin);\n    xMax = Math.max(node.x + node.r, xMax);\n    yMin = Math.min(node.y - node.r, yMin);\n    yMax = Math.max(node.y + node.r, yMax);\n  }\n\n  // Create node links.\n  nodes.forEach(d3_layout_packLink);\n\n  // Create first node.\n  a = nodes[0];\n  a.x = -a.r;\n  a.y = 0;\n  bound(a);\n\n  // Create second node.\n  if (n > 1) {\n    b = nodes[1];\n    b.x = b.r;\n    b.y = 0;\n    bound(b);\n\n    // Create third node and build chain.\n    if (n > 2) {\n      c = nodes[2];\n      d3_layout_packPlace(a, b, c);\n      bound(c);\n      d3_layout_packInsert(a, c);\n      a._pack_prev = c;\n      d3_layout_packInsert(c, b);\n      b = a._pack_next;\n\n      // Now iterate through the rest.\n      for (var i = 3; i < n; i++) {\n        d3_layout_packPlace(a, b, c = nodes[i]);\n\n        // Search for the closest intersection.\n        var isect = 0, s1 = 1, s2 = 1;\n        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n          if (d3_layout_packIntersects(j, c)) {\n            isect = 1;\n            break;\n          }\n        }\n        if (isect == 1) {\n          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n            if (d3_layout_packIntersects(k, c)) {\n              if (s2 < s1) {\n                isect = -1;\n                j = k;\n              }\n              break;\n            }\n          }\n        }\n\n        // Update node chain.\n        if (isect == 0) {\n          d3_layout_packInsert(a, c);\n          b = c;\n          bound(c);\n        } else if (isect > 0) {\n          d3_layout_packSplice(a, j);\n          b = j;\n          i--;\n        } else { // isect < 0\n          d3_layout_packSplice(j, b);\n          a = j;\n          i--;\n        }\n      }\n    }\n  }\n\n  // Re-center the circles and return the encompassing radius.\n  var cx = (xMin + xMax) / 2,\n      cy = (yMin + yMax) / 2,\n      cr = 0;\n  for (var i = 0; i < n; i++) {\n    var node = nodes[i];\n    node.x -= cx;\n    node.y -= cy;\n    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));\n  }\n\n  // Remove node links.\n  nodes.forEach(d3_layout_packUnlink);\n\n  return cr;\n}\n\nfunction d3_layout_packLink(node) {\n  node._pack_next = node._pack_prev = node;\n}\n\nfunction d3_layout_packUnlink(node) {\n  delete node._pack_next;\n  delete node._pack_prev;\n}\n\nfunction d3_layout_packTree(node) {\n  var children = node.children;\n  if (children && children.length) {\n    children.forEach(d3_layout_packTree);\n    node.r = d3_layout_packCircle(children);\n  } else {\n    node.r = Math.sqrt(node.value);\n  }\n}\n\nfunction d3_layout_packTransform(node, x, y, k) {\n  var children = node.children;\n  node.x = (x += k * node.x);\n  node.y = (y += k * node.y);\n  node.r *= k;\n  if (children) {\n    var i = -1, n = children.length;\n    while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n  }\n}\n\nfunction d3_layout_packPlace(a, b, c) {\n  var db = a.r + c.r,\n      dx = b.x - a.x,\n      dy = b.y - a.y;\n  if (db && (dx || dy)) {\n    var da = b.r + c.r,\n        dc = Math.sqrt(dx * dx + dy * dy),\n        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),\n        theta = Math.acos(cos),\n        x = cos * (db /= dc),\n        y = Math.sin(theta) * db;\n    c.x = a.x + x * dx + y * dy;\n    c.y = a.y + x * dy - y * dx;\n  } else {\n    c.x = a.x + db;\n    c.y = a.y;\n  }\n}\n// Implements a hierarchical layout using the cluster (or dendogram) algorithm.\nd3.layout.cluster = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function cluster(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0],\n        previousNode,\n        x = 0,\n        kx,\n        ky;\n\n    // First walk, computing the initial x & y values.\n    d3_layout_treeVisitAfter(root, function(node) {\n      var children = node.children;\n      if (children && children.length) {\n        node.x = d3_layout_clusterX(children);\n        node.y = d3_layout_clusterY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_clusterLeft(root),\n        right = d3_layout_clusterRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = (1 - node.y / root.y) * size[1];\n    });\n\n    return nodes;\n  }\n\n  cluster.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return cluster;\n  };\n\n  cluster.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return cluster;\n  };\n\n  return d3_layout_hierarchyRebind(cluster, hierarchy);\n};\n\nfunction d3_layout_clusterY(children) {\n  return 1 + d3.max(children, function(child) {\n    return child.y;\n  });\n}\n\nfunction d3_layout_clusterX(children) {\n  return children.reduce(function(x, child) {\n    return x + child.x;\n  }, 0) / children.length;\n}\n\nfunction d3_layout_clusterLeft(node) {\n  var children = node.children;\n  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n}\n\nfunction d3_layout_clusterRight(node) {\n  var children = node.children, n;\n  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n}\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nd3.layout.tree = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function tree(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    function firstWalk(node, previousSibling) {\n      var children = node.children,\n          layout = node._tree;\n      if (children && (n = children.length)) {\n        var n,\n            firstChild = children[0],\n            previousChild,\n            ancestor = firstChild,\n            child,\n            i = -1;\n        while (++i < n) {\n          child = children[i];\n          firstWalk(child, previousChild);\n          ancestor = apportion(child, previousChild, ancestor);\n          previousChild = child;\n        }\n        d3_layout_treeShift(node);\n        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n          layout.mod = layout.prelim - midpoint;\n        } else {\n          layout.prelim = midpoint;\n        }\n      } else {\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n        }\n      }\n    }\n\n    function secondWalk(node, x) {\n      node.x = node._tree.prelim + x;\n      var children = node.children;\n      if (children) {\n        var i = -1,\n            n = children.length;\n        x += node._tree.mod;\n        while (++i < n) {\n          secondWalk(children[i], x);\n        }\n      }\n    }\n\n    function apportion(node, previousSibling, ancestor) {\n      if (previousSibling) {\n        var vip = node,\n            vop = node,\n            vim = previousSibling,\n            vom = node.parent.children[0],\n            sip = vip._tree.mod,\n            sop = vop._tree.mod,\n            sim = vim._tree.mod,\n            som = vom._tree.mod,\n            shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop._tree.ancestor = node;\n          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim._tree.mod;\n          sip += vip._tree.mod;\n          som += vom._tree.mod;\n          sop += vop._tree.mod;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop._tree.thread = vim;\n          vop._tree.mod += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom._tree.thread = vip;\n          vom._tree.mod += sip - som;\n          ancestor = node;\n        }\n      }\n      return ancestor;\n    }\n\n    // Initialize temporary layout variables.\n    d3_layout_treeVisitAfter(root, function(node, previousSibling) {\n      node._tree = {\n        ancestor: node,\n        prelim: 0,\n        mod: 0,\n        change: 0,\n        shift: 0,\n        number: previousSibling ? previousSibling._tree.number + 1 : 0\n      };\n    });\n\n    // Compute the layout using Buchheim et al.'s algorithm.\n    firstWalk(root);\n    secondWalk(root, -root._tree.prelim);\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\n        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\n        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2,\n        y1 = deep.depth || 1;\n\n    // Clear temporary layout variables; transform x and y.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = node.depth / y1 * size[1];\n      delete node._tree;\n    });\n\n    return nodes;\n  }\n\n  tree.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return tree;\n  };\n\n  tree.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return tree;\n  };\n\n  return d3_layout_hierarchyRebind(tree, hierarchy);\n};\n\nfunction d3_layout_treeSeparation(a, b) {\n  return a.parent == b.parent ? 1 : 2;\n}\n\n// function d3_layout_treeSeparationRadial(a, b) {\n//   return (a.parent == b.parent ? 1 : 2) / a.depth;\n// }\n\nfunction d3_layout_treeLeft(node) {\n  return node.children ? node.children[0] : node._tree.thread;\n}\n\nfunction d3_layout_treeRight(node) {\n  return node.children ? node.children[node.children.length - 1] : node._tree.thread;\n}\n\nfunction d3_layout_treeSearch(node, compare) {\n  var children = node.children;\n  if (children) {\n    var child,\n        n = children.length,\n        i = -1;\n    while (++i < n) {\n      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\n        node = child;\n      }\n    }\n  }\n  return node;\n}\n\nfunction d3_layout_treeRightmost(a, b) {\n  return a.x - b.x;\n}\n\nfunction d3_layout_treeLeftmost(a, b) {\n  return b.x - a.x;\n}\n\nfunction d3_layout_treeDeepest(a, b) {\n  return a.depth - b.depth;\n}\n\nfunction d3_layout_treeVisitAfter(node, callback) {\n  function visit(node, previousSibling) {\n    var children = node.children;\n    if (children) {\n      var child,\n          previousChild = null,\n          i = -1,\n          n = children.length;\n      while (++i < n) {\n        child = children[i];\n        visit(child, previousChild);\n        previousChild = child;\n      }\n    }\n    callback(node, previousSibling);\n  }\n  visit(node, null);\n}\n\nfunction d3_layout_treeShift(node) {\n  var shift = 0,\n      change = 0,\n      children = node.children,\n      i = children.length,\n      child;\n  while (--i >= 0) {\n    child = children[i]._tree;\n    child.prelim += shift;\n    child.mod += shift;\n    shift += child.shift + (change += child.change);\n  }\n}\n\nfunction d3_layout_treeMove(ancestor, node, shift) {\n  ancestor = ancestor._tree;\n  node = node._tree;\n  var change = shift / (node.number - ancestor.number);\n  ancestor.change += change;\n  node.change -= change;\n  node.shift += shift;\n  node.prelim += shift;\n  node.mod += shift;\n}\n\nfunction d3_layout_treeAncestor(vim, node, ancestor) {\n  return vim._tree.ancestor.parent == node.parent\n      ? vim._tree.ancestor\n      : ancestor;\n}\n// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n// Modified to support a target aspect ratio by Jeff Heer\nd3.layout.treemap = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      round = Math.round,\n      size = [1, 1], // width, height\n      padding = null,\n      pad = d3_layout_treemapPadNull,\n      sticky = false,\n      stickies,\n      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio\n\n  // Compute the area for each child based on value & scale.\n  function scale(children, k) {\n    var i = -1,\n        n = children.length,\n        child,\n        area;\n    while (++i < n) {\n      area = (child = children[i]).value * (k < 0 ? 0 : k);\n      child.area = isNaN(area) || area <= 0 ? 0 : area;\n    }\n  }\n\n  // Recursively arranges the specified node's children into squarified rows.\n  function squarify(node) {\n    if (!node.children) return;\n    var rect = pad(node),\n        row = [],\n        children = node.children.slice(), // copy-on-write\n        child,\n        best = Infinity, // the best row score so far\n        score, // the current row score\n        u = Math.min(rect.dx, rect.dy), // initial orientation\n        n;\n    scale(children, rect.dx * rect.dy / node.value);\n    row.area = 0;\n    while ((n = children.length) > 0) {\n      row.push(child = children[n - 1]);\n      row.area += child.area;\n      if ((score = worst(row, u)) <= best) { // continue with this orientation\n        children.pop();\n        best = score;\n      } else { // abort, and try a different orientation\n        row.area -= row.pop().area;\n        position(row, u, rect, false);\n        u = Math.min(rect.dx, rect.dy);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n    }\n    if (row.length) {\n      position(row, u, rect, true);\n      row.length = row.area = 0;\n    }\n    node.children.forEach(squarify);\n  }\n\n  // Recursively resizes the specified node's children into existing rows.\n  // Preserves the existing layout!\n  function stickify(node) {\n    if (!node.children) return;\n    var rect = pad(node),\n        children = node.children.slice(), // copy-on-write\n        child,\n        row = [];\n    scale(children, rect.dx * rect.dy / node.value);\n    row.area = 0;\n    while (child = children.pop()) {\n      row.push(child);\n      row.area += child.area;\n      if (child.z != null) {\n        position(row, child.z ? rect.dx : rect.dy, rect, !children.length);\n        row.length = row.area = 0;\n      }\n    }\n    node.children.forEach(stickify);\n  }\n\n  // Computes the score for the specified row, as the worst aspect ratio.\n  function worst(row, u) {\n    var s = row.area,\n        r,\n        rmax = 0,\n        rmin = Infinity,\n        i = -1,\n        n = row.length;\n    while (++i < n) {\n      if (!(r = row[i].area)) continue;\n      if (r < rmin) rmin = r;\n      if (r > rmax) rmax = r;\n    }\n    s *= s;\n    u *= u;\n    return s\n        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))\n        : Infinity;\n  }\n\n  // Positions the specified row of nodes. Modifies `rect`.\n  function position(row, u, rect, flush) {\n    var i = -1,\n        n = row.length,\n        x = rect.x,\n        y = rect.y,\n        v = u ? round(row.area / u) : 0,\n        o;\n    if (u == rect.dx) { // horizontal subdivision\n      if (flush || v > rect.dy) v = v ? rect.dy : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dy = v;\n        x += o.dx = v ? round(o.area / v) : 0;\n      }\n      o.z = true;\n      o.dx += rect.x + rect.dx - x; // rounding error\n      rect.y += v;\n      rect.dy -= v;\n    } else { // vertical subdivision\n      if (flush || v > rect.dx) v = v ? rect.dx : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dx = v;\n        y += o.dy = v ? round(o.area / v) : 0;\n      }\n      o.z = false;\n      o.dy += rect.y + rect.dy - y; // rounding error\n      rect.x += v;\n      rect.dx -= v;\n    }\n  }\n\n  function treemap(d) {\n    var nodes = stickies || hierarchy(d),\n        root = nodes[0];\n    root.x = 0;\n    root.y = 0;\n    root.dx = size[0];\n    root.dy = size[1];\n    if (stickies) hierarchy.revalue(root);\n    scale([root], root.dx * root.dy / root.value);\n    (stickies ? stickify : squarify)(root);\n    if (sticky) stickies = nodes;\n    return nodes;\n  }\n\n  treemap.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return treemap;\n  };\n\n  treemap.padding = function(x) {\n    if (!arguments.length) return padding;\n\n    function padFunction(node) {\n      var p = x.call(treemap, node, node.depth);\n      return p == null\n          ? d3_layout_treemapPadNull(node)\n          : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\n    }\n\n    function padConstant(node) {\n      return d3_layout_treemapPad(node, x);\n    }\n\n    var type;\n    pad = (padding = x) == null ? d3_layout_treemapPadNull\n        : (type = typeof x) === \"function\" ? padFunction\n        : type === \"number\" ? (x = [x, x, x, x], padConstant)\n        : padConstant;\n    return treemap;\n  };\n\n  treemap.round = function(x) {\n    if (!arguments.length) return round != Number;\n    round = x ? Math.round : Number;\n    return treemap;\n  };\n\n  treemap.sticky = function(x) {\n    if (!arguments.length) return sticky;\n    sticky = x;\n    stickies = null;\n    return treemap;\n  };\n\n  treemap.ratio = function(x) {\n    if (!arguments.length) return ratio;\n    ratio = x;\n    return treemap;\n  };\n\n  return d3_layout_hierarchyRebind(treemap, hierarchy);\n};\n\nfunction d3_layout_treemapPadNull(node) {\n  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};\n}\n\nfunction d3_layout_treemapPad(node, padding) {\n  var x = node.x + padding[3],\n      y = node.y + padding[0],\n      dx = node.dx - padding[1] - padding[3],\n      dy = node.dy - padding[0] - padding[2];\n  if (dx < 0) { x += dx / 2; dx = 0; }\n  if (dy < 0) { y += dy / 2; dy = 0; }\n  return {x: x, y: y, dx: dx, dy: dy};\n}\n})();\n",
      "raw_url": "https://gist.github.com/raw/3683489/bcfddc043beb5a6f5fc633e35d6e0c620e2a0357/d3.layout.js",
      "language": "JavaScript"
    },
    "README.md": {
      "type": "text/plain",
      "filename": "README.md",
      "size": 122,
      "content": "copy of the 2011/09 talk by Mike Bostock; very minor tweaks to make it run with the latest d3.v2.js in this gist setting.\n",
      "raw_url": "https://gist.github.com/raw/3683489/cba61476714f3ec099450ecc50a16f8630a9e5e5/README.md",
      "language": "Markdown"
    },
    "foci.htm": {
      "type": "text/html",
      "filename": "foci.htm",
      "size": 2332,
      "content": "<!DOCTYPE html>\n<!-- saved from url=(0067)http://mbostock.github.com/d3/talk/20110921/foci.html?1347142470398 -->\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    \n    <title>Force Layouts - Foci</title>\n    <script type=\"text/javascript\" src=\"http://d3js.org/d3.v2.js\"></script>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n    <style type=\"text/css\">\n\ncircle {\n  stroke: #fff;\n}\n\n    </style>\n  </head>\n  <body>\n    <div id=\"body\">\n      <div id=\"chart\">\n\t\t\t</div>\n      <div id=\"header\">categorical foci</div>\n    </div>\n    <script type=\"text/javascript\">\n\nvar w = 1280,\n    h = 800,\n    color = d3.scale.category10();\n\nvar force = d3.layout.force()\n    .gravity(0)\n    .charge(-10)\n    .size([w, h]);\n\nvar nodes = force.nodes(),\n    a = {type: 0, x: 3 * w / 6, y: 2 * h / 6, fixed: true},\n    b = {type: 1, x: 4 * w / 6, y: 4 * h / 6, fixed: true},\n    c = {type: 2, x: 2 * w / 6, y: 4 * h / 6, fixed: true};\n\nnodes.push(a, b, c);\n\nvar svg = d3.select(\"#chart\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.append(\"rect\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.selectAll(\"circle\")\n    .data(nodes)\n  .enter().append(\"circle\")\n    .attr(\"r\", 12)\n    .attr(\"cx\", function(d) { return d.x; })\n    .attr(\"cy\", function(d) { return d.y; })\n    .style(\"fill\", fill)\n    .call(force.drag);\n\nforce.on(\"tick\", function(e) {\n  var k = e.alpha * .1;\n  nodes.forEach(function(node) {\n    var center = nodes[node.type];\n    node.x += (center.x - node.x) * k;\n    node.y += (center.y - node.y) * k;\n  });\n\n  svg.selectAll(\"circle\")\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; });\n});\n\nvar p0;\n\nsvg.on(\"mousemove\", function() {\n  var p1 = d3.svg.mouse(this),\n      node = {type: Math.random() * 3 | 0, x: p1[0], y: p1[1], px: (p0 || (p0 = p1))[0], py: p0[1]};\n\n  p0 = p1;\n\n  svg.append(\"circle\")\n      .data([node])\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; })\n      .attr(\"r\", 4.5)\n      .style(\"fill\", fill)\n    .transition()\n      .delay(3000)\n      .attr(\"r\", 1e-6)\n      .each(\"end\", function() { nodes.splice(3, 1); })\n      .remove();\n\n  nodes.push(node);\n  force.start();\n});\n\nfunction fill(d) {\n  return color(d.type);\n}\n\n    </script>\n  \n\n</body></html>",
      "raw_url": "https://gist.github.com/raw/3683489/d86f475c3a3b99b185072f93666dc8e0aed6e0f7/foci.htm",
      "language": "HTML"
    },
    "d3.geom.js": {
      "type": "application/javascript",
      "filename": "d3.geom.js",
      "size": 21664,
      "content": "(function(){d3.geom = {};\n/**\n * Computes a contour for a given input grid function using the <a\n * href=\"http://en.wikipedia.org/wiki/Marching_squares\">marching\n * squares</a> algorithm. Returns the contour polygon as an array of points.\n *\n * @param grid a two-input function(x, y) that returns true for values\n * inside the contour and false for values outside the contour.\n * @param start an optional starting point [x, y] on the grid.\n * @returns polygon [[x1, y1], [x2, y2], …]\n */\nd3.geom.contour = function(grid, start) {\n  var s = start || d3_geom_contourStart(grid), // starting point\n      c = [],    // contour polygon\n      x = s[0],  // current x position\n      y = s[1],  // current y position\n      dx = 0,    // next x direction\n      dy = 0,    // next y direction\n      pdx = NaN, // previous x direction\n      pdy = NaN, // previous y direction\n      i = 0;\n\n  do {\n    // determine marching squares index\n    i = 0;\n    if (grid(x-1, y-1)) i += 1;\n    if (grid(x,   y-1)) i += 2;\n    if (grid(x-1, y  )) i += 4;\n    if (grid(x,   y  )) i += 8;\n\n    // determine next direction\n    if (i === 6) {\n      dx = pdy === -1 ? -1 : 1;\n      dy = 0;\n    } else if (i === 9) {\n      dx = 0;\n      dy = pdx === 1 ? -1 : 1;\n    } else {\n      dx = d3_geom_contourDx[i];\n      dy = d3_geom_contourDy[i];\n    }\n\n    // update contour polygon\n    if (dx != pdx && dy != pdy) {\n      c.push([x, y]);\n      pdx = dx;\n      pdy = dy;\n    }\n\n    x += dx;\n    y += dy;\n  } while (s[0] != x || s[1] != y);\n\n  return c;\n};\n\n// lookup tables for marching directions\nvar d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],\n    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];\n\nfunction d3_geom_contourStart(grid) {\n  var x = 0,\n      y = 0;\n\n  // search for a starting point; begin at origin\n  // and proceed along outward-expanding diagonals\n  while (true) {\n    if (grid(x,y)) {\n      return [x,y];\n    }\n    if (x === 0) {\n      x = y + 1;\n      y = 0;\n    } else {\n      x = x - 1;\n      y = y + 1;\n    }\n  }\n}\n/**\n * Computes the 2D convex hull of a set of points using Graham's scanning\n * algorithm. The algorithm has been implemented as described in Cormen,\n * Leiserson, and Rivest's Introduction to Algorithms. The running time of\n * this algorithm is O(n log n), where n is the number of input points.\n *\n * @param vertices [[x1, y1], [x2, y2], …]\n * @returns polygon [[x1, y1], [x2, y2], …]\n */\nd3.geom.hull = function(vertices) {\n  if (vertices.length < 3) return [];\n\n  var len = vertices.length,\n      plen = len - 1,\n      points = [],\n      stack = [],\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\n\n  // find the starting ref point: leftmost point with the minimum y coord\n  for (i=1; i<len; ++i) {\n    if (vertices[i][1] < vertices[h][1]) {\n      h = i;\n    } else if (vertices[i][1] == vertices[h][1]) {\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\n    }\n  }\n\n  // calculate polar angles from ref point and sort\n  for (i=0; i<len; ++i) {\n    if (i === h) continue;\n    y1 = vertices[i][1] - vertices[h][1];\n    x1 = vertices[i][0] - vertices[h][0];\n    points.push({angle: Math.atan2(y1, x1), index: i});\n  }\n  points.sort(function(a, b) { return a.angle - b.angle; });\n\n  // toss out duplicate angles\n  a = points[0].angle;\n  v = points[0].index;\n  u = 0;\n  for (i=1; i<plen; ++i) {\n    j = points[i].index;\n    if (a == points[i].angle) {\n      // keep angle for point most distant from the reference\n      x1 = vertices[v][0] - vertices[h][0];\n      y1 = vertices[v][1] - vertices[h][1];\n      x2 = vertices[j][0] - vertices[h][0];\n      y2 = vertices[j][1] - vertices[h][1];\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\n        points[i].index = -1;\n      } else {\n        points[u].index = -1;\n        a = points[i].angle;\n        u = i;\n        v = j;\n      }\n    } else {\n      a = points[i].angle;\n      u = i;\n      v = j;\n    }\n  }\n\n  // initialize the stack\n  stack.push(h);\n  for (i=0, j=0; i<2; ++j) {\n    if (points[j].index !== -1) {\n      stack.push(points[j].index);\n      i++;\n    }\n  }\n  sp = stack.length;\n\n  // do graham's scan\n  for (; j<plen; ++j) {\n    if (points[j].index === -1) continue; // skip tossed out points\n    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\n      --sp;\n    }\n    stack[sp++] = points[j].index;\n  }\n\n  // construct the hull\n  var poly = [];\n  for (i=0; i<sp; ++i) {\n    poly.push(vertices[stack[i]]);\n  }\n  return poly;\n}\n\n// are three points in counter-clockwise order?\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\n  var t, a, b, c, d, e, f;\n  t = v[i1]; a = t[0]; b = t[1];\n  t = v[i2]; c = t[0]; d = t[1];\n  t = v[i3]; e = t[0]; f = t[1];\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\n}\n// Note: requires coordinates to be counterclockwise and convex!\nd3.geom.polygon = function(coordinates) {\n\n  coordinates.area = function() {\n    var i = 0,\n        n = coordinates.length,\n        a = coordinates[n - 1][0] * coordinates[0][1],\n        b = coordinates[n - 1][1] * coordinates[0][0];\n    while (++i < n) {\n      a += coordinates[i - 1][0] * coordinates[i][1];\n      b += coordinates[i - 1][1] * coordinates[i][0];\n    }\n    return (b - a) * .5;\n  };\n\n  coordinates.centroid = function(k) {\n    var i = -1,\n        n = coordinates.length - 1,\n        x = 0,\n        y = 0,\n        a,\n        b,\n        c;\n    if (!arguments.length) k = 1 / (6 * coordinates.area());\n    while (++i < n) {\n      a = coordinates[i];\n      b = coordinates[i + 1];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [x * k, y * k];\n  };\n\n  // The Sutherland-Hodgman clipping algorithm.\n  coordinates.clip = function(subject) {\n    var input,\n        i = -1,\n        n = coordinates.length,\n        j,\n        m,\n        a = coordinates[n - 1],\n        b,\n        c,\n        d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = coordinates[i];\n      c = input[(m = input.length) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      a = b;\n    }\n    return subject;\n  };\n\n  return coordinates;\n};\n\nfunction d3_geom_polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\nfunction d3_geom_polygonIntersect(c, d, a, b) {\n  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],\n      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],\n      x13 = x1 - x3,\n      x21 = x2 - x1,\n      x43 = x4 - x3,\n      y13 = y1 - y3,\n      y21 = y2 - y1,\n      y43 = y4 - y3,\n      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];\n}\n// Adapted from Nicolas Garcia Belmonte's JIT implementation:\n// http://blog.thejit.org/2010/02/12/voronoi-tessellation/\n// http://blog.thejit.org/assets/voronoijs/voronoi.js\n// See lib/jit/LICENSE for details.\n\n/**\n * @param vertices [[x1, y1], [x2, y2], …]\n * @returns polygons [[[x1, y1], [x2, y2], …], …]\n */\nd3.geom.voronoi = function(vertices) {\n  var polygons = vertices.map(function() { return []; });\n\n  // Note: we expect the caller to clip the polygons, if needed.\n  d3_voronoi_tessellate(vertices, function(e) {\n    var s1,\n        s2,\n        x1,\n        x2,\n        y1,\n        y2;\n    if (e.a === 1 && e.b >= 0) {\n      s1 = e.ep.r;\n      s2 = e.ep.l;\n    } else {\n      s1 = e.ep.l;\n      s2 = e.ep.r;\n    }\n    if (e.a === 1) {\n      y1 = s1 ? s1.y : -1e6;\n      x1 = e.c - e.b * y1;\n      y2 = s2 ? s2.y : 1e6;\n      x2 = e.c - e.b * y2;\n    } else {\n      x1 = s1 ? s1.x : -1e6;\n      y1 = e.c - e.a * x1;\n      x2 = s2 ? s2.x : 1e6;\n      y2 = e.c - e.a * x2;\n    }\n    var v1 = [x1, y1],\n        v2 = [x2, y2];\n    polygons[e.region.l.index].push(v1, v2);\n    polygons[e.region.r.index].push(v1, v2);\n  });\n\n  // Reconnect the polygon segments into counterclockwise loops.\n  return polygons.map(function(polygon, i) {\n    var cx = vertices[i][0],\n        cy = vertices[i][1];\n    polygon.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    return polygon.sort(function(a, b) {\n      return a.angle - b.angle;\n    }).filter(function(d, i) {\n      return !i || (d.angle - polygon[i - 1].angle > 1e-10);\n    });\n  });\n};\n\nvar d3_voronoi_opposite = {\"l\": \"r\", \"r\": \"l\"};\n\nfunction d3_voronoi_tessellate(vertices, callback) {\n\n  var Sites = {\n    list: vertices\n      .map(function(v, i) {\n        return {\n          index: i,\n          x: v[0],\n          y: v[1]\n        };\n      })\n      .sort(function(a, b) {\n        return a.y < b.y ? -1\n          : a.y > b.y ? 1\n          : a.x < b.x ? -1\n          : a.x > b.x ? 1\n          : 0;\n      }),\n    bottomSite: null\n  };\n\n  var EdgeList = {\n    list: [],\n    leftEnd: null,\n    rightEnd: null,\n\n    init: function() {\n      EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.leftEnd.r = EdgeList.rightEnd;\n      EdgeList.rightEnd.l = EdgeList.leftEnd;\n      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\n    },\n\n    createHalfEdge: function(edge, side) {\n      return {\n        edge: edge,\n        side: side,\n        vertex: null,\n        \"l\": null,\n        \"r\": null\n      };\n    },\n\n    insert: function(lb, he) {\n      he.l = lb;\n      he.r = lb.r;\n      lb.r.l = he;\n      lb.r = he;\n    },\n\n    leftBound: function(p) {\n      var he = EdgeList.leftEnd;\n      do {\n        he = he.r;\n      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\n      he = he.l;\n      return he;\n    },\n\n    del: function(he) {\n      he.l.r = he.r;\n      he.r.l = he.l;\n      he.edge = null;\n    },\n\n    right: function(he) {\n      return he.r;\n    },\n\n    left: function(he) {\n      return he.l;\n    },\n\n    leftRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[he.side];\n    },\n\n    rightRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[d3_voronoi_opposite[he.side]];\n    }\n  };\n\n  var Geom = {\n\n    bisect: function(s1, s2) {\n      var newEdge = {\n        region: {\"l\": s1, \"r\": s2},\n        ep: {\"l\": null, \"r\": null}\n      };\n\n      var dx = s2.x - s1.x,\n          dy = s2.y - s1.y,\n          adx = dx > 0 ? dx : -dx,\n          ady = dy > 0 ? dy : -dy;\n\n      newEdge.c = s1.x * dx + s1.y * dy\n          + (dx * dx + dy * dy) * .5;\n\n      if (adx > ady) {\n        newEdge.a = 1;\n        newEdge.b = dy / dx;\n        newEdge.c /= dx;\n      } else {\n        newEdge.b = 1;\n        newEdge.a = dx / dy;\n        newEdge.c /= dy;\n      }\n\n      return newEdge;\n    },\n\n    intersect: function(el1, el2) {\n      var e1 = el1.edge,\n          e2 = el2.edge;\n      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {\n        return null;\n      }\n      var d = (e1.a * e2.b) - (e1.b * e2.a);\n      if (Math.abs(d) < 1e-10) {\n        return null;\n      }\n      var xint = (e1.c * e2.b - e2.c * e1.b) / d,\n          yint = (e2.c * e1.a - e1.c * e2.a) / d,\n          e1r = e1.region.r,\n          e2r = e2.region.r,\n          el,\n          e;\n      if ((e1r.y < e2r.y) ||\n         (e1r.y == e2r.y && e1r.x < e2r.x)) {\n        el = el1;\n        e = e1;\n      } else {\n        el = el2;\n        e = e2;\n      }\n      var rightOfSite = (xint >= e.region.r.x);\n      if ((rightOfSite && (el.side === \"l\")) ||\n        (!rightOfSite && (el.side === \"r\"))) {\n        return null;\n      }\n      return {\n        x: xint,\n        y: yint\n      };\n    },\n\n    rightOf: function(he, p) {\n      var e = he.edge,\n          topsite = e.region.r,\n          rightOfSite = (p.x > topsite.x);\n\n      if (rightOfSite && (he.side === \"l\")) {\n        return 1;\n      }\n      if (!rightOfSite && (he.side === \"r\")) {\n        return 0;\n      }\n      if (e.a === 1) {\n        var dyp = p.y - topsite.y,\n            dxp = p.x - topsite.x,\n            fast = 0,\n            above = 0;\n\n        if ((!rightOfSite && (e.b < 0)) ||\n          (rightOfSite && (e.b >= 0))) {\n          above = fast = (dyp >= e.b * dxp);\n        } else {\n          above = ((p.x + p.y * e.b) > e.c);\n          if (e.b < 0) {\n            above = !above;\n          }\n          if (!above) {\n            fast = 1;\n          }\n        }\n        if (!fast) {\n          var dxs = topsite.x - e.region.l.x;\n          above = (e.b * (dxp * dxp - dyp * dyp)) <\n            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));\n\n          if (e.b < 0) {\n            above = !above;\n          }\n        }\n      } else /* e.b == 1 */ {\n        var yl = e.c - e.a * p.x,\n            t1 = p.y - yl,\n            t2 = p.x - topsite.x,\n            t3 = yl - topsite.y;\n\n        above = (t1 * t1) > (t2 * t2 + t3 * t3);\n      }\n      return he.side === \"l\" ? above : !above;\n    },\n\n    endPoint: function(edge, side, site) {\n      edge.ep[side] = site;\n      if (!edge.ep[d3_voronoi_opposite[side]]) return;\n      callback(edge);\n    },\n\n    distance: function(s, t) {\n      var dx = s.x - t.x,\n          dy = s.y - t.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  };\n\n  var EventQueue = {\n    list: [],\n\n    insert: function(he, site, offset) {\n      he.vertex = site;\n      he.ystar = site.y + offset;\n      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {\n        var next = list[i];\n        if (he.ystar > next.ystar ||\n          (he.ystar == next.ystar &&\n          site.x > next.vertex.x)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      list.splice(i, 0, he);\n    },\n\n    del: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}\n      ls.splice(i, 1);\n    },\n\n    empty: function() { return EventQueue.list.length === 0; },\n\n    nextEvent: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {\n        if (ls[i] == he) return ls[i+1];\n      }\n      return null;\n    },\n\n    min: function() {\n      var elem = EventQueue.list[0];\n      return {\n        x: elem.vertex.x,\n        y: elem.ystar\n      };\n    },\n\n    extractMin: function() {\n      return EventQueue.list.shift();\n    }\n  };\n\n  EdgeList.init();\n  Sites.bottomSite = Sites.list.shift();\n\n  var newSite = Sites.list.shift(), newIntStar;\n  var lbnd, rbnd, llbnd, rrbnd, bisector;\n  var bot, top, temp, p, v;\n  var e, pm;\n\n  while (true) {\n    if (!EventQueue.empty()) {\n      newIntStar = EventQueue.min();\n    }\n    if (newSite && (EventQueue.empty()\n      || newSite.y < newIntStar.y\n      || (newSite.y == newIntStar.y\n      && newSite.x < newIntStar.x))) { //new site is smallest\n      lbnd = EdgeList.leftBound(newSite);\n      rbnd = EdgeList.right(lbnd);\n      bot = EdgeList.rightRegion(lbnd);\n      e = Geom.bisect(bot, newSite);\n      bisector = EdgeList.createHalfEdge(e, \"l\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(lbnd, bisector);\n      if (p) {\n        EventQueue.del(lbnd);\n        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\n      }\n      lbnd = bisector;\n      bisector = EdgeList.createHalfEdge(e, \"r\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(bisector, rbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, newSite));\n      }\n      newSite = Sites.list.shift();\n    } else if (!EventQueue.empty()) { //intersection is smallest\n      lbnd = EventQueue.extractMin();\n      llbnd = EdgeList.left(lbnd);\n      rbnd = EdgeList.right(lbnd);\n      rrbnd = EdgeList.right(rbnd);\n      bot = EdgeList.leftRegion(lbnd);\n      top = EdgeList.rightRegion(rbnd);\n      v = lbnd.vertex;\n      Geom.endPoint(lbnd.edge, lbnd.side, v);\n      Geom.endPoint(rbnd.edge, rbnd.side, v);\n      EdgeList.del(lbnd);\n      EventQueue.del(rbnd);\n      EdgeList.del(rbnd);\n      pm = \"l\";\n      if (bot.y > top.y) {\n        temp = bot;\n        bot = top;\n        top = temp;\n        pm = \"r\";\n      }\n      e = Geom.bisect(bot, top);\n      bisector = EdgeList.createHalfEdge(e, pm);\n      EdgeList.insert(llbnd, bisector);\n      Geom.endPoint(e, d3_voronoi_opposite[pm], v);\n      p = Geom.intersect(llbnd, bisector);\n      if (p) {\n        EventQueue.del(llbnd);\n        EventQueue.insert(llbnd, p, Geom.distance(p, bot));\n      }\n      p = Geom.intersect(bisector, rrbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, bot));\n      }\n    } else {\n      break;\n    }\n  }//end while\n\n  for (lbnd = EdgeList.right(EdgeList.leftEnd);\n      lbnd != EdgeList.rightEnd;\n      lbnd = EdgeList.right(lbnd)) {\n    callback(lbnd.edge);\n  }\n}\n/**\n* @param vertices [[x1, y1], [x2, y2], …]\n* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], …]\n */\nd3.geom.delaunay = function(vertices) {\n  var edges = vertices.map(function() { return []; }),\n      triangles = [];\n\n  // Use the Voronoi tessellation to determine Delaunay edges.\n  d3_voronoi_tessellate(vertices, function(e) {\n    edges[e.region.l.index].push(vertices[e.region.r.index]);\n  });\n\n  // Reconnect the edges into counterclockwise triangles.\n  edges.forEach(function(edge, i) {\n    var v = vertices[i],\n        cx = v[0],\n        cy = v[1];\n    edge.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    edge.sort(function(a, b) {\n      return a.angle - b.angle;\n    });\n    for (var j = 0, m = edge.length - 1; j < m; j++) {\n      triangles.push([v, edge[j], edge[j + 1]]);\n    }\n  });\n\n  return triangles;\n};\n// Constructs a new quadtree for the specified array of points. A quadtree is a\n// two-dimensional recursive spatial subdivision. This implementation uses\n// square partitions, dividing each square into four equally-sized squares. Each\n// point exists in a unique node; if multiple points are in the same position,\n// some points may be stored on internal nodes rather than leaf nodes. Quadtrees\n// can be used to accelerate various spatial operations, such as the Barnes-Hut\n// approximation for computing n-body forces, or collision detection.\nd3.geom.quadtree = function(points, x1, y1, x2, y2) {\n  var p,\n      i = -1,\n      n = points.length;\n\n  // Type conversion for deprecated API.\n  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);\n\n  // Allow bounds to be specified explicitly.\n  if (arguments.length < 5) {\n    if (arguments.length === 3) {\n      y2 = x2 = y1;\n      y1 = x1;\n    } else {\n      x1 = y1 = Infinity;\n      x2 = y2 = -Infinity;\n\n      // Compute bounds.\n      while (++i < n) {\n        p = points[i];\n        if (p.x < x1) x1 = p.x;\n        if (p.y < y1) y1 = p.y;\n        if (p.x > x2) x2 = p.x;\n        if (p.y > y2) y2 = p.y;\n      }\n\n      // Squarify the bounds.\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      if (dx > dy) y2 = y1 + dx;\n      else x2 = x1 + dy;\n    }\n  }\n\n  // Recursively inserts the specified point p at the node n or one of its\n  // descendants. The bounds are defined by [x1, x2] and [y1, y2].\n  function insert(n, p, x1, y1, x2, y2) {\n    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points\n    if (n.leaf) {\n      var v = n.point;\n      if (v) {\n        // If the point at this leaf node is at the same position as the new\n        // point we are adding, we leave the point associated with the\n        // internal node while adding the new point to a child node. This\n        // avoids infinite recursion.\n        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {\n          insertChild(n, p, x1, y1, x2, y2);\n        } else {\n          n.point = null;\n          insertChild(n, v, x1, y1, x2, y2);\n          insertChild(n, p, x1, y1, x2, y2);\n        }\n      } else {\n        n.point = p;\n      }\n    } else {\n      insertChild(n, p, x1, y1, x2, y2);\n    }\n  }\n\n  // Recursively inserts the specified point p into a descendant of node n. The\n  // bounds are defined by [x1, x2] and [y1, y2].\n  function insertChild(n, p, x1, y1, x2, y2) {\n    // Compute the split point, and the quadrant in which to insert p.\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        right = p.x >= sx,\n        bottom = p.y >= sy,\n        i = (bottom << 1) + right;\n\n    // Recursively insert into the child node.\n    n.leaf = false;\n    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n\n    // Update the bounds as we recurse.\n    if (right) x1 = sx; else x2 = sx;\n    if (bottom) y1 = sy; else y2 = sy;\n    insert(n, p, x1, y1, x2, y2);\n  }\n\n  // Create the root node.\n  var root = d3_geom_quadtreeNode();\n\n  root.add = function(p) {\n    insert(root, p, x1, y1, x2, y2);\n  };\n\n  root.visit = function(f) {\n    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\n  };\n\n  // Insert all points.\n  points.forEach(root.add);\n  return root;\n};\n\nfunction d3_geom_quadtreeNode() {\n  return {\n    leaf: true,\n    nodes: [],\n    point: null\n  };\n}\n\nfunction d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n  if (!f(node, x1, y1, x2, y2)) {\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        children = node.nodes;\n    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n  }\n}\n\nfunction d3_geom_quadtreePoint(p) {\n  return {\n    x: p[0],\n    y: p[1]\n  };\n}\n})();\n",
      "raw_url": "https://gist.github.com/raw/3683489/9d8bc31a06fac59709dcb274ba6d94dadfde15cd/d3.geom.js",
      "language": "JavaScript"
    },
    "index.html": {
      "type": "text/html",
      "filename": "index.html",
      "size": 4764,
      "content": "<!DOCTYPE html>\n<!-- saved from url=(0047)http://mbostock.github.com/d3/talk/20110921/#15 -->\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    \n    <title>D3.js</title>\n    <script type=\"text/javascript\" src=\"http://d3js.org/d3.v2.js\"></script>\n    <style type=\"text/css\">\n\nbody {\n  background: #000;\n  position: relative;\n  width: 1280px;\n  height: 800px;\n  margin: auto;\n  overflow: hidden;\n}\n\niframe {\n  border: none;\n  position: absolute;\n  width: 1280px;\n  height: 800px;\n  background: #fff;\n  -moz-transition-property: -moz-transform, opacity;\n  -moz-transition-duration: 500ms;\n  -webkit-transition-property: -webkit-transform, opacity;\n  -webkit-transition-duration: 500ms;\n}\n\n#about {\n  font: 14px \"Helvetica Neue\";\n  position: absolute;\n  width: 1280px;\n  top: 840px;\n}\n\n#about, #about a {\n  color: #fff;\n}\n\n#previous {\n  opacity: 0;\n  -moz-transform: translateX(-1300px);\n  -webkit-transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1300, 0, 0, 1);\n}\n\n#current {\n  opacity: 1;\n  -moz-transform: translateX(0);\n  -webkit-transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n}\n\n#next {\n  opacity: 0;\n  -moz-transform: translateX(1300px);\n  -webkit-transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1300, 0, 0, 1);\n}\n\n    </style>\n  </head>\n  <body style=\"margin-top: 26.666666666666668px; \">\n    <iframe id=\"previous\" src=\"./foci.htm\"></iframe>\n    <iframe id=\"current\" src=\"./more-foci.htm\"></iframe>\n    <iframe id=\"next\" src=\"./link-foci.htm\"></iframe>\n    <div id=\"about\">\n\nVideo: <a href=\"http://vimeo.com/29458354\">http://vimeo.com/29458354</a><br>\nSource: <a href=\"http://github.com/mbostock/d3\">http://github.com/mbostock/d3</a>\n\n    </div>\n    <script type=\"text/javascript\">\n\nvar slides = [\n  \"overview.html\",\n  \"force.html\",\n  \"patent-suits.html\",\n  \"static.html\",\n  \"momentum.html\",\n  \"verlet.html\",\n  \"negative-charge.html\",\n  \"positive-charge.html\",\n  \"gravity.html\",\n  \"gravity-charge.html\",\n  \"links.html\",\n  \"relaxation.html\",\n  \"ribbon.html\",\n  \"transition.html\",\n  \"foci.html\",\n  \"more-foci.html\",\n  \"link-foci.html\",\n  \"medals.html\",\n  \"states.html\",\n  \"quantitative-foci.html\",\n  \"tree.html\",\n  \"parent-foci.html\",\n  \"depth-foci.html\",\n  \"collision.html\",\n  \"bounding.html\",\n  \"labels.html\",\n  \"collapsible.html\",\n  \"builder.html\"\n];\n\nvar previous = d3.select(\"#previous\"),\n    current = d3.select(\"#current\"),\n    next = d3.select(\"#next\"),\n    query = \"?\" + Date.now(),\n    previousIndex,\n    currentIndex = +location.hash.substring(1) || 0,\n    nextIndex;\n\nresize();\nstep(0);\n\nd3.selectAll(\"iframe\").on(\"load\", function() {\n  this.contentWindow.focus();\n  d3.select(this.contentWindow).on(\"keydown\", function() {\n    switch (d3.event.keyCode) {\n      case 39: // right arrow\n      case 32: // space\n      case 34: { // page down\n        step(+1);\n        break;\n      }\n      case 8: { // delete\n        step(d3.event.shiftKey ? +1 : -1);\n        break;\n      }\n      case 37: // left arrow\n      case 33: { // page up\n        step(-1);\n        break;\n      }\n      case 36: { // home\n        currentIndex = 0;\n        step(0);\n        break;\n      }\n      case 35: { // end\n        currentIndex = slides.length - 1;\n        step(0);\n        break;\n      }\n      default: return;\n    }\n    d3.event.preventDefault();\n  });\n});\n\nd3.select(window).on(\"resize\", resize).on(\"hashchange\", function hashchange() {\n  var that = d3.select(this).on(\"hashchange\", null);\n  currentIndex = +location.hash.substring(1);\n  step(0);\n  that.on(\"hashchange\", hashchange);\n});\n\nfunction resize() {\n  d3.select(\"body\").style(\"margin-top\", (window.innerHeight - 800) / 3 + \"px\");\n}\n\nfunction step(delta) {\n  if (delta > 0) {\n    var temp = previous;\n    previousIndex = currentIndex;\n    previous = current.attr(\"id\", \"previous\");\n    currentIndex = nextIndex;\n    current = next.attr(\"id\", \"current\");\n    nextIndex = nextIndex >= slides.length - 1 ? 0 : nextIndex + 1;\n    next = temp.attr(\"id\", \"next\");\n  } else if (delta < 0) {\n    var temp = next;\n    nextIndex = currentIndex;\n    next = current.attr(\"id\", \"next\");\n    currentIndex = previousIndex;\n    current = previous.attr(\"id\", \"current\");\n    previousIndex = previousIndex <= 0 ? slides.length - 1 : previousIndex - 1;\n    previous = temp.attr(\"id\", \"previous\");\n  } else {\n    nextIndex = currentIndex >= slides.length - 1 ? 0 : currentIndex + 1;\n    previousIndex = currentIndex <= 0 ? slides.length - 1 : currentIndex - 1;\n  }\n  previous.transition().delay(750).attr(\"src\", slides[previousIndex] + query);\n  current.transition().delay(250).attr(\"src\", slides[currentIndex] + query);\n  next.transition().delay(750).attr(\"src\", slides[nextIndex] + query);\n  location.hash = currentIndex;\n}\n\n    </script>\n  \n\n</body></html>",
      "raw_url": "https://gist.github.com/raw/3683489/075c05f3702a143b0896a4b2509ee60e5b73b1c3/index.html",
      "language": "HTML"
    },
    ".gitignore": {
      "type": "text/plain",
      "filename": ".gitignore",
      "size": 31,
      "content": "# Editor backup files\n*.bak\n*~\n",
      "raw_url": "https://gist.github.com/raw/3683489/649a1ddb7b45a1c3480ce70724917d1e64e0db52/.gitignore",
      "language": null
    },
    "more-foci.htm": {
      "type": "text/html",
      "filename": "more-foci.htm",
      "size": 2557,
      "content": "<!DOCTYPE html>\n<!-- saved from url=(0072)http://mbostock.github.com/d3/talk/20110921/more-foci.html?1347142470398 -->\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    \n    <title>Force Layouts - Foci</title>\n    <script type=\"text/javascript\" src=\"http://d3js.org/d3.v2.js\"></script>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n    <style type=\"text/css\">\n\ncircle {\n  stroke: #fff;\n}\n\n    </style>\n  </head>\n  <body>\n    <div id=\"body\">\n      <div id=\"chart\"></div>\n      <div id=\"header\">forces are additive</div>\n    </div>\n    <script type=\"text/javascript\">\n\nvar w = 1280,\n    h = 800,\n    color = d3.scale.category10().domain([1, 2, 4]);\n\nvar force = d3.layout.force()\n    .gravity(0)\n    .charge(-10)\n    .size([w, h]);\n\nvar nodes = force.nodes(),\n    a = {type: 1, x: 3 * w / 6, y: 2 * h / 6, fixed: true},\n    b = {type: 2, x: 4 * w / 6, y: 4 * h / 6, fixed: true},\n    c = {type: 4, x: 2 * w / 6, y: 4 * h / 6, fixed: true};\n\nnodes.push(a, b, c);\n\nvar svg = d3.select(\"#chart\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.append(\"rect\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.selectAll(\"circle\")\n    .data(nodes)\n  .enter().append(\"circle\")\n    .attr(\"r\", 12)\n    .attr(\"cx\", function(d) { return d.x; })\n    .attr(\"cy\", function(d) { return d.y; })\n    .style(\"fill\", fill)\n    .call(force.drag);\n\nforce.on(\"tick\", function(e) {\n  var k = e.alpha * .1;\n\n  nodes.forEach(function(node) {\n    if (node.type & 1) {\n      node.x += (a.x - node.x) * k;\n      node.y += (a.y - node.y) * k;\n    }\n    if (node.type & 2) {\n      node.x += (b.x - node.x) * k;\n      node.y += (b.y - node.y) * k;\n    }\n    if (node.type & 4) {\n      node.x += (c.x - node.x) * k;\n      node.y += (c.y - node.y) * k;\n    }\n  });\n\n  svg.selectAll(\"circle\")\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; });\n});\n\nvar p0;\n\nsvg.on(\"mousemove\", function() {\n  var p1 = d3.svg.mouse(this),\n      node = {type: (Math.random() * 7 + 1) | 0, x: p1[0], y: p1[1], px: (p0 || (p0 = p1))[0], py: p0[1]};\n\n  p0 = p1;\n\n  svg.append(\"circle\")\n      .data([node])\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; })\n      .attr(\"r\", 4.5)\n      .style(\"fill\", fill)\n    .transition()\n      .delay(3000)\n      .attr(\"r\", 1e-6)\n      .each(\"end\", function() { nodes.splice(3, 1); })\n      .remove();\n\n  nodes.push(node);\n  force.start();\n});\n\nfunction fill(d) {\n  return color(d.type);\n}\n\n    </script>\n  \n\n</body></html>",
      "raw_url": "https://gist.github.com/raw/3683489/0534923ba82929941b82dc8944113053d80f4214/more-foci.htm",
      "language": "HTML"
    },
    "link-foci.htm": {
      "type": "text/html",
      "filename": "link-foci.htm",
      "size": 2959,
      "content": "<!DOCTYPE html>\n<!-- saved from url=(0072)http://mbostock.github.com/d3/talk/20110921/link-foci.html?1347142470398 -->\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    \n    <title>Force Layouts - Foci</title>\n    <script type=\"text/javascript\" src=\"http://d3js.org/d3.v2.js\"></script>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n    <style type=\"text/css\">\n\ncircle {\n  stroke: #fff;\n}\n\n    </style>\n  </head>\n  <body>\n    <div id=\"body\">\n      <div id=\"chart\"></div>\n      <div id=\"header\">forces compete with constraints</div>\n    </div>\n    <script type=\"text/javascript\">\n\nvar w = 1280,\n    h = 800,\n    color = d3.scale.category10();\n\nvar force = d3.layout.force()\n    .gravity(0)\n    .charge(-10)\n    .size([w, h]);\n\nvar links = force.links(),\n    nodes = force.nodes(),\n    centers = [\n      {type: 0, x: 3 * w / 6, y: 2 * h / 6, fixed: true},\n      {type: 1, x: 4 * w / 6, y: 4 * h / 6, fixed: true},\n      {type: 2, x: 2 * w / 6, y: 4 * h / 6, fixed: true}\n    ];\n\nvar svg = d3.select(\"#chart\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.append(\"rect\")\n    .attr(\"width\", w)\n    .attr(\"height\", h);\n\nsvg.selectAll(\"circle\")\n    .data(centers)\n  .enter().append(\"circle\")\n    .attr(\"r\", 12)\n    .attr(\"cx\", function(d) { return d.x; })\n    .attr(\"cy\", function(d) { return d.y; })\n    .style(\"fill\", fill)\n    .call(force.drag);\n\nforce.on(\"tick\", function(e) {\n  var k = e.alpha * .1;\n  nodes.forEach(function(node) {\n    var center = centers[node.type];\n    node.x += (center.x - node.x) * k;\n    node.y += (center.y - node.y) * k;\n  });\n\n  svg.selectAll(\"circle\")\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; });\n\n  svg.selectAll(\"line\")\n      .attr(\"x1\", function(d) { return d.source.x; })\n      .attr(\"y1\", function(d) { return d.source.y; })\n      .attr(\"x2\", function(d) { return d.target.x; })\n      .attr(\"y2\", function(d) { return d.target.y; });\n});\n\nvar p0;\n\nsvg.on(\"mousemove\", function() {\n  var p1 = d3.svg.mouse(this),\n      a = {type: Math.random() * 3 | 0, x: p1[0], y: p1[1], px: (p0 || (p0 = p1))[0], py: p0[1]},\n      b = {type: Math.random() * 3 | 0},\n      link = {source: a, target: b};\n\n  p0 = p1;\n\n  svg.selectAll()\n      .data([a, b])\n    .enter().append(\"circle\")\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; })\n      .attr(\"r\", 4.5)\n      .style(\"fill\", fill)\n    .transition()\n      .delay(3000)\n      .attr(\"r\", 1e-6)\n      .remove();\n\n  svg.insert(\"line\", \"circle\")\n      .data([link])\n    .transition()\n      .delay(3000)\n      .each(\"end\", function() {\n        nodes.splice(nodes.indexOf(a), 1);\n        nodes.splice(nodes.indexOf(b), 1);\n        links.splice(links.indexOf(link), 1);\n      })\n      .remove();\n\n  nodes.push(a, b);\n  links.push(link);\n  force.start();\n});\n\nfunction fill(d) {\n  return color(d.type);\n}\n\n    </script>\n  \n\n</body></html>",
      "raw_url": "https://gist.github.com/raw/3683489/6288e89c3a1094c8e74b93821f63154830a5c480/link-foci.htm",
      "language": "HTML"
    },
    "d3.js": {
      "type": "application/javascript",
      "filename": "d3.js",
      "size": 108106,
      "content": "(function(){if (!Date.now) Date.now = function() {\n  return +new Date;\n};\ntry {\n  document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\n} catch (error) {\n  var d3_style_prototype = CSSStyleDeclaration.prototype,\n      d3_style_setProperty = d3_style_prototype.setProperty;\n  d3_style_prototype.setProperty = function(name, value, priority) {\n    d3_style_setProperty.call(this, name, value + \"\", priority);\n  };\n}\nd3 = {version: \"2.2.0\"}; // semver\nvar d3_arraySubclass = [].__proto__?\n\n// Until ECMAScript supports array subclassing, prototype injection works well.\nfunction(array, prototype) {\n  array.__proto__ = prototype;\n}:\n\n// And if your browser doesn't support __proto__, we'll use direct extension.\nfunction(array, prototype) {\n  for (var property in prototype) array[property] = prototype[property];\n};\nfunction d3_this() {\n  return this;\n}\nd3.functor = function(v) {\n  return typeof v === \"function\" ? v : function() { return v; };\n};\n// A getter-setter method that preserves the appropriate `this` context.\nd3.rebind = function(object, method) {\n  return function() {\n    var x = method.apply(object, arguments);\n    return arguments.length ? object : x;\n  };\n};\nd3.ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\nd3.descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\nd3.min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n  }\n  return a;\n};\nd3.max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n  }\n  return a;\n};\nd3.sum = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1;\n\n  if (arguments.length === 1) {\n    while (++i < n) if (!isNaN(a = +array[i])) s += a;\n  } else {\n    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\n  }\n\n  return s;\n};\n// R-7 per <http://en.wikipedia.org/wiki/Quantile>\nd3.quantile = function(values, p) {\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = values[h - 1],\n      e = H - h;\n  return e ? v + e * (values[h] - v) : v;\n};\nd3.zip = function() {\n  if (!(n = arguments.length)) return [];\n  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {\n    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {\n      zip[j] = arguments[j][i];\n    }\n  }\n  return zips;\n};\n\nfunction d3_zipLength(d) {\n  return d.length;\n}\n// Locate the insertion point for x in a to maintain sorted order. The\n// arguments lo and hi may be used to specify a subset of the array which should\n// be considered; by default the entire array is used. If x is already present\n// in a, the insertion point will be before (to the left of) any existing\n// entries. The return value is suitable for use as the first argument to\n// `array.splice` assuming that a is already sorted.\n//\n// The returned insertion point i partitions the array a into two halves so that\n// all v < x for v in a[lo:i] for the left side and all v >= x for v in a[i:hi]\n// for the right side.\nd3.bisectLeft = function(a, x, lo, hi) {\n  if (arguments.length < 3) lo = 0;\n  if (arguments.length < 4) hi = a.length;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n};\n\n// Similar to bisectLeft, but returns an insertion point which comes after (to\n// the right of) any existing entries of x in a.\n//\n// The returned insertion point i partitions the array into two halves so that\n// all v <= x for v in a[lo:i] for the left side and all v > x for v in a[i:hi]\n// for the right side.\nd3.bisect =\nd3.bisectRight = function(a, x, lo, hi) {\n  if (arguments.length < 3) lo = 0;\n  if (arguments.length < 4) hi = a.length;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (x < a[mid]) hi = mid;\n    else lo = mid + 1;\n  }\n  return lo;\n};\nd3.first = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) > 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.last = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) <= 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.nest = function() {\n  var nest = {},\n      keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup;\n\n  function map(array, depth) {\n    if (depth >= keys.length) return rollup\n        ? rollup.call(nest, array) : (sortValues\n        ? array.sort(sortValues)\n        : array);\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        object,\n        o = {};\n\n    while (++i < n) {\n      if ((keyValue = key(object = array[i])) in o) {\n        o[keyValue].push(object);\n      } else {\n        o[keyValue] = [object];\n      }\n    }\n\n    for (keyValue in o) {\n      o[keyValue] = map(o[keyValue], depth);\n    }\n\n    return o;\n  }\n\n  function entries(map, depth) {\n    if (depth >= keys.length) return map;\n\n    var a = [],\n        sortKey = sortKeys[depth++],\n        key;\n\n    for (key in map) {\n      a.push({key: key, values: entries(map[key], depth)});\n    }\n\n    if (sortKey) a.sort(function(a, b) {\n      return sortKey(a.key, b.key);\n    });\n\n    return a;\n  }\n\n  nest.map = function(array) {\n    return map(array, 0);\n  };\n\n  nest.entries = function(array) {\n    return entries(map(array, 0), 0);\n  };\n\n  nest.key = function(d) {\n    keys.push(d);\n    return nest;\n  };\n\n  // Specifies the order for the most-recently specified key.\n  // Note: only applies to entries. Map keys are unordered!\n  nest.sortKeys = function(order) {\n    sortKeys[keys.length - 1] = order;\n    return nest;\n  };\n\n  // Specifies the order for leaf values.\n  // Applies to both maps and entries array.\n  nest.sortValues = function(order) {\n    sortValues = order;\n    return nest;\n  };\n\n  nest.rollup = function(f) {\n    rollup = f;\n    return nest;\n  };\n\n  return nest;\n};\nd3.keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\nd3.values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\nd3.entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\nd3.permute = function(array, indexes) {\n  var permutes = [],\n      i = -1,\n      n = indexes.length;\n  while (++i < n) permutes[i] = array[indexes[i]];\n  return permutes;\n};\nd3.merge = function(arrays) {\n  return Array.prototype.concat.apply([], arrays);\n};\nd3.split = function(array, f) {\n  var arrays = [],\n      values = [],\n      value,\n      i = -1,\n      n = array.length;\n  if (arguments.length < 2) f = d3_splitter;\n  while (++i < n) {\n    if (f.call(values, value = array[i], i)) {\n      values = [];\n    } else {\n      if (!values.length) arrays.push(values);\n      values.push(value);\n    }\n  }\n  return arrays;\n};\n\nfunction d3_splitter(d) {\n  return d == null;\n}\nfunction d3_collapse(s) {\n  return s.replace(/(^\\s+)|(\\s+$)/g, \"\").replace(/\\s+/g, \" \");\n}\n/**\n * @param {number} start\n * @param {number=} stop\n * @param {number=} step\n */\nd3.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       i = -1,\n       j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\nd3.requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\nd3.round = function(x, n) {\n  return n\n      ? Math.round(x * Math.pow(10, n)) * Math.pow(10, -n)\n      : Math.round(x);\n};\nd3.xhr = function(url, mime, callback) {\n  var req = new XMLHttpRequest;\n  if (arguments.length < 3) callback = mime;\n  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);\n  req.open(\"GET\", url, true);\n  req.onreadystatechange = function() {\n    if (req.readyState === 4) callback(req.status < 300 ? req : null);\n  };\n  req.send(null);\n};\nd3.text = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseText);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.json = function(url, callback) {\n  d3.text(url, \"application/json\", function(text) {\n    callback(text ? JSON.parse(text) : null);\n  });\n};\nd3.html = function(url, callback) {\n  d3.text(url, \"text/html\", function(text) {\n    if (text != null) { // Treat empty string as valid HTML.\n      var range = document.createRange();\n      range.selectNode(document.body);\n      text = range.createContextualFragment(text);\n    }\n    callback(text);\n  });\n};\nd3.xml = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseXML);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.ns = {\n\n  prefix: {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: \"http://www.w3.org/1999/xhtml\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  },\n\n  qualify: function(name) {\n    var i = name.indexOf(\":\");\n    return i < 0 ? name : {\n      space: d3.ns.prefix[name.substring(0, i)],\n      local: name.substring(i + 1)\n    };\n  }\n\n};\n/** @param {...string} types */\nd3.dispatch = function(types) {\n  var dispatch = {},\n      type;\n  for (var i = 0, n = arguments.length; i < n; i++) {\n    type = arguments[i];\n    dispatch[type] = d3_dispatch(type);\n  }\n  return dispatch;\n};\n\nfunction d3_dispatch(type) {\n  var dispatch = {},\n      listeners = [];\n\n  dispatch.add = function(listener) {\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i].listener == listener) return dispatch; // already registered\n    }\n    listeners.push({listener: listener, on: true});\n    return dispatch;\n  };\n\n  dispatch.remove = function(listener) {\n    for (var i = 0; i < listeners.length; i++) {\n      var l = listeners[i];\n      if (l.listener == listener) {\n        l.on = false;\n        listeners = listeners.slice(0, i).concat(listeners.slice(i + 1));\n        break;\n      }\n    }\n    return dispatch;\n  };\n\n  dispatch.dispatch = function() {\n    var ls = listeners; // defensive reference\n    for (var i = 0, n = ls.length; i < n; i++) {\n      var l = ls[i];\n      if (l.on) l.listener.apply(this, arguments);\n    }\n  };\n\n  return dispatch;\n};\n// TODO align\nd3.format = function(specifier) {\n  var match = d3_format_re.exec(specifier),\n      fill = match[1] || \" \",\n      sign = match[3] || \"\",\n      zfill = match[5],\n      width = +match[6],\n      comma = match[7],\n      precision = match[8],\n      type = match[9],\n      percentage = false,\n      integer = false;\n\n  if (precision) precision = precision.substring(1);\n\n  if (zfill) {\n    fill = \"0\"; // TODO align = \"=\";\n    if (comma) width -= Math.floor((width - 1) / 4);\n  }\n\n  switch (type) {\n    case \"n\": comma = true; type = \"g\"; break;\n    case \"%\": percentage = true; type = \"f\"; break;\n    case \"p\": percentage = true; type = \"r\"; break;\n    case \"d\": integer = true; precision = \"0\"; break;\n  }\n\n  type = d3_format_types[type] || d3_format_typeDefault;\n\n  return function(value) {\n    var number = percentage ? value * 100 : +value,\n        negative = (number < 0) && (number = -number) ? \"\\u2212\" : sign;\n\n    // Return the empty string for floats formatted as ints.\n    if (integer && (number % 1)) return \"\";\n\n    // Convert the input value to the desired precision.\n    value = type(number, precision);\n\n    // If the fill character is 0, the sign and group is applied after the fill.\n    if (zfill) {\n      var length = value.length + negative.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n    }\n\n    // Otherwise (e.g., space-filling), the sign and group is applied before.\n    else {\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n      var length = value.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n    }\n    if (percentage) value += \"%\";\n\n    return value;\n  };\n};\n\n// [[fill]align][sign][#][0][width][,][.precision][type]\nvar d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n\nvar d3_format_types = {\n  g: function(x, p) { return x.toPrecision(p); },\n  e: function(x, p) { return x.toExponential(p); },\n  f: function(x, p) { return x.toFixed(p); },\n  r: function(x, p) {\n    var n = 1 + Math.floor(1e-15 + Math.log(x) / Math.LN10);\n    return d3.round(x, p - n).toFixed(Math.max(0, Math.min(20, p - n)));\n  }\n};\n\nfunction d3_format_typeDefault(x) {\n  return x + \"\";\n}\n\n// Apply comma grouping for thousands.\nfunction d3_format_group(value) {\n  var i = value.lastIndexOf(\".\"),\n      f = i >= 0 ? value.substring(i) : (i = value.length, \"\"),\n      t = [];\n  while (i > 0) t.push(value.substring(i -= 3, i + 3));\n  return t.reverse().join(\",\") + f;\n}\n/*\n * TERMS OF USE - EASING EQUATIONS\n *\n * Open source under the BSD License.\n *\n * Copyright 2001 Robert Penner\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of contributors may be used to\n *   endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar d3_ease_quad = d3_ease_poly(2),\n    d3_ease_cubic = d3_ease_poly(3);\n\nvar d3_ease = {\n  linear: function() { return d3_ease_linear; },\n  poly: d3_ease_poly,\n  quad: function() { return d3_ease_quad; },\n  cubic: function() { return d3_ease_cubic; },\n  sin: function() { return d3_ease_sin; },\n  exp: function() { return d3_ease_exp; },\n  circle: function() { return d3_ease_circle; },\n  elastic: d3_ease_elastic,\n  back: d3_ease_back,\n  bounce: function() { return d3_ease_bounce; }\n};\n\nvar d3_ease_mode = {\n  \"in\": function(f) { return f; },\n  \"out\": d3_ease_reverse,\n  \"in-out\": d3_ease_reflect,\n  \"out-in\": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }\n};\n\nd3.ease = function(name) {\n  var i = name.indexOf(\"-\"),\n      t = i >= 0 ? name.substring(0, i) : name,\n      m = i >= 0 ? name.substring(i + 1) : \"in\";\n  return d3_ease_clamp(d3_ease_mode[m](d3_ease[t].apply(null, Array.prototype.slice.call(arguments, 1))));\n};\n\nfunction d3_ease_clamp(f) {\n  return function(t) {\n    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n  };\n}\n\nfunction d3_ease_reverse(f) {\n  return function(t) {\n    return 1 - f(1 - t);\n  };\n}\n\nfunction d3_ease_reflect(f) {\n  return function(t) {\n    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n  };\n}\n\nfunction d3_ease_linear(t) {\n  return t;\n}\n\nfunction d3_ease_poly(e) {\n  return function(t) {\n    return Math.pow(t, e);\n  }\n}\n\nfunction d3_ease_sin(t) {\n  return 1 - Math.cos(t * Math.PI / 2);\n}\n\nfunction d3_ease_exp(t) {\n  return Math.pow(2, 10 * (t - 1));\n}\n\nfunction d3_ease_circle(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction d3_ease_elastic(a, p) {\n  var s;\n  if (arguments.length < 2) p = 0.45;\n  if (arguments.length < 1) { a = 1; s = p / 4; }\n  else s = p / (2 * Math.PI) * Math.asin(1 / a);\n  return function(t) {\n    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);\n  };\n}\n\nfunction d3_ease_back(s) {\n  if (!s) s = 1.70158;\n  return function(t) {\n    return t * t * ((s + 1) * t - s);\n  };\n}\n\nfunction d3_ease_bounce(t) {\n  return t < 1 / 2.75 ? 7.5625 * t * t\n      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75\n      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375\n      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n}\nd3.event = null;\nd3.interpolate = function(a, b) {\n  var i = d3.interpolators.length, f;\n  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n  return f;\n};\n\nd3.interpolateNumber = function(a, b) {\n  b -= a;\n  return function(t) { return a + b * t; };\n};\n\nd3.interpolateRound = function(a, b) {\n  b -= a;\n  return function(t) { return Math.round(a + b * t); };\n};\n\nd3.interpolateString = function(a, b) {\n  var m, // current match\n      i, // current index\n      j, // current index (for coallescing)\n      s0 = 0, // start index of current string prefix\n      s1 = 0, // end index of current string prefix\n      s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n, // q.length\n      o;\n\n  // Reset our regular expression!\n  d3_interpolate_number.lastIndex = 0;\n\n  // Find all numbers in b.\n  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\n    if (m.index) s.push(b.substring(s0, s1 = m.index));\n    q.push({i: s.length, x: m[0]});\n    s.push(null);\n    s0 = d3_interpolate_number.lastIndex;\n  }\n  if (s0 < b.length) s.push(b.substring(s0));\n\n  // Find all numbers in a.\n  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\n    o = q[i];\n    if (o.x == m[0]) { // The numbers match, so coallesce.\n      if (o.i) {\n        if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i - 1] += o.x;\n          s.splice(o.i, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i - 1] += o.x + s[o.i + 1];\n          s.splice(o.i, 2);\n          for (j = i + 1; j < n; ++j) q[j].i -= 2;\n        }\n      } else {\n          if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i] = o.x;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i] = o.x + s[o.i + 1];\n          s.splice(o.i + 1, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        }\n      }\n      q.splice(i, 1);\n      n--;\n      i--;\n    } else {\n      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n    }\n  }\n\n  // Remove any numbers in b not found in a.\n  while (i < n) {\n    o = q.pop();\n    if (s[o.i + 1] == null) { // This match is followed by another number.\n      s[o.i] = o.x;\n    } else { // This match is followed by a string, so coallesce twice.\n      s[o.i] = o.x + s[o.i + 1];\n      s.splice(o.i + 1, 1);\n    }\n    n--;\n  }\n\n  // Special optimization for only a single match.\n  if (s.length === 1) {\n    return s[0] == null ? q[0].x : function() { return b; };\n  }\n\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return function(t) {\n    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateRgb = function(a, b) {\n  a = d3.rgb(a);\n  b = d3.rgb(b);\n  var ar = a.r,\n      ag = a.g,\n      ab = a.b,\n      br = b.r - ar,\n      bg = b.g - ag,\n      bb = b.b - ab;\n  return function(t) {\n    return \"rgb(\" + Math.round(ar + br * t)\n        + \",\" + Math.round(ag + bg * t)\n        + \",\" + Math.round(ab + bb * t)\n        + \")\";\n  };\n};\n\n// interpolates HSL space, but outputs RGB string (for compatibility)\nd3.interpolateHsl = function(a, b) {\n  a = d3.hsl(a);\n  b = d3.hsl(b);\n  var h0 = a.h,\n      s0 = a.s,\n      l0 = a.l,\n      h1 = b.h - h0,\n      s1 = b.s - s0,\n      l1 = b.l - l0;\n  return function(t) {\n    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();\n  };\n};\n\nd3.interpolateArray = function(a, b) {\n  var x = [],\n      c = [],\n      na = a.length,\n      nb = b.length,\n      n0 = Math.min(a.length, b.length),\n      i;\n  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n  for (; i < na; ++i) c[i] = a[i];\n  for (; i < nb; ++i) c[i] = b[i];\n  return function(t) {\n    for (i = 0; i < n0; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nd3.interpolateObject = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n  for (k in a) {\n    if (k in b) {\n      i[k] = d3_interpolateByName(k)(a[k], b[k]);\n    } else {\n      c[k] = a[k];\n    }\n  }\n  for (k in b) {\n    if (!(k in a)) {\n      c[k] = b[k];\n    }\n  }\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n}\n\nvar d3_interpolate_number = /[-+]?(?:\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)(?:[eE][-]?\\d+)?/g,\n    d3_interpolate_rgb = {background: 1, fill: 1, stroke: 1};\n\nfunction d3_interpolateByName(n) {\n  return n in d3_interpolate_rgb || /\\bcolor\\b/.test(n)\n      ? d3.interpolateRgb\n      : d3.interpolate;\n}\n\nd3.interpolators = [\n  d3.interpolateObject,\n  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },\n  function(a, b) { return (typeof b === \"string\") && d3.interpolateString(String(a), b); },\n  function(a, b) { return (typeof b === \"string\" ? b in d3_rgb_names || /^(#|rgb\\(|hsl\\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(String(a), b); },\n  function(a, b) { return (typeof b === \"number\") && d3.interpolateNumber(+a, b); }\n];\nfunction d3_uninterpolateNumber(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return (x - a) * b; };\n}\n\nfunction d3_uninterpolateClamp(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };\n}\nd3.rgb = function(r, g, b) {\n  return arguments.length === 1\n      ? d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb)\n      : d3_rgb(~~r, ~~g, ~~b);\n};\n\nfunction d3_rgb(r, g, b) {\n  return new d3_Rgb(r, g, b);\n}\n\nfunction d3_Rgb(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n}\n\nd3_Rgb.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  var r = this.r,\n      g = this.g,\n      b = this.b,\n      i = 30;\n  if (!r && !g && !b) return d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return d3_rgb(\n    Math.min(255, Math.floor(r / k)),\n    Math.min(255, Math.floor(g / k)),\n    Math.min(255, Math.floor(b / k)));\n};\n\nd3_Rgb.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_rgb(\n    Math.max(0, Math.floor(k * this.r)),\n    Math.max(0, Math.floor(k * this.g)),\n    Math.max(0, Math.floor(k * this.b)));\n};\n\nd3_Rgb.prototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\n\nd3_Rgb.prototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 0x10 ? \"0\" + v.toString(16) : v.toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0, // red channel; int in [0, 255]\n      g = 0, // green channel; int in [0, 255]\n      b = 0, // blue channel; int in [0, 255]\n      m1, // CSS color specification match\n      m2, // CSS color specification type (e.g., rgb)\n      name;\n\n  /* Handle hsl, rgb. */\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\": {\n        return hsl(\n          parseFloat(m2[0]), // degrees\n          parseFloat(m2[1]) / 100, // percentage\n          parseFloat(m2[2]) / 100 // percentage\n        );\n      }\n      case \"rgb\": {\n        return rgb(\n          d3_rgb_parseNumber(m2[0]),\n          d3_rgb_parseNumber(m2[1]),\n          d3_rgb_parseNumber(m2[2])\n        );\n      }\n    }\n  }\n\n  /* Named colors. */\n  if (name = d3_rgb_names[format]) return rgb(name.r, name.g, name.b);\n\n  /* Hexadecimal colors: #rgb and #rrggbb. */\n  if (format != null && format.charAt(0) === \"#\") {\n    if (format.length === 4) {\n      r = format.charAt(1); r += r;\n      g = format.charAt(2); g += g;\n      b = format.charAt(3); b += b;\n    } else if (format.length === 7) {\n      r = format.substring(1, 3);\n      g = format.substring(3, 5);\n      b = format.substring(5, 7);\n    }\n    r = parseInt(r, 16);\n    g = parseInt(g, 16);\n    b = parseInt(b, 16);\n  }\n\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n      max = Math.max(r, g, b),\n      d = max - min,\n      h,\n      s,\n      l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    s = h = 0;\n  }\n  return d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_parseNumber(c) { // either integer or percentage\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\n\nvar d3_rgb_names = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n};\n\nfor (var d3_rgb_name in d3_rgb_names) {\n  d3_rgb_names[d3_rgb_name] = d3_rgb_parse(\n      d3_rgb_names[d3_rgb_name],\n      d3_rgb,\n      d3_hsl_rgb);\n}\nd3.hsl = function(h, s, l) {\n  return arguments.length === 1\n      ? d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl)\n      : d3_hsl(+h, +s, +l);\n};\n\nfunction d3_hsl(h, s, l) {\n  return new d3_Hsl(h, s, l);\n}\n\nfunction d3_Hsl(h, s, l) {\n  this.h = h;\n  this.s = s;\n  this.l = l;\n}\n\nd3_Hsl.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, this.l / k);\n};\n\nd3_Hsl.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, k * this.l);\n};\n\nd3_Hsl.prototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nd3_Hsl.prototype.toString = function() {\n  return \"hsl(\" + this.h + \",\" + this.s * 100 + \"%,\" + this.l * 100 + \"%)\";\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1,\n      m2;\n\n  /* Some simple corrections for h, s and l. */\n  h = h % 360; if (h < 0) h += 360;\n  s = s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n\n  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nfunction d3_selection(groups) {\n  d3_arraySubclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0]; };\n  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };\n}\n\nvar d3_selectionPrototype = [];\n\nd3.selection = function() {\n  return d3_selectionRoot;\n};\n\nd3.selection.prototype = d3_selectionPrototype;\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return function() {\n    return d3_select(selector, this);\n  };\n}\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = selector.call(node, node.__data__, i));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return function() {\n    return d3_selectAll(selector, this);\n  };\n}\nd3_selectionPrototype.attr = function(name, value) {\n  name = d3.ns.qualify(name);\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) {\n    var node = this.node();\n    return name.local\n        ? node.getAttributeNS(name.space, name.local)\n        : node.getAttribute(name);\n  }\n\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return this.each(value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant)));\n};\nd3_selectionPrototype.classed = function(name, value) {\n  var re = new RegExp(\"(^|\\\\s+)\" + d3.requote(name) + \"(\\\\s+|$)\", \"g\");\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) {\n    var node = this.node();\n    if (c = node.classList) return c.contains(name);\n    var c = node.className;\n    re.lastIndex = 0;\n    return re.test(c.baseVal != null ? c.baseVal : c);\n  }\n\n  function classedAdd() {\n    if (c = this.classList) return c.add(name);\n    var c = this.className,\n        cb = c.baseVal != null,\n        cv = cb ? c.baseVal : c;\n    re.lastIndex = 0;\n    if (!re.test(cv)) {\n      cv = d3_collapse(cv + \" \" + name);\n      if (cb) c.baseVal = cv;\n      else this.className = cv;\n    }\n  }\n\n  function classedRemove() {\n    if (c = this.classList) return c.remove(name);\n    var c = this.className,\n        cb = c.baseVal != null,\n        cv = cb ? c.baseVal : c;\n    cv = d3_collapse(cv.replace(re, \" \"));\n    if (cb) c.baseVal = cv;\n    else this.className = cv;\n  }\n\n  function classedFunction() {\n    (value.apply(this, arguments)\n        ? classedAdd\n        : classedRemove).call(this);\n  }\n\n  return this.each(typeof value === \"function\"\n      ? classedFunction : value\n      ? classedAdd\n      : classedRemove);\n};\nd3_selectionPrototype.style = function(name, value, priority) {\n  if (arguments.length < 3) priority = \"\";\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) return window\n      .getComputedStyle(this.node(), null)\n      .getPropertyValue(name);\n\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return this.each(value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant));\n};\nd3_selectionPrototype.property = function(name, value) {\n\n  // If no value is specified, return the first value.\n  if (arguments.length < 2) return this.node()[name];\n\n  function propertyNull() {\n    delete this[name];\n  }\n\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return this.each(value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant));\n};\nd3_selectionPrototype.text = function(value) {\n  return arguments.length < 1 ? this.node().textContent\n      : (this.each(typeof value === \"function\"\n      ? function() { this.textContent = value.apply(this, arguments); }\n      : function() { this.textContent = value; }));\n};\nd3_selectionPrototype.html = function(value) {\n  return arguments.length < 1 ? this.node().innerHTML\n      : (this.each(typeof value === \"function\"\n      ? function() { this.innerHTML = value.apply(this, arguments); }\n      : function() { this.innerHTML = value; }));\n};\n// TODO append(node)?\n// TODO append(function)?\nd3_selectionPrototype.append = function(name) {\n  name = d3.ns.qualify(name);\n\n  function append() {\n    return this.appendChild(document.createElement(name));\n  }\n\n  function appendNS() {\n    return this.appendChild(document.createElementNS(name.space, name.local));\n  }\n\n  return this.select(name.local ? appendNS : append);\n};\n// TODO insert(node, function)?\n// TODO insert(function, string)?\n// TODO insert(function, function)?\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3.ns.qualify(name);\n\n  function insert() {\n    return this.insertBefore(\n        document.createElement(name),\n        d3_select(before, this));\n  }\n\n  function insertNS() {\n    return this.insertBefore(\n        document.createElementNS(name.space, name.local),\n        d3_select(before, this));\n  }\n\n  return this.select(name.local ? insertNS : insert);\n};\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(function() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  });\n};\n// TODO data(null) for clearing data?\nd3_selectionPrototype.data = function(data, join) {\n  var enter = [],\n      update = [],\n      exit = [];\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        n1 = Math.max(n, m),\n        updateNodes = [],\n        enterNodes = [],\n        exitNodes = [],\n        node,\n        nodeData;\n\n    if (join) {\n      var nodeByKey = {},\n          keys = [],\n          key,\n          j = groupData.length;\n\n      for (i = -1; ++i < n;) {\n        key = join.call(node = group[i], node.__data__, i);\n        if (key in nodeByKey) {\n          exitNodes[j++] = node; // duplicate key\n        } else {\n          nodeByKey[key] = node;\n        }\n        keys.push(key);\n      }\n\n      for (i = -1; ++i < m;) {\n        node = nodeByKey[key = join.call(groupData, nodeData = groupData[i], i)];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n        delete nodeByKey[key];\n      }\n\n      for (i = -1; ++i < n;) {\n        if (keys[i] in nodeByKey) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        updateNodes[i] = exitNodes[i] = null;\n      }\n      for (; i < n1; ++i) {\n        exitNodes[i] = group[i];\n        enterNodes[i] = updateNodes[i] = null;\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var i = -1,\n      n = this.length,\n      group;\n  if (typeof data === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], data.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], data);\n    }\n  }\n\n  var selection = d3_selection(update);\n  selection.enter = function() { return d3_selection_enter(enter); };\n  selection.exit = function() { return d3_selection(exit); };\n  return selection;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\nfunction d3_selection_enter(selection) {\n  d3_arraySubclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n// TODO preserve null elements to maintain index?\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\nd3_selectionPrototype.map = function(map) {\n  return this.each(function() {\n    this.__data__ = map.apply(this, arguments);\n  });\n};\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j].sort(comparator), i = 1, n = group.length, prev = group[0]; i < n; i++) {\n      var node = group[i];\n      if (node) {\n        if (prev) prev.parentNode.insertBefore(node, prev.nextSibling);\n        prev = node;\n      }\n    }\n  }\n  return this;\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3.ascending;\n  return function(a, b) {\n    return comparator(a && a.__data__, b && b.__data__);\n  };\n}\n// type can be namespaced, e.g., \"click.foo\"\n// listener can be null for removal\nd3_selectionPrototype.on = function(type, listener, capture) {\n  if (arguments.length < 3) capture = false;\n\n  // parse the type specifier\n  var name = \"__on\" + type, i = type.indexOf(\".\");\n  if (i > 0) type = type.substring(0, i);\n\n  // if called with only one argument, return the current listener\n  if (arguments.length < 2) return (i = this.node()[name]) && i._;\n\n  // remove the old event listener, and add the new event listener\n  return this.each(function(d, i) {\n    var node = this;\n\n    if (node[name]) node.removeEventListener(type, node[name], capture);\n    if (listener) node.addEventListener(type, node[name] = l, capture);\n\n    // wrapped event listener that preserves i\n    function l(e) {\n      var o = d3.event; // Events can be reentrant (e.g., focus).\n      d3.event = e;\n      try {\n        listener.call(node, node.__data__, i);\n      } finally {\n        d3.event = o;\n      }\n    }\n\n    // stash the unwrapped listener for retrieval\n    l._ = listener;\n  });\n};\nd3_selectionPrototype.each = function(callback) {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      var node = group[i];\n      if (node) callback.call(node, node.__data__, i, j);\n    }\n  }\n  return this;\n};\n//\n// Note: assigning to the arguments array simultaneously changes the value of\n// the corresponding argument!\n//\n// TODO The `this` argument probably shouldn't be the first argument to the\n// callback, anyway, since it's redundant. However, that will require a major\n// version bump due to backwards compatibility, so I'm not changing it right\n// away.\n//\nd3_selectionPrototype.call = function(callback) {\n  callback.apply(this, (arguments[0] = this, arguments));\n  return this;\n};\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\nd3_selectionPrototype.node = function(callback) {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\nd3_selectionPrototype.transition = function() {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      subgroup.push((node = group[i]) ? {node: node, delay: 0, duration: 250} : null);\n    }\n  }\n\n  return d3_transition(subgroups, d3_transitionInheritId || ++d3_transitionId);\n};\nvar d3_selectionRoot = d3_selection([[document]]);\n\nd3_selectionRoot[0].parentNode = document.documentElement;\n\n// TODO fast singleton implementation!\nd3.select = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.select(selector)\n      : d3_selection([[selector]]); // assume node\n};\n\nd3.selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.selectAll(selector)\n      : d3_selection([selector]); // assume node[]\n};\nfunction d3_transition(groups, id) {\n  d3_arraySubclass(groups, d3_transitionPrototype);\n\n  var tweens = {},\n      event = d3.dispatch(\"start\", \"end\"),\n      ease = d3_transitionEase,\n      then = Date.now();\n\n  groups.id = id;\n\n  groups.tween = function(name, tween) {\n    if (arguments.length < 2) return tweens[name];\n    if (tween == null) delete tweens[name];\n    else tweens[name] = tween;\n    return groups;\n  };\n\n  groups.ease = function(value) {\n    if (!arguments.length) return ease;\n    ease = typeof value === \"function\" ? value : d3.ease.apply(d3, arguments);\n    return groups;\n  };\n\n  groups.each = function(type, listener) {\n    if (arguments.length < 2) return d3_transition_each.call(groups, type);\n    event[type].add(listener);\n    return groups;\n  };\n\n  d3.timer(function(elapsed) {\n    groups.each(function(d, i, j) {\n      var tweened = [],\n          node = this,\n          delay = groups[j][i].delay,\n          duration = groups[j][i].duration,\n          lock = node.__transition__ || (node.__transition__ = {active: 0, count: 0});\n\n      ++lock.count;\n\n      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, then);\n\n      function start(elapsed) {\n        if (lock.active > id) return stop();\n        lock.active = id;\n\n        for (var tween in tweens) {\n          if (tween = tweens[tween].call(node, d, i)) {\n            tweened.push(tween);\n          }\n        }\n\n        event.start.dispatch.call(node, d, i);\n        if (!tick(elapsed)) d3.timer(tick, 0, then);\n        return 1;\n      }\n\n      function tick(elapsed) {\n        if (lock.active !== id) return stop();\n\n        var t = (elapsed - delay) / duration,\n            e = ease(t),\n            n = tweened.length;\n\n        while (n > 0) {\n          tweened[--n].call(node, e);\n        }\n\n        if (t >= 1) {\n          stop();\n          d3_transitionInheritId = id;\n          event.end.dispatch.call(node, d, i);\n          d3_transitionInheritId = 0;\n          return 1;\n        }\n      }\n\n      function stop() {\n        if (!--lock.count) delete node.__transition__;\n        return 1;\n      }\n    });\n    return 1;\n  }, 0, then);\n\n  return groups;\n}\n\nfunction d3_transitionTween(b) {\n  return typeof b === \"function\"\n      ? function(d, i, a) { var v = b.call(this, d, i) + \"\"; return a != v && d3.interpolate(a, v); }\n      : (b = b + \"\", function(d, i, a) { return a != b && d3.interpolate(a, b); });\n}\n\nvar d3_transitionPrototype = [],\n    d3_transitionId = 0,\n    d3_transitionInheritId = 0,\n    d3_transitionEase = d3.ease(\"cubic-in-out\");\n\nd3_transitionPrototype.call = d3_selectionPrototype.call;\n\nd3.transition = function() {\n  return d3_selectionRoot.transition();\n};\n\nd3.transition.prototype = d3_transitionPrototype;\nd3_transitionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {\n        if (\"__data__\" in node.node) subnode.__data__ = node.node.__data__;\n        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id).ease(this.ease());\n};\nd3_transitionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = selector.call(node.node, node.node.__data__, i));\n        for (var k = -1, o = subgroup.length; ++k < o;) {\n          subgroup[k] = {node: subgroup[k], delay: node.delay, duration: node.duration};\n        }\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id).ease(this.ease());\n};\nd3_transitionPrototype.attr = function(name, value) {\n  return this.attrTween(name, d3_transitionTween(value));\n};\n\nd3_transitionPrototype.attrTween = function(name, tween) {\n  name = d3.ns.qualify(name);\n\n  function attrTween(d, i) {\n    var f = tween.call(this, d, i, this.getAttribute(name));\n    return f && function(t) {\n      this.setAttribute(name, f(t));\n    };\n  }\n\n  function attrTweenNS(d, i) {\n    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n    return f && function(t) {\n      this.setAttributeNS(name.space, name.local, f(t));\n    };\n  }\n\n  return this.tween(\"attr.\" + name, name.local ? attrTweenNS : attrTween);\n};\nd3_transitionPrototype.style = function(name, value, priority) {\n  if (arguments.length < 3) priority = \"\";\n  return this.styleTween(name, d3_transitionTween(value), priority);\n};\n\nd3_transitionPrototype.styleTween = function(name, tween, priority) {\n  if (arguments.length < 3) priority = \"\";\n  return this.tween(\"style.\" + name, function(d, i) {\n    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));\n    return f && function(t) {\n      this.style.setProperty(name, f(t), priority);\n    };\n  });\n};\nd3_transitionPrototype.text = function(value) {\n  return this.tween(\"text\", function(d, i) {\n    this.textContent = typeof value === \"function\"\n        ? value.call(this, d, i)\n        : value;\n  });\n};\nd3_transitionPrototype.remove = function() {\n  return this.each(\"end\", function() {\n    var p;\n    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\n  });\n};\nd3_transitionPrototype.delay = function(value) {\n  var groups = this;\n  return groups.each(typeof value === \"function\"\n      ? function(d, i, j) { groups[j][i].delay = +value.apply(this, arguments); }\n      : (value = +value, function(d, i, j) { groups[j][i].delay = value; }));\n};\nd3_transitionPrototype.duration = function(value) {\n  var groups = this;\n  return groups.each(typeof value === \"function\"\n      ? function(d, i, j) { groups[j][i].duration = +value.apply(this, arguments); }\n      : (value = +value, function(d, i, j) { groups[j][i].duration = value; }));\n};\nfunction d3_transition_each(callback) {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) callback.call(node = node.node, node.__data__, i, j);\n    }\n  }\n  return this;\n}\nd3_transitionPrototype.transition = function() {\n  return this.select(d3_this);\n};\nvar d3_timer_queue = null,\n    d3_timer_interval, // is an interval (or frame) active?\n    d3_timer_timeout; // is a timeout active?\n\n// The timer will continue to fire until callback returns true.\nd3.timer = function(callback, delay, then) {\n  var found = false,\n      t0,\n      t1 = d3_timer_queue;\n\n  if (arguments.length < 3) {\n    if (arguments.length < 2) delay = 0;\n    else if (!isFinite(delay)) return;\n    then = Date.now();\n  }\n\n  // See if the callback's already in the queue.\n  while (t1) {\n    if (t1.callback === callback) {\n      t1.then = then;\n      t1.delay = delay;\n      found = true;\n      break;\n    }\n    t0 = t1;\n    t1 = t1.next;\n  }\n\n  // Otherwise, add the callback to the queue.\n  if (!found) d3_timer_queue = {\n    callback: callback,\n    then: then,\n    delay: delay,\n    next: d3_timer_queue\n  };\n\n  // Start animatin'!\n  if (!d3_timer_interval) {\n    d3_timer_timeout = clearTimeout(d3_timer_timeout);\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nfunction d3_timer_step() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  var delay = d3_timer_flush() - now;\n  if (delay > 24) {\n    if (isFinite(delay)) {\n      clearTimeout(d3_timer_timeout);\n      d3_timer_timeout = setTimeout(d3_timer_step, delay);\n    }\n    d3_timer_interval = 0;\n  } else {\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nd3.timer.flush = function() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (!t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  d3_timer_flush();\n};\n\n// Flush after callbacks, to avoid concurrent queue modification.\nfunction d3_timer_flush() {\n  var t0 = null,\n      t1 = d3_timer_queue,\n      then = Infinity;\n  while (t1) {\n    if (t1.flush) {\n      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\n    } else {\n      then = Math.min(then, t1.then + t1.delay);\n      t1 = (t0 = t1).next;\n    }\n  }\n  return then;\n}\n\nvar d3_timer_frame = window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.oRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || function(callback) { setTimeout(callback, 17); };\nfunction d3_noop() {}\nd3.scale = {};\n\nfunction d3_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\nfunction d3_scale_nice(domain, nice) {\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      dx;\n\n  if (x1 < x0) {\n    dx = i0; i0 = i1; i1 = dx;\n    dx = x0; x0 = x1; x1 = dx;\n  }\n\n  nice = nice(x1 - x0);\n  domain[i0] = nice.floor(x0);\n  domain[i1] = nice.ceil(x1);\n  return domain;\n}\n\nfunction d3_scale_niceDefault() {\n  return Math;\n}\nd3.scale.linear = function() {\n  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);\n};\n\nfunction d3_scale_linear(domain, range, interpolate, clamp) {\n  var output,\n      input;\n\n  function rescale() {\n    var linear = domain.length == 2 ? d3_scale_bilinear : d3_scale_polylinear,\n        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n    output = linear(domain, range, uninterpolate, interpolate);\n    input = linear(range, domain, uninterpolate, d3.interpolate);\n    return scale;\n  }\n\n  function scale(x) {\n    return output(x);\n  }\n\n  // Note: requires range is coercible to number!\n  scale.invert = function(y) {\n    return input(y);\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(Number);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.rangeRound = function(x) {\n    return scale.range(x).interpolate(d3.interpolateRound);\n  };\n\n  scale.clamp = function(x) {\n    if (!arguments.length) return clamp;\n    clamp = x;\n    return rescale();\n  };\n\n  scale.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolate = x;\n    return rescale();\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  scale.nice = function() {\n    d3_scale_nice(domain, d3_scale_linearNice);\n    return rescale();\n  };\n\n  scale.copy = function() {\n    return d3_scale_linear(domain, range, interpolate, clamp);\n  };\n\n  return rescale();\n};\n\nfunction d3_scale_linearRebind(scale, linear) {\n  scale.range = d3.rebind(scale, linear.range);\n  scale.rangeRound = d3.rebind(scale, linear.rangeRound);\n  scale.interpolate = d3.rebind(scale, linear.interpolate);\n  scale.clamp = d3.rebind(scale, linear.clamp);\n  return scale;\n}\n\nfunction d3_scale_linearNice(dx) {\n  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n  return {\n    floor: function(x) { return Math.floor(x / dx) * dx; },\n    ceil: function(x) { return Math.ceil(x / dx) * dx; }\n  };\n}\n\n// TODO Dates? Ugh.\nfunction d3_scale_linearTickRange(domain, m) {\n  var extent = d3_scaleExtent(domain),\n      span = extent[1] - extent[0],\n      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n      err = m / span * step;\n\n  // Filter ticks to get closer to the desired count.\n  if (err <= .15) step *= 10;\n  else if (err <= .35) step *= 5;\n  else if (err <= .75) step *= 2;\n\n  // Round start and stop values to step interval.\n  extent[0] = Math.ceil(extent[0] / step) * step;\n  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive\n  extent[2] = step;\n  return extent;\n}\n\nfunction d3_scale_linearTicks(domain, m) {\n  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n}\n\nfunction d3_scale_linearTickFormat(domain, m) {\n  return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\n}\nfunction d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n  var u = uninterpolate(domain[0], domain[1]),\n      i = interpolate(range[0], range[1]);\n  return function(x) {\n    return i(u(x));\n  };\n}\nfunction d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n  var u = [],\n      i = [],\n      j = 0,\n      n = domain.length;\n\n  while (++j < n) {\n    u.push(uninterpolate(domain[j - 1], domain[j]));\n    i.push(interpolate(range[j - 1], range[j]));\n  }\n\n  return function(x) {\n    var j = d3.bisect(domain, x, 1, domain.length - 1) - 1;\n    return i[j](u[j](x));\n  };\n}\nd3.scale.log = function() {\n  return d3_scale_log(d3.scale.linear(), d3_scale_logp);\n};\n\nfunction d3_scale_log(linear, log) {\n  var pow = log.pow;\n\n  function scale(x) {\n    return linear(log(x));\n  }\n\n  scale.invert = function(x) {\n    return pow(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(pow);\n    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\n    pow = log.pow;\n    linear.domain(x.map(log));\n    return scale;\n  };\n\n  scale.nice = function() {\n    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n    return scale;\n  };\n\n  scale.ticks = function() {\n    var extent = d3_scaleExtent(linear.domain()),\n        ticks = [];\n    if (extent.every(isFinite)) {\n      var i = Math.floor(extent[0]),\n          j = Math.ceil(extent[1]),\n          u = pow(extent[0]),\n          v = pow(extent[1]);\n      if (log === d3_scale_logn) {\n        ticks.push(pow(i));\n        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n      } else {\n        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n        ticks.push(pow(i));\n      }\n      for (i = 0; ticks[i] < u; i++) {} // strip small values\n      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values\n      ticks = ticks.slice(i, j);\n    }\n    return ticks;\n  };\n\n  scale.tickFormat = function() {\n    return d3_scale_logTickFormat;\n  };\n\n  scale.copy = function() {\n    return d3_scale_log(linear.copy(), log);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n};\n\nfunction d3_scale_logp(x) {\n  return Math.log(x) / Math.LN10;\n}\n\nfunction d3_scale_logn(x) {\n  return -Math.log(-x) / Math.LN10;\n}\n\nd3_scale_logp.pow = function(x) {\n  return Math.pow(10, x);\n};\n\nd3_scale_logn.pow = function(x) {\n  return -Math.pow(10, -x);\n};\n\nfunction d3_scale_logTickFormat(d) {\n  return d.toPrecision(1);\n}\nd3.scale.pow = function() {\n  return d3_scale_pow(d3.scale.linear(), 1);\n};\n\nfunction d3_scale_pow(linear, exponent) {\n  var powp = d3_scale_powPow(exponent),\n      powb = d3_scale_powPow(1 / exponent);\n\n  function scale(x) {\n    return linear(powp(x));\n  }\n\n  scale.invert = function(x) {\n    return powb(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(powb);\n    linear.domain(x.map(powp));\n    return scale;\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(scale.domain(), m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(scale.domain(), m);\n  };\n\n  scale.nice = function() {\n    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n  };\n\n  scale.exponent = function(x) {\n    if (!arguments.length) return exponent;\n    var domain = scale.domain();\n    powp = d3_scale_powPow(exponent = x);\n    powb = d3_scale_powPow(1 / exponent);\n    return scale.domain(domain);\n  };\n\n  scale.copy = function() {\n    return d3_scale_pow(linear.copy(), exponent);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n};\n\nfunction d3_scale_powPow(e) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n  };\n}\nd3.scale.sqrt = function() {\n  return d3.scale.pow().exponent(.5);\n};\nd3.scale.ordinal = function() {\n  return d3_scale_ordinal([], {t: \"range\", x: []});\n};\n\nfunction d3_scale_ordinal(domain, ranger) {\n  var index,\n      range,\n      rangeBand;\n\n  function scale(x) {\n    return range[((index[x] || (index[x] = domain.push(x))) - 1) % range.length];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = [];\n    index = {};\n    var i = -1, n = x.length, xi;\n    while (++i < n) if (!index[xi = x[i]]) index[xi] = domain.push(xi);\n    return scale[ranger.t](ranger.x, ranger.p);\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    rangeBand = 0;\n    ranger = {t: \"range\", x: x};\n    return scale;\n  };\n\n  scale.rangePoints = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (domain.length - 1 + padding);\n    range = domain.length < 2 ? [(start + stop) / 2] : d3.range(start + step * padding / 2, stop + step / 2, step);\n    rangeBand = 0;\n    ranger = {t: \"rangePoints\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (domain.length + padding);\n    range = d3.range(start + step * padding, stop, step);\n    rangeBand = step * (1 - padding);\n    ranger = {t: \"rangeBands\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeRoundBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = Math.floor((stop - start) / (domain.length + padding)),\n        err = stop - start - (domain.length - padding) * step;\n    range = d3.range(start + Math.round(err / 2), stop, step);\n    rangeBand = Math.round(step * (1 - padding));\n    ranger = {t: \"rangeRoundBands\", x: x, p: padding};\n    return scale;\n  };\n\n  scale.rangeBand = function() {\n    return rangeBand;\n  };\n\n  scale.copy = function() {\n    return d3_scale_ordinal(domain, ranger);\n  };\n\n  return scale.domain(domain);\n};\n/*\n * This product includes color specifications and designs developed by Cynthia\n * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.\n */\n\nd3.scale.category10 = function() {\n  return d3.scale.ordinal().range(d3_category10);\n};\n\nd3.scale.category20 = function() {\n  return d3.scale.ordinal().range(d3_category20);\n};\n\nd3.scale.category20b = function() {\n  return d3.scale.ordinal().range(d3_category20b);\n};\n\nd3.scale.category20c = function() {\n  return d3.scale.ordinal().range(d3_category20c);\n};\n\nvar d3_category10 = [\n  \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n  \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"\n];\n\nvar d3_category20 = [\n  \"#1f77b4\", \"#aec7e8\",\n  \"#ff7f0e\", \"#ffbb78\",\n  \"#2ca02c\", \"#98df8a\",\n  \"#d62728\", \"#ff9896\",\n  \"#9467bd\", \"#c5b0d5\",\n  \"#8c564b\", \"#c49c94\",\n  \"#e377c2\", \"#f7b6d2\",\n  \"#7f7f7f\", \"#c7c7c7\",\n  \"#bcbd22\", \"#dbdb8d\",\n  \"#17becf\", \"#9edae5\"\n];\n\nvar d3_category20b = [\n  \"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\",\n  \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\",\n  \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\",\n  \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\",\n  \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\"\n];\n\nvar d3_category20c = [\n  \"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\",\n  \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\",\n  \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\",\n  \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\",\n  \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\"\n];\nd3.scale.quantile = function() {\n  return d3_scale_quantile([], []);\n};\n\nfunction d3_scale_quantile(domain, range) {\n  var thresholds;\n\n  function rescale() {\n    var k = 0,\n        n = domain.length,\n        q = range.length;\n    thresholds = [];\n    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n    return scale;\n  }\n\n  function scale(x) {\n    if (isNaN(x = +x)) return NaN;\n    return range[d3.bisect(thresholds, x)];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.quantiles = function() {\n    return thresholds;\n  };\n\n  scale.copy = function() {\n    return d3_scale_quantile(domain, range); // copy on write!\n  };\n\n  return rescale();\n};\nd3.scale.quantize = function() {\n  return d3_scale_quantize(0, 1, [0, 1]);\n};\n\nfunction d3_scale_quantize(x0, x1, range) {\n  var kx, i;\n\n  function scale(x) {\n    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n  }\n\n  function rescale() {\n    kx = range.length / (x1 - x0);\n    i = range.length - 1;\n    return scale;\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return [x0, x1];\n    x0 = +x[0];\n    x1 = +x[x.length - 1];\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.copy = function() {\n    return d3_scale_quantize(x0, x1, range); // copy on write\n  };\n\n  return rescale();\n};\nd3.svg = {};\nd3.svg.arc = function() {\n  var innerRadius = d3_svg_arcInnerRadius,\n      outerRadius = d3_svg_arcOuterRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  function arc() {\n    var r0 = innerRadius.apply(this, arguments),\n        r1 = outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),\n        df = da < Math.PI ? \"0\" : \"1\",\n        c0 = Math.cos(a0),\n        s0 = Math.sin(a0),\n        c1 = Math.cos(a1),\n        s1 = Math.sin(a1);\n    return da >= d3_svg_arcMax\n      ? (r0\n      ? \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"M0,\" + r0\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + (-r0)\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0\n      + \"Z\"\n      : \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"Z\")\n      : (r0\n      ? \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L\" + r0 * c1 + \",\" + r0 * s1\n      + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0\n      + \"Z\"\n      : \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L0,0\"\n      + \"Z\");\n  }\n\n  arc.innerRadius = function(v) {\n    if (!arguments.length) return innerRadius;\n    innerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.outerRadius = function(v) {\n    if (!arguments.length) return outerRadius;\n    outerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.centroid = function() {\n    var r = (innerRadius.apply(this, arguments)\n        + outerRadius.apply(this, arguments)) / 2,\n        a = (startAngle.apply(this, arguments)\n        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\n    return [Math.cos(a) * r, Math.sin(a) * r];\n  };\n\n  return arc;\n};\n\nvar d3_svg_arcOffset = -Math.PI / 2,\n    d3_svg_arcMax = 2 * Math.PI - 1e-6;\n\nfunction d3_svg_arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction d3_svg_arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction d3_svg_arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction d3_svg_line(projection) {\n  var x = d3_svg_lineX,\n      y = d3_svg_lineY,\n      interpolate = \"linear\",\n      interpolator = d3_svg_lineInterpolators[interpolate],\n      tension = .7;\n\n  function line(d) {\n    return d.length < 1 ? null : \"M\" + interpolator(projection(d3_svg_linePoints(this, d, x, y)), tension);\n  }\n\n  line.x = function(v) {\n    if (!arguments.length) return x;\n    x = v;\n    return line;\n  };\n\n  line.y = function(v) {\n    if (!arguments.length) return y;\n    y = v;\n    return line;\n  };\n\n  line.interpolate = function(v) {\n    if (!arguments.length) return interpolate;\n    interpolator = d3_svg_lineInterpolators[interpolate = v];\n    return line;\n  };\n\n  line.tension = function(v) {\n    if (!arguments.length) return tension;\n    tension = v;\n    return line;\n  };\n\n  return line;\n}\n\nd3.svg.line = function() {\n  return d3_svg_line(Object);\n};\n\n// Converts the specified array of data into an array of points\n// (x-y tuples), by evaluating the specified `x` and `y` functions on each\n// data point. The `this` context of the evaluated functions is the specified\n// \"self\" object; each function is passed the current datum and index.\nfunction d3_svg_linePoints(self, d, x, y) {\n  var points = [],\n      i = -1,\n      n = d.length,\n      fx = typeof x === \"function\",\n      fy = typeof y === \"function\",\n      value;\n  if (fx && fy) {\n    while (++i < n) points.push([\n      x.call(self, value = d[i], i),\n      y.call(self, value, i)\n    ]);\n  } else if (fx) {\n    while (++i < n) points.push([x.call(self, d[i], i), y]);\n  } else if (fy) {\n    while (++i < n) points.push([x, y.call(self, d[i], i)]);\n  } else {\n    while (++i < n) points.push([x, y]);\n  }\n  return points;\n}\n\n// The default `x` property, which references d[0].\nfunction d3_svg_lineX(d) {\n  return d[0];\n}\n\n// The default `y` property, which references d[1].\nfunction d3_svg_lineY(d) {\n  return d[1];\n}\n\n// The various interpolators supported by the `line` class.\nvar d3_svg_lineInterpolators = {\n  \"linear\": d3_svg_lineLinear,\n  \"step-before\": d3_svg_lineStepBefore,\n  \"step-after\": d3_svg_lineStepAfter,\n  \"basis\": d3_svg_lineBasis,\n  \"basis-open\": d3_svg_lineBasisOpen,\n  \"basis-closed\": d3_svg_lineBasisClosed,\n  \"bundle\": d3_svg_lineBundle,\n  \"cardinal\": d3_svg_lineCardinal,\n  \"cardinal-open\": d3_svg_lineCardinalOpen,\n  \"cardinal-closed\": d3_svg_lineCardinalClosed,\n  \"monotone\": d3_svg_lineMonotone\n};\n\n// Linear interpolation; generates \"L\" commands.\nfunction d3_svg_lineLinear(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"L\", (p = points[i])[0], \",\", p[1]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepBefore(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepAfter(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n  return path.join(\"\");\n}\n\n// Open cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalOpen(points, tension) {\n  return points.length < 4\n      ? d3_svg_lineLinear(points)\n      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Closed cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalClosed(points, tension) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),\n        d3_svg_lineCardinalTangents([points[points.length - 2]]\n        .concat(points, [points[1]]), tension));\n}\n\n// Cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinal(points, tension, closed) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite(points,\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Hermite spline construction; generates \"C\" commands.\nfunction d3_svg_lineHermite(points, tangents) {\n  if (tangents.length < 1\n      || (points.length != tangents.length\n      && points.length != tangents.length + 2)) {\n    return d3_svg_lineLinear(points);\n  }\n\n  var quad = points.length != tangents.length,\n      path = \"\",\n      p0 = points[0],\n      p = points[1],\n      t0 = tangents[0],\n      t = t0,\n      pi = 1;\n\n  if (quad) {\n    path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3)\n        + \",\" + p[0] + \",\" + p[1];\n    p0 = points[1];\n    pi = 2;\n  }\n\n  if (tangents.length > 1) {\n    t = tangents[1];\n    p = points[pi];\n    pi++;\n    path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1])\n        + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n        + \",\" + p[0] + \",\" + p[1];\n    for (var i = 2; i < tangents.length; i++, pi++) {\n      p = points[pi];\n      t = tangents[i];\n      path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n          + \",\" + p[0] + \",\" + p[1];\n    }\n  }\n\n  if (quad) {\n    var lp = points[pi];\n    path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3)\n        + \",\" + lp[0] + \",\" + lp[1];\n  }\n\n  return path;\n}\n\n// Generates tangents for a cardinal spline.\nfunction d3_svg_lineCardinalTangents(points, tension) {\n  var tangents = [],\n      a = (1 - tension) / 2,\n      p0,\n      p1 = points[0],\n      p2 = points[1],\n      i = 1,\n      n = points.length;\n  while (++i < n) {\n    p0 = p1;\n    p1 = p2;\n    p2 = points[i];\n    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n  }\n  return tangents;\n}\n\n// B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasis(points) {\n  if (points.length < 3) return d3_svg_lineLinear(points);\n  var i = 1,\n      n = points.length,\n      pi = points[0],\n      x0 = pi[0],\n      y0 = pi[1],\n      px = [x0, x0, x0, (pi = points[1])[0]],\n      py = [y0, y0, y0, pi[1]],\n      path = [x0, \",\", y0];\n  d3_svg_lineBasisBezier(path, px, py);\n  while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  i = -1;\n  while (++i < 2) {\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Open B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisOpen(points) {\n  if (points.length < 4) return d3_svg_lineLinear(points);\n  var path = [],\n      i = -1,\n      n = points.length,\n      pi,\n      px = [0],\n      py = [0];\n  while (++i < 3) {\n    pi = points[i];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)\n    + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n  --i; while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Closed B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisClosed(points) {\n  var path,\n      i = -1,\n      n = points.length,\n      m = n + 4,\n      pi,\n      px = [],\n      py = [];\n  while (++i < 4) {\n    pi = points[i % n];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path = [\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\",\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)\n  ];\n  --i; while (++i < m) {\n    pi = points[i % n];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\nfunction d3_svg_lineBundle(points, tension) {\n  var n = points.length - 1,\n      x0 = points[0][0],\n      y0 = points[0][1],\n      dx = points[n][0] - x0,\n      dy = points[n][1] - y0,\n      i = -1,\n      p,\n      t;\n  while (++i <= n) {\n    p = points[i];\n    t = i / n;\n    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n  }\n  return d3_svg_lineBasis(points);\n}\n\n// Returns the dot product of the given four-element vectors.\nfunction d3_svg_lineDot4(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n// Matrix to transform basis (b-spline) control points to bezier\n// control points. Derived from FvD 11.2.8.\nvar d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],\n    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],\n    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];\n\n// Pushes a \"C\" Bézier curve onto the specified path array, given the\n// two specified four-element arrays which define the control points.\nfunction d3_svg_lineBasisBezier(path, x, y) {\n  path.push(\n      \"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n}\n\n// Computes the slope from points p0 to p1.\nfunction d3_svg_lineSlope(p0, p1) {\n  return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n}\n\n// Compute three-point differences for the given points.\n// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference\nfunction d3_svg_lineFiniteDifferences(points) {\n  var i = 0,\n      j = points.length - 1,\n      m = [],\n      p0 = points[0],\n      p1 = points[1],\n      d = m[0] = d3_svg_lineSlope(p0, p1);\n  while (++i < j) {\n    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));\n  }\n  m[i] = d;\n  return m;\n}\n\n// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite\n// interpolation. Returns an array of tangent vectors. For details, see\n// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation\nfunction d3_svg_lineMonotoneTangents(points) {\n  var tangents = [],\n      d,\n      a,\n      b,\n      s,\n      m = d3_svg_lineFiniteDifferences(points),\n      i = -1,\n      j = points.length - 1;\n\n  // The first two steps are done by computing finite-differences:\n  // 1. Compute the slopes of the secant lines between successive points.\n  // 2. Initialize the tangents at every point as the average of the secants.\n\n  // Then, for each segment…\n  while (++i < j) {\n    d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set\n    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to\n    // preserve monotonicity. Ignore step 4 and 5 for those k.\n\n    if (Math.abs(d) < 1e-6) {\n      m[i] = m[i + 1] = 0;\n    } else {\n      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.\n      a = m[i] / d;\n      b = m[i + 1] / d;\n\n      // 5. Prevent overshoot and ensure monotonicity by restricting the\n      // magnitude of vector <ak, bk> to a circle of radius 3.\n      s = a * a + b * b;\n      if (s > 9) {\n        s = d * 3 / Math.sqrt(s);\n        m[i] = s * a;\n        m[i + 1] = s * b;\n      }\n    }\n  }\n\n  // Compute the normalized tangent vector from the slopes. Note that if x is\n  // not monotonic, it's possible that the slope will be infinite, so we protect\n  // against NaN by setting the coordinate to zero.\n  i = -1; while (++i <= j) {\n    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0])\n      / (6 * (1 + m[i] * m[i]));\n    tangents.push([s || 0, m[i] * s || 0]);\n  }\n\n  return tangents;\n}\n\nfunction d3_svg_lineMonotone(points) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] +\n        d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n}\nd3.svg.line.radial = function() {\n  var line = d3_svg_line(d3_svg_lineRadial);\n  line.radius = line.x, delete line.x;\n  line.angle = line.y, delete line.y;\n  return line;\n};\n\nfunction d3_svg_lineRadial(points) {\n  var point,\n      i = -1,\n      n = points.length,\n      r,\n      a;\n  while (++i < n) {\n    point = points[i];\n    r = point[0];\n    a = point[1] + d3_svg_arcOffset;\n    point[0] = r * Math.cos(a);\n    point[1] = r * Math.sin(a);\n  }\n  return points;\n}\nfunction d3_svg_area(projection) {\n  var x0 = d3_svg_lineX,\n      x1 = d3_svg_lineX,\n      y0 = 0,\n      y1 = d3_svg_lineY,\n      interpolate = \"linear\",\n      interpolator = d3_svg_lineInterpolators[interpolate],\n      tension = .7;\n\n  function area(d) {\n    if (d.length < 1) return null;\n    var points0 = d3_svg_linePoints(this, d, x0, y0),\n        points1 = d3_svg_linePoints(this, d, x0 === x1 ? d3_svg_areaX(points0) : x1, y0 === y1 ? d3_svg_areaY(points0) : y1);\n    return \"M\" + interpolator(projection(points1), tension)\n         + \"L\" + interpolator(projection(points0.reverse()), tension)\n         + \"Z\";\n  }\n\n  area.x = function(x) {\n    if (!arguments.length) return x1;\n    x0 = x1 = x;\n    return area;\n  };\n\n  area.x0 = function(x) {\n    if (!arguments.length) return x0;\n    x0 = x;\n    return area;\n  };\n\n  area.x1 = function(x) {\n    if (!arguments.length) return x1;\n    x1 = x;\n    return area;\n  };\n\n  area.y = function(y) {\n    if (!arguments.length) return y1;\n    y0 = y1 = y;\n    return area;\n  };\n\n  area.y0 = function(y) {\n    if (!arguments.length) return y0;\n    y0 = y;\n    return area;\n  };\n\n  area.y1 = function(y) {\n    if (!arguments.length) return y1;\n    y1 = y;\n    return area;\n  };\n\n  area.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolator = d3_svg_lineInterpolators[interpolate = x];\n    return area;\n  };\n\n  area.tension = function(x) {\n    if (!arguments.length) return tension;\n    tension = x;\n    return area;\n  };\n\n  return area;\n}\n\nd3.svg.area = function() {\n  return d3_svg_area(Object);\n};\n\nfunction d3_svg_areaX(points) {\n  return function(d, i) {\n    return points[i][0];\n  };\n}\n\nfunction d3_svg_areaY(points) {\n  return function(d, i) {\n    return points[i][1];\n  };\n}\nd3.svg.area.radial = function() {\n  var area = d3_svg_area(d3_svg_lineRadial);\n  area.radius = area.x, delete area.x;\n  area.innerRadius = area.x0, delete area.x0;\n  area.outerRadius = area.x1, delete area.x1;\n  area.angle = area.y, delete area.y;\n  area.startAngle = area.y0, delete area.y0;\n  area.endAngle = area.y1, delete area.y1;\n  return area;\n};\nd3.svg.chord = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      radius = d3_svg_chordRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  // TODO Allow control point to be customized.\n\n  function chord(d, i) {\n    var s = subgroup(this, source, d, i),\n        t = subgroup(this, target, d, i);\n    return \"M\" + s.p0\n      + arc(s.r, s.p1) + (equals(s, t)\n      ? curve(s.r, s.p1, s.r, s.p0)\n      : curve(s.r, s.p1, t.r, t.p0)\n      + arc(t.r, t.p1)\n      + curve(t.r, t.p1, s.r, s.p0))\n      + \"Z\";\n  }\n\n  function subgroup(self, f, d, i) {\n    var subgroup = f.call(self, d, i),\n        r = radius.call(self, subgroup, i),\n        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n    return {\n      r: r,\n      a0: a0,\n      a1: a1,\n      p0: [r * Math.cos(a0), r * Math.sin(a0)],\n      p1: [r * Math.cos(a1), r * Math.sin(a1)]\n    };\n  }\n\n  function equals(a, b) {\n    return a.a0 == b.a0 && a.a1 == b.a1;\n  }\n\n  function arc(r, p) {\n    return \"A\" + r + \",\" + r + \" 0 0,1 \" + p;\n  }\n\n  function curve(r0, p0, r1, p1) {\n    return \"Q 0,0 \" + p1;\n  }\n\n  chord.radius = function(v) {\n    if (!arguments.length) return radius;\n    radius = d3.functor(v);\n    return chord;\n  };\n\n  chord.source = function(v) {\n    if (!arguments.length) return source;\n    source = d3.functor(v);\n    return chord;\n  };\n\n  chord.target = function(v) {\n    if (!arguments.length) return target;\n    target = d3.functor(v);\n    return chord;\n  };\n\n  chord.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return chord;\n  };\n\n  chord.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return chord;\n  };\n\n  return chord;\n};\n\nfunction d3_svg_chordSource(d) {\n  return d.source;\n}\n\nfunction d3_svg_chordTarget(d) {\n  return d.target;\n}\n\nfunction d3_svg_chordRadius(d) {\n  return d.radius;\n}\n\nfunction d3_svg_chordStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_chordEndAngle(d) {\n  return d.endAngle;\n}\nd3.svg.diagonal = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      projection = d3_svg_diagonalProjection;\n\n  function diagonal(d, i) {\n    var p0 = source.call(this, d, i),\n        p3 = target.call(this, d, i),\n        m = (p0.y + p3.y) / 2,\n        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];\n    p = p.map(projection);\n    return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n  }\n\n  diagonal.source = function(x) {\n    if (!arguments.length) return source;\n    source = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.target = function(x) {\n    if (!arguments.length) return target;\n    target = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.projection = function(x) {\n    if (!arguments.length) return projection;\n    projection = x;\n    return diagonal;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalProjection(d) {\n  return [d.x, d.y];\n}\nd3.svg.diagonal.radial = function() {\n  var diagonal = d3.svg.diagonal(),\n      projection = d3_svg_diagonalProjection,\n      projection_ = diagonal.projection;\n\n  diagonal.projection = function(x) {\n    return arguments.length\n        ? projection_(d3_svg_diagonalRadialProjection(projection = x))\n        : projection;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalRadialProjection(projection) {\n  return function() {\n    var d = projection.apply(this, arguments),\n        r = d[0],\n        a = d[1] + d3_svg_arcOffset;\n    return [r * Math.cos(a), r * Math.sin(a)];\n  };\n}\nd3.svg.mouse = function(container) {\n  return d3_svg_mousePoint(container, d3.event);\n};\n\n// https://bugs.webkit.org/show_bug.cgi?id=44083\nvar d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n\nfunction d3_svg_mousePoint(container, e) {\n  var point = (container.ownerSVGElement || container).createSVGPoint();\n  if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {\n    var svg = d3.select(document.body)\n      .append(\"svg:svg\")\n        .style(\"position\", \"absolute\")\n        .style(\"top\", 0)\n        .style(\"left\", 0);\n    var ctm = svg[0][0].getScreenCTM();\n    d3_mouse_bug44083 = !(ctm.f || ctm.e);\n    svg.remove();\n  }\n  if (d3_mouse_bug44083) {\n    point.x = e.pageX;\n    point.y = e.pageY;\n  } else {\n    point.x = e.clientX;\n    point.y = e.clientY;\n  }\n  point = point.matrixTransform(container.getScreenCTM().inverse());\n  return [point.x, point.y];\n};\nd3.svg.touches = function(container) {\n  var touches = d3.event.touches;\n  return touches ? Array.prototype.map.call(touches, function(touch) {\n    var point = d3_svg_mousePoint(container, touch);\n    point.identifier = touch.identifier;\n    return point;\n  }) : [];\n};\nd3.svg.symbol = function() {\n  var type = d3_svg_symbolType,\n      size = d3_svg_symbolSize;\n\n  function symbol(d, i) {\n    return (d3_svg_symbols[type.call(this, d, i)]\n        || d3_svg_symbols.circle)\n        (size.call(this, d, i));\n  }\n\n  symbol.type = function(x) {\n    if (!arguments.length) return type;\n    type = d3.functor(x);\n    return symbol;\n  };\n\n  // size of symbol in square pixels\n  symbol.size = function(x) {\n    if (!arguments.length) return size;\n    size = d3.functor(x);\n    return symbol;\n  };\n\n  return symbol;\n};\n\nfunction d3_svg_symbolSize() {\n  return 64;\n}\n\nfunction d3_svg_symbolType() {\n  return \"circle\";\n}\n\n// TODO cross-diagonal?\nvar d3_svg_symbols = {\n  \"circle\": function(size) {\n    var r = Math.sqrt(size / Math.PI);\n    return \"M0,\" + r\n        + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r)\n        + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r\n        + \"Z\";\n  },\n  \"cross\": function(size) {\n    var r = Math.sqrt(size / 5) / 2;\n    return \"M\" + -3 * r + \",\" + -r\n        + \"H\" + -r\n        + \"V\" + -3 * r\n        + \"H\" + r\n        + \"V\" + -r\n        + \"H\" + 3 * r\n        + \"V\" + r\n        + \"H\" + r\n        + \"V\" + 3 * r\n        + \"H\" + -r\n        + \"V\" + r\n        + \"H\" + -3 * r\n        + \"Z\";\n  },\n  \"diamond\": function(size) {\n    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n        rx = ry * d3_svg_symbolTan30;\n    return \"M0,\" + -ry\n        + \"L\" + rx + \",0\"\n        + \" 0,\" + ry\n        + \" \" + -rx + \",0\"\n        + \"Z\";\n  },\n  \"square\": function(size) {\n    var r = Math.sqrt(size) / 2;\n    return \"M\" + -r + \",\" + -r\n        + \"L\" + r + \",\" + -r\n        + \" \" + r + \",\" + r\n        + \" \" + -r + \",\" + r\n        + \"Z\";\n  },\n  \"triangle-down\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + ry\n        + \"L\" + rx +\",\" + -ry\n        + \" \" + -rx + \",\" + -ry\n        + \"Z\";\n  },\n  \"triangle-up\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + -ry\n        + \"L\" + rx +\",\" + ry\n        + \" \" + -rx + \",\" + ry\n        + \"Z\";\n  }\n};\n\nd3.svg.symbolTypes = d3.keys(d3_svg_symbols);\n\nvar d3_svg_symbolSqrt3 = Math.sqrt(3),\n    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);\nd3.svg.axis = function() {\n  var scale = d3.scale.linear(),\n      orient = \"bottom\",\n      tickMajorSize = 6,\n      tickMinorSize = 6,\n      tickEndSize = 6,\n      tickPadding = 3,\n      tickArguments_ = [10],\n      tickFormat_,\n      tickSubdivide = 0;\n\n  function axis(selection) {\n    selection.each(function(d, i, j) {\n      var g = d3.select(this);\n\n      // Ticks.\n      var ticks = scale.ticks.apply(scale, tickArguments_),\n          tickFormat = tickFormat_ == null ? scale.tickFormat.apply(scale, tickArguments_) : tickFormat_;\n\n      // Minor ticks.\n      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),\n          subtick = g.selectAll(\".minor\").data(subticks, String),\n          subtickEnter = subtick.enter().insert(\"svg:line\", \"g\").attr(\"class\", \"tick minor\").style(\"opacity\", 1e-6),\n          subtickExit = transition(subtick.exit()).style(\"opacity\", 1e-6).remove(),\n          subtickUpdate = transition(subtick).style(\"opacity\", 1);\n\n      // Major ticks.\n      var tick = g.selectAll(\"g\").data(ticks, String),\n          tickEnter = tick.enter().insert(\"svg:g\", \"path\").style(\"opacity\", 1e-6),\n          tickExit = transition(tick.exit()).style(\"opacity\", 1e-6).remove(),\n          tickUpdate = transition(tick).style(\"opacity\", 1),\n          tickTransform;\n\n      // Domain.\n      var range = d3_scaleExtent(scale.range()),\n          path = g.selectAll(\".domain\").data([0]),\n          pathEnter = path.enter().append(\"svg:path\").attr(\"class\", \"domain\"),\n          pathUpdate = transition(path);\n\n      // Stash the new scale and grab the old scale.\n      var scale0 = this.__chart__ || scale;\n      this.__chart__ = scale.copy();\n\n      tickEnter.append(\"svg:line\").attr(\"class\", \"tick\");\n      tickEnter.append(\"svg:text\");\n      tickUpdate.select(\"text\").text(tickFormat);\n\n      switch (orient) {\n        case \"bottom\": {\n          tickTransform = d3_svg_axisX;\n          subtickUpdate.attr(\"y2\", tickMinorSize);\n          tickEnter.select(\"text\").attr(\"dy\", \".71em\").attr(\"text-anchor\", \"middle\");\n          tickUpdate.select(\"line\").attr(\"y2\", tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + tickEndSize + \"V0H\" + range[1] + \"V\" + tickEndSize);\n          break;\n        }\n        case \"top\": {\n          tickTransform = d3_svg_axisX;\n          subtickUpdate.attr(\"y2\", -tickMinorSize);\n          tickEnter.select(\"text\").attr(\"text-anchor\", \"middle\");\n          tickUpdate.select(\"line\").attr(\"y2\", -tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + -tickEndSize + \"V0H\" + range[1] + \"V\" + -tickEndSize);\n          break;\n        }\n        case \"left\": {\n          tickTransform = d3_svg_axisY;\n          subtickUpdate.attr(\"x2\", -tickMinorSize);\n          tickEnter.select(\"text\").attr(\"dy\", \".32em\").attr(\"text-anchor\", \"end\");\n          tickUpdate.select(\"line\").attr(\"x2\", -tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding));\n          pathUpdate.attr(\"d\", \"M\" + -tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + -tickEndSize);\n          break;\n        }\n        case \"right\": {\n          tickTransform = d3_svg_axisY;\n          subtickUpdate.attr(\"x2\", tickMinorSize);\n          tickEnter.select(\"text\").attr(\"dy\", \".32em\");\n          tickUpdate.select(\"line\").attr(\"x2\", tickMajorSize);\n          tickUpdate.select(\"text\").attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding);\n          pathUpdate.attr(\"d\", \"M\" + tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + tickEndSize);\n          break;\n        }\n      }\n\n      tickEnter.call(tickTransform, scale0);\n      tickUpdate.call(tickTransform, scale);\n      tickExit.call(tickTransform, scale);\n\n      subtickEnter.call(tickTransform, scale0);\n      subtickUpdate.call(tickTransform, scale);\n      subtickExit.call(tickTransform, scale);\n\n      function transition(o) {\n        return selection.delay ? o.transition()\n            .delay(selection[j][i].delay)\n            .duration(selection[j][i].duration)\n            .ease(selection.ease()) : o;\n      }\n    });\n  }\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = x;\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x;\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments_;\n    tickArguments_ = arguments;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormat_;\n    tickFormat_ = x;\n    return axis;\n  };\n\n  axis.tickSize = function(x, y, z) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1;\n    tickMajorSize = +x;\n    tickMinorSize = n > 1 ? +y : tickMajorSize;\n    tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    tickPadding = +x;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n\n  return axis;\n};\n\nfunction d3_svg_axisX(selection, x) {\n  selection.attr(\"transform\", function(d) { return \"translate(\" + x(d) + \",0)\"; });\n}\n\nfunction d3_svg_axisY(selection, y) {\n  selection.attr(\"transform\", function(d) { return \"translate(0,\" + y(d) + \")\"; });\n}\n\nfunction d3_svg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = d3_scaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\nd3.behavior = {};\nd3.behavior.drag = function() {\n  var event = d3.dispatch(\"drag\", \"dragstart\", \"dragend\");\n\n  function drag() {\n    this\n        .on(\"mousedown.drag\", mousedown)\n        .on(\"touchstart.drag\", mousedown);\n\n    d3.select(window)\n        .on(\"mousemove.drag\", d3_behavior_dragMove)\n        .on(\"touchmove.drag\", d3_behavior_dragMove)\n        .on(\"mouseup.drag\", d3_behavior_dragUp, true)\n        .on(\"touchend.drag\", d3_behavior_dragUp, true)\n        .on(\"click.drag\", d3_behavior_dragClick, true);\n  }\n\n  // snapshot the local context for subsequent dispatch\n  function start() {\n    d3_behavior_dragEvent = event;\n    d3_behavior_dragOffset = d3_behavior_dragPoint((d3_behavior_dragTarget = this).parentNode);\n    d3_behavior_dragMoved = 0;\n    d3_behavior_dragArguments = arguments;\n  }\n\n  function mousedown() {\n    start.apply(this, arguments);\n    d3_behavior_dragDispatch(\"dragstart\");\n  }\n\n  drag.on = function(type, listener) {\n    event[type].add(listener);\n    return drag;\n  };\n\n  return drag;\n};\n\nvar d3_behavior_dragEvent,\n    d3_behavior_dragTarget,\n    d3_behavior_dragArguments,\n    d3_behavior_dragOffset,\n    d3_behavior_dragMoved,\n    d3_behavior_dragStopClick;\n\nfunction d3_behavior_dragDispatch(type) {\n  var o = d3.event, p = d3_behavior_dragTarget.parentNode, dx = 0, dy = 0;\n\n  if (p) {\n    p = d3_behavior_dragPoint(p);\n    dx = p[0] - d3_behavior_dragOffset[0];\n    dy = p[1] - d3_behavior_dragOffset[1];\n    d3_behavior_dragOffset = p;\n    d3_behavior_dragMoved |= dx | dy;\n  }\n\n  try {\n    d3.event = {dx: dx, dy: dy};\n    d3_behavior_dragEvent[type].dispatch.apply(d3_behavior_dragTarget, d3_behavior_dragArguments);\n  } finally {\n    d3.event = o;\n  }\n\n  o.preventDefault();\n}\n\nfunction d3_behavior_dragPoint(container) {\n  return d3.event.touches\n      ? d3.svg.touches(container)[0]\n      : d3.svg.mouse(container);\n}\n\nfunction d3_behavior_dragMove() {\n  if (!d3_behavior_dragTarget) return;\n  var parent = d3_behavior_dragTarget.parentNode;\n\n  // O NOES! The drag element was removed from the DOM.\n  if (!parent) return d3_behavior_dragUp();\n\n  d3_behavior_dragDispatch(\"drag\");\n  d3_behavior_dragCancel();\n}\n\nfunction d3_behavior_dragUp() {\n  if (!d3_behavior_dragTarget) return;\n  d3_behavior_dragDispatch(\"dragend\");\n  d3_behavior_dragTarget = null;\n\n  // If the node was moved, prevent the mouseup from propagating.\n  // Also prevent the subsequent click from propagating (e.g., for anchors).\n  if (d3_behavior_dragMoved) {\n    d3_behavior_dragStopClick = true;\n    d3_behavior_dragCancel();\n  }\n}\n\nfunction d3_behavior_dragClick() {\n  if (d3_behavior_dragStopClick) {\n    d3_behavior_dragCancel();\n    d3_behavior_dragStopClick = false;\n  }\n}\n\nfunction d3_behavior_dragCancel() {\n  d3.event.stopPropagation();\n  d3.event.preventDefault();\n}\n// TODO unbind zoom behavior?\n// TODO unbind listener?\nd3.behavior.zoom = function() {\n  var xyz = [0, 0, 0],\n      event = d3.dispatch(\"zoom\");\n\n  function zoom() {\n    this\n        .on(\"mousedown.zoom\", mousedown)\n        .on(\"mousewheel.zoom\", mousewheel)\n        .on(\"DOMMouseScroll.zoom\", mousewheel)\n        .on(\"dblclick.zoom\", dblclick)\n        .on(\"touchstart.zoom\", touchstart);\n\n    d3.select(window)\n        .on(\"mousemove.zoom\", d3_behavior_zoomMousemove)\n        .on(\"mouseup.zoom\", d3_behavior_zoomMouseup)\n        .on(\"touchmove.zoom\", d3_behavior_zoomTouchmove)\n        .on(\"touchend.zoom\", d3_behavior_zoomTouchup)\n        .on(\"click.zoom\", d3_behavior_zoomClick, true);\n  }\n\n  // snapshot the local context for subsequent dispatch\n  function start() {\n    d3_behavior_zoomXyz = xyz;\n    d3_behavior_zoomDispatch = event.zoom.dispatch;\n    d3_behavior_zoomTarget = this;\n    d3_behavior_zoomArguments = arguments;\n  }\n\n  function mousedown() {\n    start.apply(this, arguments);\n    d3_behavior_zoomPanning = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));\n    d3_behavior_zoomMoved = false;\n    d3.event.preventDefault();\n    window.focus();\n  }\n\n  // store starting mouse location\n  function mousewheel() {\n    start.apply(this, arguments);\n    if (!d3_behavior_zoomZooming) d3_behavior_zoomZooming = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));\n    d3_behavior_zoomTo(d3_behavior_zoomDelta() + xyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomZooming);\n  }\n\n  function dblclick() {\n    start.apply(this, arguments);\n    var mouse = d3.svg.mouse(d3_behavior_zoomTarget);\n    d3_behavior_zoomTo(d3.event.shiftKey ? Math.ceil(xyz[2] - 1) : Math.floor(xyz[2] + 1), mouse, d3_behavior_zoomLocation(mouse));\n  }\n\n  // doubletap detection\n  function touchstart() {\n    start.apply(this, arguments);\n    var touches = d3_behavior_zoomTouchup(),\n        touch,\n        now = Date.now();\n    if ((touches.length === 1) && (now - d3_behavior_zoomLast < 300)) {\n      d3_behavior_zoomTo(1 + Math.floor(xyz[2]), touch = touches[0], d3_behavior_zoomLocations[touch.identifier]);\n    }\n    d3_behavior_zoomLast = now;\n  }\n\n  zoom.on = function(type, listener) {\n    event[type].add(listener);\n    return zoom;\n  };\n\n  return zoom;\n};\n\nvar d3_behavior_zoomDiv,\n    d3_behavior_zoomPanning,\n    d3_behavior_zoomZooming,\n    d3_behavior_zoomLocations = {}, // identifier -> location\n    d3_behavior_zoomLast = 0,\n    d3_behavior_zoomXyz,\n    d3_behavior_zoomDispatch,\n    d3_behavior_zoomTarget,\n    d3_behavior_zoomArguments,\n    d3_behavior_zoomMoved,\n    d3_behavior_zoomStopClick;\n\nfunction d3_behavior_zoomLocation(point) {\n  return [\n    point[0] - d3_behavior_zoomXyz[0],\n    point[1] - d3_behavior_zoomXyz[1],\n    d3_behavior_zoomXyz[2]\n  ];\n}\n\n// detect the pixels that would be scrolled by this wheel event\nfunction d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta * .005;\n}\n\n// Note: Since we don't rotate, it's possible for the touches to become\n// slightly detached from their original positions. Thus, we recompute the\n// touch points on touchend as well as touchstart!\nfunction d3_behavior_zoomTouchup() {\n  var touches = d3.svg.touches(d3_behavior_zoomTarget),\n      i = -1,\n      n = touches.length,\n      touch;\n  while (++i < n) d3_behavior_zoomLocations[(touch = touches[i]).identifier] = d3_behavior_zoomLocation(touch);\n  return touches;\n}\n\nfunction d3_behavior_zoomTouchmove() {\n  var touches = d3.svg.touches(d3_behavior_zoomTarget);\n  switch (touches.length) {\n\n    // single-touch pan\n    case 1: {\n      var touch = touches[0];\n      d3_behavior_zoomTo(d3_behavior_zoomXyz[2], touch, d3_behavior_zoomLocations[touch.identifier]);\n      break;\n    }\n\n    // double-touch pan + zoom\n    case 2: {\n      var p0 = touches[0],\n          p1 = touches[1],\n          p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2],\n          l0 = d3_behavior_zoomLocations[p0.identifier],\n          l1 = d3_behavior_zoomLocations[p1.identifier],\n          l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2, l0[2]];\n      d3_behavior_zoomTo(Math.log(d3.event.scale) / Math.LN2 + l0[2], p2, l2);\n      break;\n    }\n  }\n}\n\nfunction d3_behavior_zoomMousemove() {\n  d3_behavior_zoomZooming = null;\n  if (d3_behavior_zoomPanning) {\n    d3_behavior_zoomMoved = true;\n    d3_behavior_zoomTo(d3_behavior_zoomXyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomPanning);\n  }\n}\n\nfunction d3_behavior_zoomMouseup() {\n  if (d3_behavior_zoomPanning) {\n    if (d3_behavior_zoomMoved) d3_behavior_zoomStopClick = true;\n    d3_behavior_zoomMousemove();\n    d3_behavior_zoomPanning = null;\n  }\n}\n\nfunction d3_behavior_zoomClick() {\n  if (d3_behavior_zoomStopClick) {\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n    d3_behavior_zoomStopClick = false;\n  }\n}\n\nfunction d3_behavior_zoomTo(z, x0, x1) {\n  var K = Math.pow(2, (d3_behavior_zoomXyz[2] = z) - x1[2]),\n      x = d3_behavior_zoomXyz[0] = x0[0] - K * x1[0],\n      y = d3_behavior_zoomXyz[1] = x0[1] - K * x1[1],\n      o = d3.event, // Events can be reentrant (e.g., focus).\n      k = Math.pow(2, z);\n\n  d3.event = {\n    scale: k,\n    translate: [x, y],\n    transform: function(sx, sy) {\n      if (sx) transform(sx, x);\n      if (sy) transform(sy, y);\n    }\n  };\n\n  function transform(scale, o) {\n    var domain = scale.__domain || (scale.__domain = scale.domain()),\n        range = scale.range().map(function(v) { return (v - o) / k; });\n    scale.domain(domain).domain(range.map(scale.invert));\n  }\n\n  try {\n    d3_behavior_zoomDispatch.apply(d3_behavior_zoomTarget, d3_behavior_zoomArguments);\n  } finally {\n    d3.event = o;\n  }\n\n  o.preventDefault();\n}\n})();\n",
      "raw_url": "https://gist.github.com/raw/3683489/cb224b7032394c72b4b24f10e57298fc227b3a8e/d3.js",
      "language": "JavaScript"
    }
  },
  "updated_at": "2012-09-09T10:14:43Z",
  "url": "https://api.github.com/gists/3683489",
  "id": "3683489"
}
