{
  "forks": [

  ],
  "user": {
    "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
    "login": "GerHobbelt",
    "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
    "url": "https://api.github.com/users/GerHobbelt",
    "id": 402462
  },
  "git_push_url": "git@gist.github.com:3616279.git",
  "history": [
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "905ee79cf730ab15c097c5356516ef8240d7c1f7",
      "change_status": {
        "total": 46,
        "additions": 46,
        "deletions": 0
      },
      "committed_at": "2012-09-09T08:44:37Z",
      "url": "https://api.github.com/gists/3616279/905ee79cf730ab15c097c5356516ef8240d7c1f7"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "a16be381562ef27fdc31c54e5909dbe9c446d268",
      "change_status": {
        "total": 2,
        "additions": 2,
        "deletions": 0
      },
      "committed_at": "2012-09-05T14:25:24Z",
      "url": "https://api.github.com/gists/3616279/a16be381562ef27fdc31c54e5909dbe9c446d268"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "fe27925f2b72b8941466cc39e4b674af330ee631",
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "committed_at": "2012-09-04T06:53:34Z",
      "url": "https://api.github.com/gists/3616279/fe27925f2b72b8941466cc39e4b674af330ee631"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "c62e816abd68e5ff36b343d9611327b74ebca369",
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "committed_at": "2012-09-04T06:50:02Z",
      "url": "https://api.github.com/gists/3616279/c62e816abd68e5ff36b343d9611327b74ebca369"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "8488c2b2f5e22557523676298ce468af8149b50c",
      "change_status": {
        "total": 12,
        "additions": 8,
        "deletions": 4
      },
      "committed_at": "2012-09-04T06:46:36Z",
      "url": "https://api.github.com/gists/3616279/8488c2b2f5e22557523676298ce468af8149b50c"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "fffd7aa6c8e2e4a981f1b6544fe357de7586162d",
      "change_status": {
        "total": 703,
        "additions": 348,
        "deletions": 355
      },
      "committed_at": "2012-09-04T06:40:41Z",
      "url": "https://api.github.com/gists/3616279/fffd7aa6c8e2e4a981f1b6544fe357de7586162d"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "a77f69193a06460f355cae3a18565eb322222ac3",
      "change_status": {
        "total": 155,
        "additions": 123,
        "deletions": 32
      },
      "committed_at": "2012-09-04T04:40:51Z",
      "url": "https://api.github.com/gists/3616279/a77f69193a06460f355cae3a18565eb322222ac3"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "515152648b4ef141b297bc76db3486c6942cd695",
      "change_status": {
        "total": 1373,
        "additions": 1372,
        "deletions": 1
      },
      "committed_at": "2012-09-04T03:51:17Z",
      "url": "https://api.github.com/gists/3616279/515152648b4ef141b297bc76db3486c6942cd695"
    },
    {
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "version": "6c308c4ff2e63fa195df765d8013782f47ded3c3",
      "change_status": {
        "total": 1,
        "additions": 1,
        "deletions": 0
      },
      "committed_at": "2012-09-04T03:37:33Z",
      "url": "https://api.github.com/gists/3616279/6c308c4ff2e63fa195df765d8013782f47ded3c3"
    }
  ],
  "description": "d3.js: force layout with self-referencing links",
  "comments": 0,
  "created_at": "2012-09-04T03:37:33Z",
  "public": true,
  "html_url": "https://gist.github.com/3616279",
  "files": {
    "CREDITS": {
      "type": "text/plain",
      "filename": "CREDITS",
      "raw_url": "https://gist.github.com/raw/3616279/be62eea78c45fef0e8fa951885ec524b0c920410/CREDITS",
      "size": 664,
      "content": "Code derived from the d3.js 'force' example:\n\nThe miserables.json file contains the weighted network of coappearances of\ncharacters in Victor Hugo's novel /Les Miserables/. Nodes represent characters\nas indicated by the labels, and edges connect any pair of characters that\nappear in the same chapter of the book. The values on the edges are the number\nof such coappearances. The data on coappearances were taken from D. E. Knuth,\n\"The Stanford GraphBase: A Platform for Combinatorial Computing\",\nAddison-Wesley, Reading, MA (1993).\n\nThe group labels were transcribed from \"Finding and evaluating community\nstructure in networks\" by M. E. J. Newman and M. Girvan.\n",
      "language": null
    },
    ".gitignore": {
      "type": "text/plain",
      "filename": ".gitignore",
      "raw_url": "https://gist.github.com/raw/3616279/86ddb2374d1fac25691f714c9aa949986b8fecf9/.gitignore",
      "size": 623,
      "content": "*.bak\n*~\n*.exe\n*.o\n*.a\n*.depend\n*.layout\n*.res\n*.user\n*.ncb\n\nmongoose-hg/*\nmongoose-tmp/\ngerhobbelt-github-mongoose/\n\ngerhobbelt-mongoose-issue-360/\nmongoose-issue360/\ngerhobbelt-issue349/\nmongoose-issue349/\n\nbuild/msvc2010/bin/\nbuild/msvc2010/obj/\nbuild/msvc2010/ipch/\n\nbuild/msvc2008/bin/\nbuild/msvc2008/obj/\nbuild/msvc2008/ipch/\n\n*.suo\n*.sdf\n*.opensdf\n\nhtml/contact/images/_vti_cnf\nhtml/contact/_vti_cnf\nhtml/dev/_vti_cnf\nhtml/faking_it/_vti_cnf\nhtml/images/_vti_cnf\nhtml/overview/images/_vti_cnf\nhtml/overview/_vti_cnf\nhtml/styles/_vti_cnf\nhtml/trading/_vti_cnf\nhtml/_vti_cnf\nhtml/_vti_pvt\nhtml/mongoose/_vti_cnf\n\nlog/\n",
      "language": null
    },
    "miserables-with-cycles.json": {
      "type": "application/json",
      "filename": "miserables-with-cycles.json",
      "raw_url": "https://gist.github.com/raw/3616279/c91a8d1202a110db75592f919aa899c624610c72/miserables-with-cycles.json",
      "size": 12446,
      "content": "{\n\"nodes\":[\n{\"name\":\"Myriel\",\"group\":1},\n{\"name\":\"Napoleon\",\"group\":1},\n{\"name\":\"Mlle.Baptistine\",\"group\":1},\n{\"name\":\"Mme.Magloire\",\"group\":1},\n{\"name\":\"CountessdeLo\",\"group\":1},\n{\"name\":\"Geborand\",\"group\":1},\n{\"name\":\"Champtercier\",\"group\":1},\n{\"name\":\"Cravatte\",\"group\":1},\n{\"name\":\"Count\",\"group\":1},\n{\"name\":\"OldMan\",\"group\":1},\n{\"name\":\"Labarre\",\"group\":2},\n{\"name\":\"Valjean\",\"group\":2},\n{\"name\":\"Marguerite\",\"group\":3},\n{\"name\":\"Mme.deR\",\"group\":2},\n{\"name\":\"Isabeau\",\"group\":2},\n{\"name\":\"Gervais\",\"group\":2},\n{\"name\":\"Tholomyes\",\"group\":3},\n{\"name\":\"Listolier\",\"group\":3},\n{\"name\":\"Fameuil\",\"group\":3},\n{\"name\":\"Blacheville\",\"group\":3},\n{\"name\":\"Favourite\",\"group\":3},\n{\"name\":\"Dahlia\",\"group\":3},\n{\"name\":\"Zephine\",\"group\":3},\n{\"name\":\"Fantine\",\"group\":3},\n{\"name\":\"Mme.Thenardier\",\"group\":4},\n{\"name\":\"Thenardier\",\"group\":4},\n{\"name\":\"Cosette\",\"group\":5},\n{\"name\":\"Javert\",\"group\":4},\n{\"name\":\"Fauchelevent\",\"group\":0},\n{\"name\":\"Bamatabois\",\"group\":2},\n{\"name\":\"Perpetue\",\"group\":3},\n{\"name\":\"Simplice\",\"group\":2},\n{\"name\":\"Scaufflaire\",\"group\":2},\n{\"name\":\"Woman1\",\"group\":2},\n{\"name\":\"Judge\",\"group\":2},\n{\"name\":\"Champmathieu\",\"group\":2},\n{\"name\":\"Brevet\",\"group\":2},\n{\"name\":\"Chenildieu\",\"group\":2},\n{\"name\":\"Cochepaille\",\"group\":2},\n{\"name\":\"Pontmercy\",\"group\":4},\n{\"name\":\"Boulatruelle\",\"group\":6},\n{\"name\":\"Eponine\",\"group\":4},\n{\"name\":\"Anzelma\",\"group\":4},\n{\"name\":\"Woman2\",\"group\":5},\n{\"name\":\"MotherInnocent\",\"group\":0},\n{\"name\":\"Gribier\",\"group\":0},\n{\"name\":\"Jondrette\",\"group\":7},\n{\"name\":\"Mme.Burgon\",\"group\":7},\n{\"name\":\"Gavroche\",\"group\":8},\n{\"name\":\"Gillenormand\",\"group\":5},\n{\"name\":\"Magnon\",\"group\":5},\n{\"name\":\"Mlle.Gillenormand\",\"group\":5},\n{\"name\":\"Mme.Pontmercy\",\"group\":5},\n{\"name\":\"Mlle.Vaubois\",\"group\":5},\n{\"name\":\"Lt.Gillenormand\",\"group\":5},\n{\"name\":\"Marius\",\"group\":8},\n{\"name\":\"BaronessT\",\"group\":5},\n{\"name\":\"Mabeuf\",\"group\":8},\n{\"name\":\"Enjolras\",\"group\":8},\n{\"name\":\"Combeferre\",\"group\":8},\n{\"name\":\"Prouvaire\",\"group\":8},\n{\"name\":\"Feuilly\",\"group\":8},\n{\"name\":\"Courfeyrac\",\"group\":8},\n{\"name\":\"Bahorel\",\"group\":8},\n{\"name\":\"Bossuet\",\"group\":8},\n{\"name\":\"Joly\",\"group\":8},\n{\"name\":\"Grantaire\",\"group\":8},\n{\"name\":\"MotherPlutarch\",\"group\":9},\n{\"name\":\"Gueulemer\",\"group\":4},\n{\"name\":\"Babet\",\"group\":4},\n{\"name\":\"Claquesous\",\"group\":4},\n{\"name\":\"Montparnasse\",\"group\":4},\n{\"name\":\"Toussaint\",\"group\":5},\n{\"name\":\"Child1\",\"group\":10},\n{\"name\":\"Child2\",\"group\":10},\n{\"name\":\"Brujon\",\"group\":4},\n{\"name\":\"Mme.Hucheloup\",\"group\":8}\n],\"links\":[\n{\"source\":1,\"target\":0,\"value\":1},\n{\"source\":2,\"target\":0,\"value\":8},\n{\"source\":3,\"target\":0,\"value\":10},\n{\"source\":3,\"target\":2,\"value\":6},\n{\"source\":4,\"target\":0,\"value\":1},\n{\"source\":5,\"target\":0,\"value\":1},\n{\"source\":6,\"target\":0,\"value\":1},\n{\"source\":7,\"target\":0,\"value\":1},\n{\"source\":8,\"target\":0,\"value\":2},\n{\"source\":9,\"target\":0,\"value\":1},\n{\"source\":11,\"target\":10,\"value\":1},\n{\"source\":11,\"target\":3,\"value\":3},\n{\"source\":11,\"target\":2,\"value\":3},\n{\"source\":11,\"target\":0,\"value\":5},\n{\"source\":12,\"target\":11,\"value\":1},\n{\"source\":13,\"target\":11,\"value\":1},\n{\"source\":14,\"target\":11,\"value\":1},\n{\"source\":15,\"target\":11,\"value\":1},\n{\"source\":17,\"target\":16,\"value\":4},\n{\"source\":18,\"target\":16,\"value\":4},\n{\"source\":18,\"target\":17,\"value\":4},\n{\"source\":19,\"target\":16,\"value\":4},\n{\"source\":19,\"target\":17,\"value\":4},\n{\"source\":19,\"target\":18,\"value\":4},\n{\"source\":20,\"target\":16,\"value\":3},\n{\"source\":20,\"target\":17,\"value\":3},\n{\"source\":20,\"target\":18,\"value\":3},\n{\"source\":20,\"target\":19,\"value\":4},\n{\"source\":21,\"target\":16,\"value\":3},\n{\"source\":21,\"target\":17,\"value\":3},\n{\"source\":21,\"target\":18,\"value\":3},\n{\"source\":21,\"target\":19,\"value\":3},\n{\"source\":21,\"target\":20,\"value\":5},\n{\"source\":22,\"target\":16,\"value\":3},\n{\"source\":22,\"target\":17,\"value\":3},\n{\"source\":22,\"target\":18,\"value\":3},\n{\"source\":22,\"target\":19,\"value\":3},\n{\"source\":22,\"target\":20,\"value\":4},\n{\"source\":22,\"target\":21,\"value\":4},\n{\"source\":23,\"target\":16,\"value\":3},\n{\"source\":23,\"target\":17,\"value\":3},\n{\"source\":23,\"target\":18,\"value\":3},\n{\"source\":23,\"target\":19,\"value\":3},\n{\"source\":23,\"target\":20,\"value\":4},\n{\"source\":23,\"target\":21,\"value\":4},\n{\"source\":23,\"target\":22,\"value\":4},\n{\"source\":23,\"target\":12,\"value\":2},\n{\"source\":23,\"target\":11,\"value\":9},\n{\"source\":24,\"target\":23,\"value\":2},\n{\"source\":24,\"target\":11,\"value\":7},\n{\"source\":25,\"target\":24,\"value\":13},\n{\"source\":25,\"target\":23,\"value\":1},\n{\"source\":25,\"target\":11,\"value\":12},\n{\"source\":26,\"target\":24,\"value\":4},\n{\"source\":26,\"target\":11,\"value\":31},\n{\"source\":26,\"target\":16,\"value\":1},\n{\"source\":26,\"target\":25,\"value\":1},\n{\"source\":27,\"target\":11,\"value\":17},\n{\"source\":27,\"target\":23,\"value\":5},\n{\"source\":27,\"target\":25,\"value\":5},\n{\"source\":27,\"target\":24,\"value\":1},\n{\"source\":27,\"target\":26,\"value\":1},\n{\"source\":28,\"target\":11,\"value\":8},\n{\"source\":28,\"target\":27,\"value\":1},\n{\"source\":29,\"target\":23,\"value\":1},\n{\"source\":29,\"target\":27,\"value\":1},\n{\"source\":29,\"target\":11,\"value\":2},\n{\"source\":30,\"target\":23,\"value\":1},\n{\"source\":31,\"target\":30,\"value\":2},\n{\"source\":31,\"target\":11,\"value\":3},\n{\"source\":31,\"target\":23,\"value\":2},\n{\"source\":31,\"target\":27,\"value\":1},\n{\"source\":32,\"target\":11,\"value\":1},\n{\"source\":33,\"target\":11,\"value\":2},\n{\"source\":33,\"target\":27,\"value\":1},\n{\"source\":34,\"target\":11,\"value\":3},\n{\"source\":34,\"target\":29,\"value\":2},\n{\"source\":35,\"target\":11,\"value\":3},\n{\"source\":35,\"target\":34,\"value\":3},\n{\"source\":35,\"target\":29,\"value\":2},\n{\"source\":36,\"target\":34,\"value\":2},\n{\"source\":36,\"target\":35,\"value\":2},\n{\"source\":36,\"target\":11,\"value\":2},\n{\"source\":36,\"target\":29,\"value\":1},\n{\"source\":37,\"target\":34,\"value\":2},\n{\"source\":37,\"target\":35,\"value\":2},\n{\"source\":37,\"target\":36,\"value\":2},\n{\"source\":37,\"target\":11,\"value\":2},\n{\"source\":37,\"target\":29,\"value\":1},\n{\"source\":38,\"target\":34,\"value\":2},\n{\"source\":38,\"target\":35,\"value\":2},\n{\"source\":38,\"target\":36,\"value\":2},\n{\"source\":38,\"target\":37,\"value\":2},\n{\"source\":38,\"target\":11,\"value\":2},\n{\"source\":38,\"target\":29,\"value\":1},\n{\"source\":39,\"target\":25,\"value\":1},\n{\"source\":40,\"target\":25,\"value\":1},\n{\"source\":41,\"target\":24,\"value\":2},\n{\"source\":41,\"target\":25,\"value\":3},\n{\"source\":42,\"target\":41,\"value\":2},\n{\"source\":42,\"target\":25,\"value\":2},\n{\"source\":42,\"target\":24,\"value\":1},\n{\"source\":43,\"target\":11,\"value\":3},\n{\"source\":43,\"target\":26,\"value\":1},\n{\"source\":43,\"target\":27,\"value\":1},\n{\"source\":44,\"target\":28,\"value\":3},\n{\"source\":44,\"target\":11,\"value\":1},\n{\"source\":45,\"target\":28,\"value\":2},\n{\"source\":47,\"target\":46,\"value\":1},\n{\"source\":48,\"target\":47,\"value\":2},\n{\"source\":48,\"target\":25,\"value\":1},\n{\"source\":48,\"target\":27,\"value\":1},\n{\"source\":48,\"target\":11,\"value\":1},\n{\"source\":49,\"target\":26,\"value\":3},\n{\"source\":49,\"target\":11,\"value\":2},\n{\"source\":50,\"target\":49,\"value\":1},\n{\"source\":50,\"target\":24,\"value\":1},\n{\"source\":51,\"target\":49,\"value\":9},\n{\"source\":51,\"target\":26,\"value\":2},\n{\"source\":51,\"target\":11,\"value\":2},\n{\"source\":52,\"target\":51,\"value\":1},\n{\"source\":52,\"target\":39,\"value\":1},\n{\"source\":53,\"target\":51,\"value\":1},\n{\"source\":54,\"target\":51,\"value\":2},\n{\"source\":54,\"target\":49,\"value\":1},\n{\"source\":54,\"target\":26,\"value\":1},\n{\"source\":55,\"target\":51,\"value\":6},\n{\"source\":55,\"target\":49,\"value\":12},\n{\"source\":55,\"target\":39,\"value\":1},\n{\"source\":55,\"target\":54,\"value\":1},\n{\"source\":55,\"target\":26,\"value\":21},\n{\"source\":55,\"target\":11,\"value\":19},\n{\"source\":55,\"target\":16,\"value\":1},\n{\"source\":55,\"target\":25,\"value\":2},\n{\"source\":55,\"target\":41,\"value\":5},\n{\"source\":55,\"target\":48,\"value\":4},\n{\"source\":56,\"target\":49,\"value\":1},\n{\"source\":56,\"target\":55,\"value\":1},\n{\"source\":57,\"target\":55,\"value\":1},\n{\"source\":57,\"target\":41,\"value\":1},\n{\"source\":57,\"target\":48,\"value\":1},\n{\"source\":58,\"target\":55,\"value\":7},\n{\"source\":58,\"target\":48,\"value\":7},\n{\"source\":58,\"target\":27,\"value\":6},\n{\"source\":58,\"target\":57,\"value\":1},\n{\"source\":58,\"target\":11,\"value\":4},\n{\"source\":59,\"target\":58,\"value\":15},\n{\"source\":59,\"target\":55,\"value\":5},\n{\"source\":59,\"target\":48,\"value\":6},\n{\"source\":59,\"target\":57,\"value\":2},\n{\"source\":60,\"target\":48,\"value\":1},\n{\"source\":60,\"target\":58,\"value\":4},\n{\"source\":60,\"target\":59,\"value\":2},\n{\"source\":61,\"target\":48,\"value\":2},\n{\"source\":61,\"target\":58,\"value\":6},\n{\"source\":61,\"target\":60,\"value\":2},\n{\"source\":61,\"target\":59,\"value\":5},\n{\"source\":61,\"target\":57,\"value\":1},\n{\"source\":61,\"target\":55,\"value\":1},\n{\"source\":62,\"target\":55,\"value\":9},\n{\"source\":62,\"target\":58,\"value\":17},\n{\"source\":62,\"target\":59,\"value\":13},\n{\"source\":62,\"target\":48,\"value\":7},\n{\"source\":62,\"target\":57,\"value\":2},\n{\"source\":62,\"target\":41,\"value\":1},\n{\"source\":62,\"target\":61,\"value\":6},\n{\"source\":62,\"target\":60,\"value\":3},\n{\"source\":63,\"target\":59,\"value\":5},\n{\"source\":63,\"target\":48,\"value\":5},\n{\"source\":63,\"target\":62,\"value\":6},\n{\"source\":63,\"target\":57,\"value\":2},\n{\"source\":63,\"target\":58,\"value\":4},\n{\"source\":63,\"target\":61,\"value\":3},\n{\"source\":63,\"target\":60,\"value\":2},\n{\"source\":63,\"target\":55,\"value\":1},\n{\"source\":64,\"target\":55,\"value\":5},\n{\"source\":64,\"target\":62,\"value\":12},\n{\"source\":64,\"target\":48,\"value\":5},\n{\"source\":64,\"target\":63,\"value\":4},\n{\"source\":64,\"target\":58,\"value\":10},\n{\"source\":64,\"target\":61,\"value\":6},\n{\"source\":64,\"target\":60,\"value\":2},\n{\"source\":64,\"target\":59,\"value\":9},\n{\"source\":64,\"target\":57,\"value\":1},\n{\"source\":64,\"target\":11,\"value\":1},\n{\"source\":65,\"target\":63,\"value\":5},\n{\"source\":65,\"target\":64,\"value\":7},\n{\"source\":65,\"target\":48,\"value\":3},\n{\"source\":65,\"target\":62,\"value\":5},\n{\"source\":65,\"target\":58,\"value\":5},\n{\"source\":65,\"target\":61,\"value\":5},\n{\"source\":65,\"target\":60,\"value\":2},\n{\"source\":65,\"target\":59,\"value\":5},\n{\"source\":65,\"target\":57,\"value\":1},\n{\"source\":65,\"target\":55,\"value\":2},\n{\"source\":66,\"target\":64,\"value\":3},\n{\"source\":66,\"target\":58,\"value\":3},\n{\"source\":66,\"target\":59,\"value\":1},\n{\"source\":66,\"target\":62,\"value\":2},\n{\"source\":66,\"target\":65,\"value\":2},\n{\"source\":66,\"target\":48,\"value\":1},\n{\"source\":66,\"target\":63,\"value\":1},\n{\"source\":66,\"target\":61,\"value\":1},\n{\"source\":66,\"target\":60,\"value\":1},\n{\"source\":67,\"target\":57,\"value\":3},\n{\"source\":68,\"target\":25,\"value\":5},\n{\"source\":68,\"target\":11,\"value\":1},\n{\"source\":68,\"target\":24,\"value\":1},\n{\"source\":68,\"target\":27,\"value\":1},\n{\"source\":68,\"target\":48,\"value\":1},\n{\"source\":68,\"target\":41,\"value\":1},\n{\"source\":69,\"target\":25,\"value\":6},\n{\"source\":69,\"target\":68,\"value\":6},\n{\"source\":69,\"target\":11,\"value\":1},\n{\"source\":69,\"target\":24,\"value\":1},\n{\"source\":69,\"target\":27,\"value\":2},\n{\"source\":69,\"target\":48,\"value\":1},\n{\"source\":69,\"target\":41,\"value\":1},\n{\"source\":70,\"target\":25,\"value\":4},\n{\"source\":70,\"target\":69,\"value\":4},\n{\"source\":70,\"target\":68,\"value\":4},\n{\"source\":70,\"target\":11,\"value\":1},\n{\"source\":70,\"target\":24,\"value\":1},\n{\"source\":70,\"target\":27,\"value\":1},\n{\"source\":70,\"target\":41,\"value\":1},\n{\"source\":70,\"target\":58,\"value\":1},\n{\"source\":71,\"target\":27,\"value\":1},\n{\"source\":71,\"target\":69,\"value\":2},\n{\"source\":71,\"target\":68,\"value\":2},\n{\"source\":71,\"target\":70,\"value\":2},\n{\"source\":71,\"target\":11,\"value\":1},\n{\"source\":71,\"target\":48,\"value\":1},\n{\"source\":71,\"target\":41,\"value\":1},\n{\"source\":71,\"target\":25,\"value\":1},\n{\"source\":72,\"target\":26,\"value\":2},\n{\"source\":72,\"target\":27,\"value\":1},\n{\"source\":72,\"target\":11,\"value\":1},\n{\"source\":73,\"target\":48,\"value\":2},\n{\"source\":74,\"target\":48,\"value\":2},\n{\"source\":74,\"target\":73,\"value\":3},\n{\"source\":75,\"target\":69,\"value\":3},\n{\"source\":75,\"target\":68,\"value\":3},\n{\"source\":75,\"target\":25,\"value\":3},\n{\"source\":75,\"target\":48,\"value\":1},\n{\"source\":75,\"target\":41,\"value\":1},\n{\"source\":75,\"target\":70,\"value\":1},\n{\"source\":75,\"target\":71,\"value\":1},\n{\"source\":76,\"target\":64,\"value\":1},\n{\"source\":76,\"target\":65,\"value\":1},\n{\"source\":76,\"target\":66,\"value\":1},\n{\"source\":76,\"target\":63,\"value\":1},\n{\"source\":76,\"target\":62,\"value\":1},\n{\"source\":76,\"target\":48,\"value\":1},\n{\"source\":76,\"target\":58,\"value\":1},\n{\"source\":40,\"target\":40,\"value\":2,\"cyclic\":1},\n{\"source\":40,\"target\":40,\"value\":3,\"cyclic\":1},\n{\"source\":65,\"target\":65,\"value\":1,\"cyclic\":1},\n{\"source\":66,\"target\":66,\"value\":1,\"cyclic\":1},\n{\"source\":67,\"target\":67,\"value\":1,\"cyclic\":1},\n{\"source\":68,\"target\":68,\"value\":1,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":2,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":3,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":1,\"cyclic\":1},\n{\"source\":73,\"target\":73,\"value\":3,\"cyclic\":1},\n{\"source\":74,\"target\":74,\"value\":1,\"cyclic\":1},\n{\"source\":47,\"target\":47,\"value\":2,\"cyclic\":1}\n]\n}",
      "language": "JSON"
    },
    "index.html": {
      "type": "text/html",
      "filename": "index.html",
      "raw_url": "https://gist.github.com/raw/3616279/92b6545cde68ff9f4845ddf99a3f2564ba12e65c/index.html",
      "size": 36175,
      "content": "<!DOCTYPE html>\n<html>\n  <head>\n    <title>Clustered Network</title>\n    <script src=\"http://d3js.org/d3.v2.js\"></script>\n    <link href='http://fonts.googleapis.com/css?family=Gudea:700,400italic,400' rel='stylesheet' type='text/css'>\n    <style type=\"text/css\">\nsvg {\n  border: 1px solid #ccc;\n}\nbody {\n  font: 10px 'Gudea', sans-serif;\n}\ntext {\n  font-family: 'Gudea', sans-serif;\n  font-size: 9pt;\n}\ncircle.node {\n  fill: lightsteelblue;\n  stroke: #555;\n  stroke-width: 3px;\n}\ncircle.leaf {\n  stroke: #fff;\n  stroke-width: 1.5px;\n}\ncircle.link-expanded {\n  stroke: #555;\n  stroke-width: 3px;\n  stroke-dasharray: 2px 4px;\n}\ncircle.helper {\n  stroke-width: 0;\n  fill: #333;\n  opacity: 0.6;\n}\ncircle.center-of-mass {\n  fill: white;\n  stroke: red;\n  stroke-width: 5px;\n}\npath.hull {\n  fill: lightsteelblue;\n  fill-opacity: 0.3;\n}\npath.hlink {\n  stroke: #333;\n  stroke-opacity: 0.5;\n  fill: none;\n  pointer-events: none;\n}\npath.trace-alpha {\n  stroke: #0ee;\n  stroke-opacity: 0.8;\n  stroke-width: 1.5px;\n  fill: none;\n  pointer-events: none;\n}\npath.trace-c2 {\n  stroke: #3bb;\n  stroke-opacity: 0.8;\n  stroke-width: 1.5px;\n  fill: none;\n  pointer-events: none;\n}\nline.link {\n  stroke: red;\n  stroke-opacity: 0.7;\n  pointer-events: none;\n}\n    </style>\n  </head>\n  <body>\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"controls\" visibility=\"hidden\">\n  <g visibility=\"visible\">\n    <rect x=\"0\" y=\"0.55\" opacity=\"0.6\" fill=\"#FFFFFF\" stroke=\"#231F20\" stroke-miterlimit=\"10\" width=\"192\" height=\"22\"/>\n    <text transform=\"matrix(1 0 0 1 4.5066 15.343)\"  >Debug level:</text>\n    <g id=\"slider-debug-level\">\n      <line id=\"slider-x-debug-level\" fill=\"none\" stroke=\"#939598\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" x1=\"73.5\" y1=\"11.05\" x2=\"160.5\" y2=\"11.05\"/>\n      <rect id=\"sliderpos-debug-level\" x=\"77\" y=\"3.55\" fill=\"#58595B\" stroke=\"#231F20\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" width=\"4\" height=\"15\"/>\n            <text id=\"sliderval-debug-level\" transform=\"matrix(1 0 0 1 164.6638 15.343)\"  >?????</text>\n    </g>\n  </g>\n</svg>\n\n<script type=\"text/javascript\" src=\"http://gerhobbelt.github.com/bl.ocks.org-hack/fixit.js\" ></script>\n\n    <script type=\"text/javascript\">\nvar width = 960,        // svg width\n    height = 500,       // svg height\n    dr = 4,             // default point radius\n    off = 15,           // cluster hull offset\n\t\tcycle_curvep = 0.5, // cyclic ~ self-referential links: determines the 'radius' of the bezier path constructed for the link\n    expand = {},        // expanded clusters\n    data, net, force1, force2, hullg, hull, linkg, helper_linkg, link, hlink, nodeg, helper_nodeg, node, hnode,\n    debug = 3,          // 0: disable, 1: all, 2: only force2 + curves, 3: curves only\n    alpha_trace = [], alpha_line, alpha_scale, debug_g,\n    c2_trace = [], c2_line, c2_scale, debug_g;\n\n\t\t//for (var gn = 0; gn < 20; gn++) expand[gn] = 2;\n\t\t\nalpha_line = d3.svg.line()\n  .x(function(d, i) {\n    return i + 10;\n  })\n  .y(function(d, i) {\n    return d;\n  });\n\nalpha_scale = d3.scale.pow().exponent(-1.0).domain([5,.005]).range([10, height - 10]).clamp(true);\n\nc2_scale = d3.scale.log().domain([0.01, width * height]).range([10, height - 10]).clamp(true);\n\nc2_line = d3.svg.line()\n  .x(function(d, i) {\n    return i + 10;\n  })\n  .y(function(d, i) {\n    return d;\n  });\n\nvar curve = d3.svg.line()\n  .interpolate(\"cardinal-closed\")\n  .tension(.85);\n\nvar fill = d3.scale.category20();\n\nfunction noop() { return false; }\n\nfunction nodeid(n) {\n  return n.size > 0 ? \"_g_\" + n.group + \"_\" + n.expansion : n.name;\n}\n\nfunction linkid(l) {\n  var u = nodeid(l.source),\n      v = nodeid(l.target);\n  return u<v ? u+\"|\"+v : v+\"|\"+u;\n}\n\nfunction getGroup(n) { return n.group; }\n\nfunction cycleState(d) {\n  var g = d.group, s = expand[g] || 0;\n  // it's no use 'expanding the intergroup links only' for nodes which only have 1 outside link for real:\n  if (d.ig_link_count < 2)\n    s = (s ? 0 : 2);\n  else {\n    s++; s %= 3;\n  }\n  return expand[g] = s;\n}\n\n// constructs the network to visualize\nfunction network(data, prev) {\n  expand = expand || {};\n  var gm = {},    // group map\n      nm = {},    // node map\n      nml = {},   // node map for left-side 'link path helper nodes'\n      nmr = {},   // node map for right-side 'link path helper nodes'\n      nmc = {},   // node map for cyclic ~ self-referencing 'link path helper nodes'\n      nmimg = {}, // node map for cloned nodes for force2\n      lm = {},    // link maps - lm ~ lml-lmm-lmr\n      lml = {},\n      lmm = {},\n      lmr = {},\n      lmc = {},\n      gn = {},                  // previous group nodes\n      gc = {},                  // previous group centroids\n      nodes = [],               // output nodes\n      links = [],               // output links\n      helper_nodes = [],        // helper force graph nodes\n      helper_links = [];        // helper force graph links\n      helper_render_links = []; // helper force graph links\n  var k;\n\n  // process previous nodes for reuse or centroid calculation\n  if (prev) {\n    prev.nodes.forEach(function(n) {\n      var i = getGroup(n), o;\n      if (n.size > 0) {\n        gn[i] = n;\n        n.size = 0;\n        n.ig_link_count = 0;\n        n.link_count = 0;\n        n.first_link = null;\n        n.first_link_target = null;\n      } else {\n        o = gc[i] || (gc[i] = {x:0,y:0,count:0});\n        o.x += n.x;\n        o.y += n.y;\n        o.count += 1; // we count regular nodes here, so .count is a measure for the number of nodes in the group\n      }\n    });\n  }\n\n  // determine nodes\n  for (k=0; k<data.nodes.length; ++k) {\n    var n = data.nodes[k],\n        i = getGroup(n),\n        expansion = expand[i] || 0,\n        l = gm[i] || (gm[i]=gn[i]) || (gm[i]={group:i, size:0, nodes:[], ig_link_count:0, link_count:0, expansion: expansion}),\n        img;\n\n    // we need to create a NEW object when expansion changes from 0->1 for a group node\n    // in order to break the references from the d3 selections, so that the next time\n    // this group node will indeed land in the 'enter()' set\n    if (l.expansion != expansion) {\n      l = gn[i] = gm[i] = {group:l.group, x:l.x, y: l.y, size:l.size, nodes:l.nodes, ig_link_count:l.ig_link_count, link_count:l.link_count, expansion: expansion};\n    }\n\n    if (expansion == 2) {\n      // the node should be directly visible\n      nm[nodeid(n)] = n;\n      img = {ref: n, x: n.x, y: n.y, size: n.size || 0, fixed: 1, id: nodeid(n)};\n      nmimg[nodeid(n)] = img;\n      nodes.push(n);\n      helper_nodes.push(img);\n      if (gn[i]) {\n        // place new nodes at cluster location (plus jitter)\n        n.x = gn[i].x + Math.random();\n        n.y = gn[i].y + Math.random();\n      }\n    } else {\n      // the node is part of a collapsed cluster\n      if (l.size == 0) {\n        // if new cluster, add to set and position at centroid of leaf nodes\n        nm[nodeid(n)] = l;\n        l.size = 1;                     // hack to make nodeid() work correctly for the new group node\n        nm[nodeid(l)] = l;\n        img = {ref: l, x: l.x, y: l.y, size: l.size || 0, fixed: 1, id: nodeid(l)};\n        nmimg[nodeid(l)] = img;\n        l.size = 0;                     // undo hack\n        nmimg[nodeid(n)] = img;\n        nodes.push(l);\n        helper_nodes.push(img);\n        if (gc[i]) {\n          l.x = gc[i].x / gc[i].count;\n          l.y = gc[i].y / gc[i].count;\n        }\n      } else {\n        // have element node point to group node:\n        nm[nodeid(n)] = l; // l = shortcut for: nm[nodeid(l)];\n        nmimg[nodeid(n)] = nmimg[nodeid(l)];\n      }\n      l.nodes.push(n);\n    }\n    // always count group size as we also use it to tweak the force graph strengths/distances\n    l.size += 1;\n    n.group_data = l;\n    n.link_count = 0;\n    n.first_link = null;\n    n.first_link_target = null;\n  }\n\n  // determine links\n  for (k=0; k<data.links.length; ++k) {\n    var e = data.links[k],\n        u = getGroup(e.source),\n        v = getGroup(e.target),\n        rui, rvi, ui, vi, lu, rv, ustate, vstate, uimg, vimg,\n        i, ix,\n        l, ll, l_, lr;\n    if (u != v) {\n      gm[u].ig_link_count++;\n      gm[v].ig_link_count++;\n    }\n    ustate = expand[u] || 0;\n    vstate = expand[v] || 0;\n    // while d3.layout.force does convert link.source and link.target NUMERIC values to direct node references,\n    // it doesn't for other attributes, such as .real_source, so we do not use indexes in nm[] but direct node\n    // references to skip the d3.layout.force implicit links conversion later on and ensure that both .source/.target\n    // and .real_source/.real_target are of the same type and pointing at valid nodes.\n    rui = nodeid(e.source);\n    rvi = nodeid(e.target);\n    u = nm[rui];\n    v = nm[rvi];\n    if (u == v) {\n      // skip non-original links from node to same (A-A); they are rendered as 0-length lines anyhow. Less links in array = faster animation.\n\t\t\tif (ustate < 2)\n\t\t\t  continue;\n\t\t\t\n\t\t\t// self-referential 'links' are produced as 2 links+1 helper node; this is a generalized approach so we\n\t\t\t// can support multiple self-referential links as thanks to the force layout\n\t\t\t// those helpers will all be in different places, hence the link 'path' for each\n\t\t\t// parallel link will be different.\n\t\t\tui = nodeid(u);\n\t\t\ti = ui+\"|\"+ui+\"|\"+k;\n\t\t\tl = lm[i] || (lm[i] = {source:u, target:u, size:0, distance: 0});\n\t\t\tl.cyclic = true;\n\t\t\tix = i;\n\t\t\t// link(u,v) ==> u -> lu -> u\n\t\t\tlu = nmc[ix] || (nmc[ix] = data.helpers.cyclic[ix] || (data.helpers.cyclic[ix] = {ref: u, id: \"_ch_\" + ix, size: -1, link_ref: l, cyclic_helper: true}));\n\t\t\tuimg = nmimg[ui];\n\t\t\tl_ = lmc[ix] || (lmc[ix] = {g_ref: l, ref: e, id: \"c\"+ix, source:uimg, target: lu, real_source:u, size: 0, distance: 0, cyclic: true});\n\t\t\tl.size += 1;\n\t\t\tl_.size += 1;\n      continue;\n    }\n    // 'links' are produced as 3 links+2 helper nodes; this is a generalized approach so we\n    // can support multiple links between element nodes and/or groups, always, as each\n    // 'original link' gets its own set of 2 helper nodes and thanks to the force layout\n    // those helpers will all be in different places, hence the link 'path' for each\n    // parallel link will be different.\n    ui = nodeid(u);\n    vi = nodeid(v);\n    i = (ui < vi ? ui+\"|\"+vi : vi+\"|\"+ui);\n    l = lm[i] || (lm[i] = {source:u, target:v, size:0, distance: 0});\n    if (ustate == 1) {\n      ui = rui;\n    }\n    if (vstate == 1) {\n      vi = rvi;\n    }\n    ix = (ui < vi ? ui+\"|\"+vi+\"|\"+ustate+\"|\"+vstate : vi+\"|\"+ui+\"|\"+vstate+\"|\"+ustate);\n    ix = (ui < vi ? ui+\"|\"+vi : vi+\"|\"+ui);\n    // link(u,v) ==> u -> lu -> rv -> v\n    lu = nml[ix] || (nml[ix] = data.helpers.left[ix]  || (data.helpers.left[ix]  = {ref: u, id: \"_lh_\" + ix, size: -1, link_ref: l}));\n    rv = nmr[ix] || (nmr[ix] = data.helpers.right[ix] || (data.helpers.right[ix] = {ref: v, id: \"_rh_\" + ix, size: -1, link_ref: l}));\n    uimg = nmimg[ui];\n    vimg = nmimg[vi];\n    ll = lml[ix] || (lml[ix] = {g_ref: l, ref: e, id: \"l\"+ix, source:uimg, target:  lu, real_source:u, real_target:v, size:0, distance: 0, left_seg  : true});\n    l_ = lmm[ix] || (lmm[ix] = {g_ref: l, ref: e, id: \"m\"+ix, source:  lu, target:  rv, real_source:u, real_target:v, size:0, distance: 0, middle_seg: true});\n    lr = lmr[ix] || (lmr[ix] = {g_ref: l, ref: e, id: \"r\"+ix, source:  rv, target:vimg, real_source:u, real_target:v, size:0, distance: 0, right_seg : true});\n    l.size += 1;\n    ll.size += 1;\n    l_.size += 1;\n    lr.size += 1;\n\n    // these are only useful for single-linked nodes, but we don't care; here we have everything we need at minimum cost.\n    if (l.size == 1) {\n      u.link_count++;\n      v.link_count++;\n      u.first_link = l;\n      v.first_link = l;\n      u.first_link_target = v;\n      v.first_link_target = u;\n    }\n  }\n\n  for (k in lm) { links.push(lm[k]); }\n  for (k in lml) { helper_links.push(lml[k]); }\n  for (k in lmm) { helper_links.push(lmm[k]); helper_render_links.push(lmm[k]); }\n  for (k in lmr) { helper_links.push(lmr[k]); }\n  for (k in lmc) { helper_links.push(lmc[k]); helper_render_links.push(lmc[k]); }\n  for (k in nml) { helper_nodes.push(nml[k]); }\n  for (k in nmr) { helper_nodes.push(nmr[k]); }\n  for (k in nmc) { helper_nodes.push(nmc[k]); }\n  //for (k in nmc) { nodes.push(nmc[k]); }\n\n  return {nodes: nodes, links: links, helper_nodes: helper_nodes, helper_links: helper_links, helper_render_links: helper_render_links};\n}\n\nfunction convexHulls(nodes, offset) {\n  var hulls = {};\n\n  // create point sets\n  for (var k=0; k<nodes.length; ++k) {\n    var n = nodes[k];\n    if (n.size) continue;\n    var i = getGroup(n),\n        l = hulls[i] || (hulls[i] = []);\n    l.push([n.x - offset, n.y - offset]);\n    l.push([n.x - offset, n.y + offset]);\n    l.push([n.x + offset, n.y - offset]);\n    l.push([n.x + offset, n.y + offset]);\n  }\n\n  // create convex hulls\n  var hullset = [];\n  for (i in hulls) {\n    hullset.push({group: i, path: d3.geom.hull(hulls[i])});\n  }\n\n  return hullset;\n}\n\nfunction drawCluster(d) {\n  return curve(d.path); // 0.8\n}\n\n// these functions call init(); by declaring them here,\n// they don't have the old init() as a closure any more.\n// This should save us some memory and cycles when using\n// this in a long-running setting.\n\nfunction on_hull_click(d) {\n  if (debug == 1) console.log(\"node click\", d, arguments, this, expand[d.group]);\n  // clicking on 'path helper nodes' shouln't expand/collapse the group node:\n  if (d.size < 0)\n    return;\n  cycleState(d);\n  init();\n}\n\nfunction on_node_click(d) {\n  if (debug == 1) console.log(\"node click\", d, arguments, this, expand[d.group]);\n  // clicking on 'path helper nodes' shouln't expand/collapse the group node:\n  if (d.size < 0)\n    return;\n  cycleState(d);\n  init();\n}\n\n// --------------------------------------------------------\n\nvar vis = d3.select(\"svg\")\n  .attr(\"width\", width)\n  .attr(\"height\", height);\n\nvar debug_ui = vis.select(\"#slider-debug-level\");\ndebug_ui.select(\"#sliderval-debug-level\").text(debug);\nvar dbg = debug_ui.select(\"#slider-x-debug-level\");\nx1 = +dbg.attr(\"x1\");\nx2 = +dbg.attr(\"x2\");\nvar debug_ui_scale = d3.scale.linear().domain([0,3]).range([+dbg.attr(\"x1\")+3.5, +dbg.attr(\"x2\")-3.5-4]).clamp(true);\n\n// as per http://bl.ocks.org/1557377; correction for latest d3 lib: origin(Object) doesn't cut it.\nvar slider_drag = d3.behavior.drag()\n/*\n        .origin(function(d, i) {\n            // must return {x: value, y: value} object\n            var owner = this.ownerSVGElement;\n            var rect = owner.getBoundingClientRect();\n            // (window.scrollX || window.scrollY) ?\n            //return {x: rect.left - this.clientLeft, y: rect.top - this.clientTop};\n            return {x: rect.left, y: rect.top};\n        })\n*/\n  .on(\"drag\", slider_dragmove);\n\ndebug_ui.select(\"#sliderpos-debug-level\")\n  .attr(\"x\", debug_ui_scale(debug))\n  .call(slider_drag);\n\nfunction slider_dragmove(d) {\n  if (!isFinite(d3.event.x))\n    return;\n  var dv = debug_ui_scale.invert(d3.event.x);\n  dv = Math.round(dv);\n  d3.select(this)\n    .attr(\"x\", debug_ui_scale(dv));\n  debug_ui.select(\"#sliderval-debug-level\").text(dv);\n  if (dv != debug) {\n    debug = dv;\n\n    helper_nodeg\n      .selectAll(\"*\")\n        .remove();\n    linkg\n      .selectAll(\"*\")\n        .remove();\n    vis.select(\"#center-of-mass\")\n      .attr(\"display\", (debug == 1) ? null : \"none\");\n    debug_g\n      .attr(\"display\", debug ? null : \"none\");\n\n    init();\n  }\n}\n\ndebug_g = vis.append(\"g\");\ndebug_g\n  .append(\"path\")\n  .attr(\"class\", \"trace-alpha\");\ndebug_g\n  .append(\"path\")\n  .attr(\"class\", \"trace-c2\");\n\nvar pathgen = d3.svg.line().interpolate(\"basis\");\nvar cycle_pathgen = d3.svg.line().interpolate(\"basis\");\n\nd3.json(\"miserables-with-cycles.json\", function(json) {\n  /*\n  JSON layout:\n\n  {\n    \"nodes\": [\n      {\n        \"name\"  : \"bla\",    // in this code, this is expected to be a globally unique string (as it's used for the id via nodeid())\n        \"group\" : 1         // group ID (number)\n      },\n      ...\n    ],\n    \"links\": [\n      {\n        \"source\" : 1,       // nodes[] index (number; is immediately converted to direct nodes[index] reference)\n        \"target\" : 0,       // nodes[] index (number; is immediately converted to direct nodes[index] reference)\n        \"value\"  : 1        // [not used in this force layout]\n      },\n      ...\n    ]\n  }\n  */\n  data = json;\n  for (var i=0; i<data.links.length; ++i) {\n    o = data.links[i];\n    o.source = data.nodes[o.source];\n    o.target = data.nodes[o.target];\n  }\n  // prepare data struct to also carry our 'path helper nodes':\n  data.helpers = {left: {}, right: {}, cyclic: {}};\n\n  hullg = vis.append(\"g\");\n  //if (debug && debug < 3) {\n    linkg = vis.append(\"g\");\n    helper_nodeg = vis.append(\"g\");\n  //}\n  helper_linkg = vis.append(\"g\");\n  nodeg = vis.append(\"g\");\n  //if (debug == 1) {\n    node = vis.append(\"g\")\n        .attr(\"id\", \"center-of-mass\")\n      .append(\"circle\")\n        .attr(\"class\", \"center-of-mass\")\n        .attr(\"visibility\", (debug == 1) ? \"visible\" : \"hidden\")\n        .attr(\"r\", 10);\n  //}\n\n  init();\n\n  vis.attr(\"opacity\", 1e-6)\n    .transition()\n    .duration(1000)\n    .attr(\"opacity\", 1);\n});\n\nfunction init() {\n  if (force1) force1.stop();\n\n  net = network(data, net);\n\n  force1 = d3.layout.force()\n      .nodes(net.nodes)\n      .links(net.links)\n      .size([width, height])\n      .linkDistance(function(l, i) {\n        //return 300;\n        var n1 = l.source, n2 = l.target,\n            g1 = n1.group_data || n1, g2 = n2.group_data || n2,\n            n1_is_group = n1.size || 0, n2_is_group = n2.size || 0,\n            rv = 300;\n        // larger distance for bigger groups:\n        // both between single nodes and _other_ groups (where size of own node group still counts),\n        // and between two group nodes.\n        //\n        // reduce distance for groups with very few outer links,\n        // again both in expanded and grouped form, i.e. between individual nodes of a group and\n        // nodes of another group or other group node or between two group nodes.\n        //\n        // The latter was done to keep the single-link groups close.\n        if (n1.group == n2.group) {\n          if ((n1.link_count < 2 && !n1_is_group) || (n2.link_count < 2 && !n2_is_group)) {\n            // 'real node' singles: these don't need a big distance to make the distance, if you whumsayin' ;-)\n            rv = 2;\n          } else if (!n1_is_group && !n2_is_group) {\n            rv = 2;\n          } else if (g1.link_count < 4 || g2.link_count < 4) {\n            rv = 100;\n          }\n        } else {\n          if (!n1_is_group && !n2_is_group) {\n            rv = 50;\n          } else if ((n1_is_group && n2_is_group) && (g1.link_count < 4 || g2.link_count < 4)) {\n            // 'real node' singles: these don't need a big distance to make the ditance, if you whumsayin' ;-)\n            rv = 100;\n          } else if ((n1_is_group && g1.link_count < 2) || (n2_is_group && g2.link_count < 2)) {\n            // 'real node' singles: these don't need a big distance to make the ditance, if you whumsayin' ;-)\n            rv = 30;\n          } else if (!n1_is_group || !n2_is_group) {\n            rv = 100;\n          }\n        }\n        return l.distance = rv;\n      })\n      .gravity(1.0)             // gravity+charge tweaked to ensure good 'grouped' view (e.g. green group not smack between blue&orange, ...\n      .charge(function(d, i) {  // ... charge is important to turn single-linked groups to the outside\n        if (d.size > 0) {\n          return -5000;  // group node\n        } else {\n          // 'regular node'\n          return -1000;\n        }\n      })\n      .friction(0.7)   // friction adjusted to get dampened display: less bouncy bouncy ball [Swedish Chef, anyone?]\n      .on(\"end\", function() {\n        // done\n      })\n      .on(\"start\", function() {\n        // zip nada\n      })\n      .start();\n\n  /*\n  And here's the crazy idea for allowing AND rendering multiple links between 2 nodes, etc., as the initial attempt\n  to include the 'helper' nodes in the basic 'force' failed dramatically from a visual PoV: we 'overlay' the basic\n  nodes+links force with a SECOND force layout which 'augments' the original force layout by having it 'layout' all\n  the helper nodes (with their links) between the 'fixed' REAL nodes, which are laid out by the original force.\n\n  This way, we also have the freedom to apply a completely different force field setup to the helpers (no gravity\n  as it doesn't make sense for helpers, different charge values, etc.).\n  */\n  force2 = d3.layout.force()\n      .nodes(net.helper_nodes)\n      .links(net.helper_links)\n      .size([width, height])\n      .linkDistance(function(l, i) {\n        var n1 = l.real_source, n2 = l.real_target, rv,\n            lr = l.g_ref,\n            n1r, n2r,\n            dx, dy;\n\t\t\t\tif (l.cyclic)\n\t\t\t\t  return 15;\n        if (lr.source.size > 0 || lr.target.size > 0)\n          return 20;\n        return 1;\n      })\n      .gravity(0.0)   // just a tad of gravidy to help keep those curvy buttocks decent\n      .charge(function(d, i) {\n        // helper nodes have a medium-to-high charge, depending on the number of links the related force link represents.\n        // Hence bundles of links fro A->B will have helper nodes with huge charges: better spreading of the link paths.\n        //\n        // Unless we're looking at helpers for links between 'real nodes', NOT GROUPS: in that case we want to keep\n        // the lines are straight as posssible as there would only be one relation for A->B anyway, so we lower the charge\n        // for such nodes and helpers.\n        if (d.fixed)\n          return -10;\n        var l = d.link_ref,\n            c = l.link_count || 1;\n        if (l.source.size > 0 || l.target.size > 0)\n          return -30;\n        return -1;\n      })\n      .friction(0.95)\n      .start()\n      .stop();          // and immediately stop! force.tick will drive this one every tick!\n\n  hullg.selectAll(\"path.hull\").remove();\n  hull = hullg.selectAll(\"path.hull\")\n      .data(convexHulls(net.nodes, off))\n      .enter().append(\"path\")\n        .attr(\"class\", \"hull\")\n        .attr(\"d\", drawCluster)\n        .style(\"fill\", function(d) { return fill(d.group); })\n        .on(\"click\", on_hull_click);\n\n  if (debug == 1) {\n    link = linkg.selectAll(\"line.link\").data(net.links, linkid);\n    link.exit().remove();\n    link.enter().append(\"line\")\n        .attr(\"class\", \"link\")\n        .attr(\"x1\", function(d) { return d.source.x; })\n        .attr(\"y1\", function(d) { return d.source.y; })\n        .attr(\"x2\", function(d) { return d.target.x; })\n        .attr(\"y2\", function(d) { return d.target.y; });\n    // both existing and enter()ed links may have changed stroke width due to expand state change somewhere:\n    link.style(\"stroke-width\", function(d) { return d.size || 1; });\n  }\n\n  hlink = helper_linkg.selectAll(\"path.hlink\").data(net.helper_render_links, function(d) {\n    return d.id;\n  });\n  hlink.exit().remove();\n  hlink.enter().append(\"path\")\n      .attr(\"class\", \"hlink\");\n  // both existing and enter()ed links may have changed stroke width due to expand state change somewhere:\n  hlink.style(\"stroke-width\", function(d) { return d.size || 1; });\n\n\n  if (debug && debug < 3) {\n    hnode = helper_nodeg.selectAll(\"circle.node\").data(net.helper_nodes, function(d) {\n      return d.id;\n    });\n    hnode.exit().remove();\n    hnode.enter().append(\"circle\")\n        // if (d.size) -- d.size > 0 when d is a group node.\n        // d.size < 0 when d is a 'path helper node'.\n        .attr(\"class\", function(d) {\n          return \"node\" + (d.size > 0 ? \"\" : d.size < 0 ? \" helper\" : \" leaf\");\n        })\n        .attr(\"r\", function(d) {\n          return d.size > 0 ? d.size + dr : d.size < 0 ? 2 : dr + 1;\n        })\n        .attr(\"cx\", function(d) { return d.x; })\n        .attr(\"cy\", function(d) { return d.y; })\n        .style(\"fill\", function(d) { return fill(d.group); });\n  }\n\n  node = nodeg.selectAll(\"circle.node\").data(net.nodes, nodeid);\n  node.exit().remove();\n  node.enter().append(\"circle\")\n      // if (d.size) -- d.size > 0 when d is a group node.\n      // d.size < 0 when d is a 'path helper node'.\n      .attr(\"class\", function(d) {\n        return \"node\" + (d.size > 0 ? d.expansion ? \" link-expanded\" : \"\" : \" leaf\");\n      })\n      .attr(\"r\", function(d) {\n        return d.size > 0 ? d.size + dr : dr + 1;\n      })\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; })\n      .style(\"fill\", function(d) { return fill(d.group); })\n      .on(\"click\", on_node_click);\n\n  node.call(force1.drag);\n\n  var drag_in_progress = false;\n  var change_squared = width * height;\n\n  // CPU load redux for the fix, part 3: jumpstart the annealing process again when the user moves the mouse outside the node,\n  // when we believe the drag is still going on; even when it isn't anymore, but D3 doesn't inform us about that!\n  node\n    .on(\"mouseout.ger_fix\", function(d) {\n      if (debug == 1) console.log(\"mouseout.ger_fix\", this, arguments, d.fixed, drag_in_progress);\n      if (drag_in_progress) {\n        force1.resume();\n      }\n    });\n\n  var resume_threshold = 0.05;\n\n  force1.on(\"tick\", function(e) {\n    if (debug) {\n      alpha_trace.push(alpha_scale(e.alpha));\n      if (alpha_trace.length > width - 20)\n        alpha_trace.shift();\n      debug_g.select(\"path.trace-alpha\")\n          .attr(\"d\", alpha_line(alpha_trace));\n\n      c2_trace.push(c2_scale(change_squared));\n      if (c2_trace.length > width - 20)\n        c2_trace.shift();\n      debug_g.select(\"path.trace-c2\")\n          .attr(\"d\", c2_line(c2_trace));\n    }\n\n    /*\n    Force all nodes with only one link to point outwards.\n\n    To do this, we first calculate the center mass (okay, we wing it, we fake node 'weight'),\n    then see whether the target node for links from single-link nodes is closer to the\n    center-of-mass than us, and if it isn't, we push the node outwards.\n    */\n    var center = {x: 0, y: 0, weight: 0}, singles = [], centroids = {},\n        size, c, k, mx, my, dx, dy, alpha;\n\n    drag_in_progress = false;\n    net.nodes.forEach(function(n) {\n      var w = Math.max(1, n.size || 0, n.weight || 0),\n          i = getGroup(n),\n          gc = centroids[i] || (centroids[i] = { x:0, y:0, weight: 0});\n\n      center.x += w * n.x;\n      center.y += w * n.y;\n      center.weight += w;\n\n      gc.x += w * n.x;\n      gc.y += w * n.y;\n      gc.weight += w;\n\n      if (n.fixed & 2) {\n        drag_in_progress = true;\n      }\n\n      if (n.size > 0 ? n.link_count < 4 : n.group_data.link_count < 3)\n        singles.push(n);\n    });\n\n    size = force1.size();\n\n    mx = size[0] / 2;\n    my = size[1] / 2;\n\n    for (k in centroids) {\n      var gc = centroids[k];\n      gc.x /= gc.weight;\n      gc.y /= gc.weight;\n    }\n\n    singles.forEach(function(n) {\n      var l = n.first_link, n2 = n.first_link_target,\n          proj, ax, bx, ay, by, k, x, y, alpha, rej, power,\n          dx, dy,\n          n_is_group = n.size || 0,\n          ng = n.group_data || n,\n          c2,\n          w = Math.max(1, n.size || 0, n.weight || 0),\n          i = getGroup(n),\n          gc = centroids[i];\n\n      // haven't decided what to do for unconnected nodes, yet...\n      if (!l)\n        return;\n\n      // apply amplification of the 'original' alpha:\n      // 1.0 for singles and double-connected nodes, close to 0 for highly connected nodes, rapidly decreasing.\n      // Use this as we want to give those 'non-singles' a little bit of the same 'push out' treatment.\n      // Reduce effect for 'real nodes' which are singles: they need much less encouragement!\n      power = Math.max(2, n_is_group ? n.link_count : n.group_data.link_count);\n      power = 2 / power;\n\n      alpha = e.alpha * power;\n\n      // undo/revert gravity forces (or as near as we can get, here)\n      //\n      // revert for truely single nodes, revert just a wee little bit for dual linked nodes,\n      // only reduce ever so slighty for nodes with few links (~ 3) that made it into this\n      // 'singles' selection\n      if (k = alpha * force1.gravity() * (0.8 + power)) {\n        dx = (mx - n.x) * k;\n        dy = (my - n.y) * k;\n        n.x -= dx;\n        n.y -= dy;\n\n        center.x -= dx * w;\n        center.y -= dy * w;\n        gc.x -= dx * w;\n        gc.y -= dy * w;\n      }\n    });\n\n    // move the entire graph so that its center of mass sits at the center, period.\n    center.x /= center.weight;\n    center.y /= center.weight;\n\n    if (debug == 1) {\n      c = vis.selectAll(\"circle.center-of-mass\")\n          .attr(\"cx\", center.x)\n          .attr(\"cy\", center.y);\n    }\n\n    dx = mx - center.x;\n    dy = my - center.y;\n\n    alpha = e.alpha * 5;\n    dx *= alpha;\n    dy *= alpha;\n\n    net.nodes.forEach(function(n) {\n      n.x += dx;\n      n.y += dy;\n    });\n\n\n    change_squared = 0;\n\n    // fixup .px/.py so drag behaviour and annealing get the correct values, as\n    // force.tick() would expect .px and .py to be the .x and .y of yesterday.\n    net.nodes.forEach(function(n) {\n      // restrain all nodes to window area\n      var k, dx, dy,\n          r = (n.size > 0 ? n.size + dr : dr + 1) + 2 /* styled border outer thickness and a bit */;\n\n      dx = 0;\n      if (n.x < r)\n        dx = r - n.x;\n      else if (n.x > size[0] - r)\n        dx = size[0] - r - n.x;\n\n      dy = 0;\n      if (n.y < r)\n        dy = r - n.y;\n      else if (n.y > size[1] - r)\n        dy = size[1] - r - n.y;\n\n      k = 1.2;\n\n      n.x += dx * k;\n      n.y += dy * k;\n      // restraining completed.......................\n\n      // fixes 'elusive' node behaviour when hovering with the mouse (related to force.drag)\n      if (n.fixed) {\n        // 'elusive behaviour' ~ move mouse near node and node would take off, i.e. act as an elusive creature.\n        n.x = n.px;\n        n.y = n.py;\n      }\n      n.px = n.x;\n      n.py = n.y;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n\t\t\n\t\t// also restrain helper nodes to within the visible area --> link paths are almost always ket in-view:\n    net.helper_nodes.forEach(function(n) {\n      // restrain all nodes to window area\n      var k, dx, dy,\n          r = (n.size > 0 ? n.size : 1) + 5 /* heuristic */;\n\n      dx = 0;\n      if (n.x < r)\n        dx = r - n.x;\n      else if (n.x > size[0] - r)\n        dx = size[0] - r - n.x;\n\n      dy = 0;\n      if (n.y < r)\n        dy = r - n.y;\n      else if (n.y > size[1] - r)\n        dy = size[1] - r - n.y;\n\n      k = 1.2;\n\n      n.x += dx * k;\n      n.y += dy * k;\n      // restraining completed.......................\n\n      n.px = n.x;\n      n.py = n.y;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n\t\t\n    if (!isFinite(change_squared))\n      change_squared = width * height;\n\n    // kick the force2 to also do a bit of annealing alongside:\n    // to make it do something, we need to surround it alpha-tweaking stuff, though.\n    force2.resume();\n    force2.tick();\n    force2.stop();\n\n    // fast stop + the drag fix, part 2:\n    if (change_squared < .05) {\n      if (debug == 1) console.log(\"fast stop: CPU load redux\");\n      force1.stop();\n      // fix part 4: monitor D3 resetting the drag marker:\n      if (drag_in_progress) {\n        if (debug == 1) console.log(\"START monitor drag in progress\", drag_in_progress);\n        d3.timer(function() {\n          drag_in_progress = false;\n          net.nodes.forEach(function(n) {\n            if (n.fixed & 2) {\n              drag_in_progress = true;\n            }\n          });\n          force1.resume();\n          if (debug == 1) console.log(\"monitor drag in progress: drag ENDED\", drag_in_progress);\n          // Quit monitoring as soon as we noticed the drag ENDED.\n          // Note: we continue to monitor at +500ms intervals beyond the last tick\n          //       as this timer function ALWAYS kickstarts the force layout again\n          //       through force.resume().\n          //       d3.timer() API only accepts an initial delay; we can't set this\n          //       thing to scan, say, every 500msecs until the drag is done,\n          //       so we do it that way, via the revived force.tick process.\n          return true;\n        }, 500);\n      }\n    } else if (change_squared > net.nodes.length * 0.1 * resume_threshold && e.alpha < resume_threshold) {\n      // jolt the alpha (and the visual) when there's still a lot of change when we hit the alpha threshold.\n      force1.alpha(e.alpha *= 2); //force.resume(), but now with decreasing alpha starting value so the jolts don't get so big.\n\n      // And 'dampen out' the trigger point, so it becomes harder and harder to trigger the threshold.\n      // This is done to cope with those instable (forever rotating, etc.) layouts...\n      resume_threshold *= 0.75;\n    } else {\n      //console.log(\"fast stop tracking: \", change_squared, net.nodes.length * 0.1 * resume_threshold, e.alpha, resume_threshold);\n    }\n\n    //--------------------------------------------------------------------\n\n    if (!hull.empty()) {\n      hull.data(convexHulls(net.nodes, off))\n          .attr(\"d\", drawCluster);\n    }\n\n    if (debug == 1) {\n      link.attr(\"x1\", function(d) { return d.source.x; })\n          .attr(\"y1\", function(d) { return d.source.y; })\n          .attr(\"x2\", function(d) { return d.target.x; })\n          .attr(\"y2\", function(d) { return d.target.y; });\n    }\n\n    node.attr(\"cx\", function(d) { return d.x; })\n        .attr(\"__name__\", function(d) { return d.name || \"xxx\"; })\n        .attr(\"cy\", function(d) { return d.y; });\n  });\n\n\n\n  var log_count = 100;\n\n\n\n\n  force2.on(\"tick\", function(e) {\n    /*\n      Update all 'real'=fixed nodes.\n    */\n    net.helper_nodes.forEach(function(n) {\n      var o;\n      if (n.fixed) {\n        o = n.ref;\n        n.px = n.x = o.x;\n        n.py = n.y = o.y;\n      }\n    });\n    net.helper_links.forEach(function(l) {\n      var o = l.g_ref;\n      l.distance = o.distance;\n    });\n\n    // NOTE: force2 is fully driven by force(1), but still there's need for 'fast stop' handling in here\n    //       as our force2 may be more 'joyous' in animating the links that force is animating the nodes\n    //       themselves. Hence we also take the delta movement of the helper nodes into account!\n    net.helper_nodes.forEach(function(n) {\n      // skip the 'fixed' buggers: those are already accounted for in force.tick!\n      if (n.fixed)\n        return;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n    if (!isFinite(change_squared))\n      change_squared = width * height;\n\n    //--------------------------------------------------------------------\n\n    var logged = false;\n\n    hlink.attr(\"d\", function(d) {\n      if (isFinite(d.real_source.x)) {\n\t\t\t  var linedata, dx, dy, f;\n\t\t\t  if (d.cyclic) {\n\t\t\t\t  // construct round-ish bezier from node to helper and back again:\n\t\t\t\t  dx = d.target.x - d.real_source.x;\n\t\t\t\t  dy = d.target.y - d.real_source.y;\n\t\t\t\t\tlinedata = [\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y],\n\t\t\t\t\t\t\t[d.target.x - cycle_curvep * dy, d.target.y + cycle_curvep * dx], \n\t\t\t\t\t\t\t[d.target.x + cycle_curvep * dx, d.target.y + cycle_curvep * dy], \n\t\t\t\t\t\t\t[d.target.x + cycle_curvep * dy, d.target.y - cycle_curvep * dx],\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y]\n\t\t\t\t\t];\n\t\t\t\t\treturn cycle_pathgen(linedata);\n\t\t\t\t} else {\n\t\t\t\t\tlinedata = [\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y],\n\t\t\t\t\t\t\t[d.source.x, d.source.y],\n\t\t\t\t\t\t\t[d.target.x, d.target.y],\n\t\t\t\t\t\t\t[d.real_target.x, d.real_target.y]\n\t\t\t\t\t];\n\t\t\t\t\treturn pathgen(linedata);\n\t\t\t\t}\n      } else {\n        if (!logged) {\n          console.log(\"boom\");\n          logged = true;\n        }\n        return null;\n      }\n    });\n\n    if (debug && debug < 3) {\n      hnode.attr(\"cx\", function(d) { return d.x; })\n           .attr(\"cy\", function(d) { return d.y; });\n    }\n  });\n}\n\n    </script>\n  </body>\n</html>\n",
      "language": "HTML"
    },
    "README.md": {
      "type": "text/plain",
      "filename": "README.md",
      "raw_url": "https://gist.github.com/raw/3616279/57c4ecdc0d29557637dc0dfef0eac4e948569ad7/README.md",
      "size": 1717,
      "content": "Derived from the D3.js example [force_cluster.html](https://github.com/mbostock/d3/blob/master/examples/force/force-cluster.html) and [gist 3104394](http://bl.ocks.org/3104394).\n\nFeatures\n========\n\n- all of [gist 3104394](http://bl.ocks.org/3104394) [@ github](https://gist.github.com/3104394)\n- showcases a tweaked 'miserables.json' file which includes 'circular links' i.e. links which connect node A to node A (~ self-reference)\n\nUsage\n-----\n\n* Slide the 'debug level' slider to see the various debug levels visually; the hospital curves are (top): force.alpha and (bottom) total x/y change squared: a measurement for the amount of movement of nodes in the graph. Note that the bottom curve is inverted, so that when both meet, you're getting close to done. :-)\n* Click on node to expand or collapse. When a node has 'bundled' outgoing links, the first click will expand only those (a.k.a. 2nd display mode / expand state = 1), the next click will then expand the group node itself.\n* Click on hull (which shows up when you expanded a group node) to collapse the group.\n* Drag node to move entire graph around.\n\nNotes\n-----\n\nThe ability to draw circular references is following the overall force design used here, \nwhere helper nodes (and ditto links) are used to produce the bezier-based links; \na self-reference is nothing but yet another nodeA -> helper -> nodeB link chain where\n'nodeB' just happens to be nodeA again.\n\nThis code uses two(2) d3.layout.force() forces: one to layout the original nodes (or their group node equivalent),\nthe second is used to layout all the helper nodes (which are only visible in debug modes 1 and 2): the latter are \nused to construct the bezier paths representing the links.\n\n",
      "language": "Markdown"
    }
  },
  "updated_at": "2012-09-09T09:01:25Z",
  "url": "https://api.github.com/gists/3616279",
  "git_pull_url": "git://gist.github.com/3616279.git",
  "id": "3616279"
}
