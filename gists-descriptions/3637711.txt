{
  "forks": [

  ],
  "user": {
    "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
    "login": "GerHobbelt",
    "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
    "url": "https://api.github.com/users/GerHobbelt",
    "id": 402462
  },
  "history": [
    {
      "change_status": {
        "total": 0,
        "additions": 0,
        "deletions": 0
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-09T07:59:50Z",
      "version": "dd482e884375389101a21cf0d6e8feadc1719447",
      "url": "https://api.github.com/gists/3637711/dd482e884375389101a21cf0d6e8feadc1719447"
    },
    {
      "change_status": {
        "total": 5,
        "additions": 4,
        "deletions": 1
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-09T07:59:01Z",
      "version": "3f2cb58406e6e32cd12d9b11264306ecf3adc801",
      "url": "https://api.github.com/gists/3637711/3f2cb58406e6e32cd12d9b11264306ecf3adc801"
    },
    {
      "change_status": {
        "total": 3,
        "additions": 1,
        "deletions": 2
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-09T07:57:26Z",
      "version": "4fbbe8c5519e8d932d5f4677f2f11c8ad393efd8",
      "url": "https://api.github.com/gists/3637711/4fbbe8c5519e8d932d5f4677f2f11c8ad393efd8"
    },
    {
      "change_status": {
        "total": 53,
        "additions": 28,
        "deletions": 25
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T19:42:27Z",
      "version": "f518b6395188e72796fa92d974c16615a7192c77",
      "url": "https://api.github.com/gists/3637711/f518b6395188e72796fa92d974c16615a7192c77"
    },
    {
      "change_status": {
        "total": 10109,
        "additions": 10092,
        "deletions": 17
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T19:24:58Z",
      "version": "e49e111e6b95805e3995a8b8226b2742aebeb41b",
      "url": "https://api.github.com/gists/3637711/e49e111e6b95805e3995a8b8226b2742aebeb41b"
    },
    {
      "change_status": {
        "total": 0,
        "additions": 0,
        "deletions": 0
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T14:51:36Z",
      "version": "3937910baaff828e7c00033aeff2a99b7a34cf40",
      "url": "https://api.github.com/gists/3637711/3937910baaff828e7c00033aeff2a99b7a34cf40"
    },
    {
      "change_status": {
        "total": 7,
        "additions": 7,
        "deletions": 0
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T14:50:14Z",
      "version": "f8b93d1385e3aa73fa82989c3096fa788983efba",
      "url": "https://api.github.com/gists/3637711/f8b93d1385e3aa73fa82989c3096fa788983efba"
    },
    {
      "change_status": {
        "total": 1,
        "additions": 1,
        "deletions": 0
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T14:47:02Z",
      "version": "95b3cee9bbf206e09fea83b93dec8a419ff0830f",
      "url": "https://api.github.com/gists/3637711/95b3cee9bbf206e09fea83b93dec8a419ff0830f"
    },
    {
      "change_status": {
        "total": 2,
        "additions": 2,
        "deletions": 0
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-05T14:25:24Z",
      "version": "a16be381562ef27fdc31c54e5909dbe9c446d268",
      "url": "https://api.github.com/gists/3637711/a16be381562ef27fdc31c54e5909dbe9c446d268"
    },
    {
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "user": {
        "gravatar_id": "96cd1af3aefe14ff4f803a7ef582d182",
        "login": "GerHobbelt",
        "avatar_url": "https://secure.gravatar.com/avatar/96cd1af3aefe14ff4f803a7ef582d182?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "url": "https://api.github.com/users/GerHobbelt",
        "id": 402462
      },
      "committed_at": "2012-09-04T06:53:34Z",
      "version": "fe27925f2b72b8941466cc39e4b674af330ee631",
      "url": "https://api.github.com/gists/3637711/fe27925f2b72b8941466cc39e4b674af330ee631"
    }
  ],
  "description": "d3.js: force layout with 'pinning' nodes after dragging (SHIFT or CTRL key)",
  "html_url": "https://gist.github.com/3637711",
  "comments": 0,
  "created_at": "2012-09-05T14:47:02Z",
  "git_pull_url": "git://gist.github.com/3637711.git",
  "public": true,
  "files": {
    "CREDITS": {
      "type": "text/plain",
      "filename": "CREDITS",
      "raw_url": "https://gist.github.com/raw/3637711/be62eea78c45fef0e8fa951885ec524b0c920410/CREDITS",
      "size": 664,
      "content": "Code derived from the d3.js 'force' example:\n\nThe miserables.json file contains the weighted network of coappearances of\ncharacters in Victor Hugo's novel /Les Miserables/. Nodes represent characters\nas indicated by the labels, and edges connect any pair of characters that\nappear in the same chapter of the book. The values on the edges are the number\nof such coappearances. The data on coappearances were taken from D. E. Knuth,\n\"The Stanford GraphBase: A Platform for Combinatorial Computing\",\nAddison-Wesley, Reading, MA (1993).\n\nThe group labels were transcribed from \"Finding and evaluating community\nstructure in networks\" by M. E. J. Newman and M. Girvan.\n",
      "language": null
    },
    "README.md": {
      "type": "text/plain",
      "filename": "README.md",
      "raw_url": "https://gist.github.com/raw/3637711/3f4a3e7d5ebe9146584c3ea9d012c5144e8fadf4/README.md",
      "size": 2592,
      "content": "Pinning nodes (or groups of nodes) in force layout after drag: .fixed bits …… <a href=\"http://bl.ocks.org/3637711\" title=\"view this gist via bl.ocks.org\">∆</a> <a href=\"http://bl.ocks.org/GerHobbelt\" title=\"view a list of all my gists at bl.ocks.org\">∞</a>\n==========================================================================\n\nDerived from the D3.js example [force_cluster.html](https://github.com/mbostock/d3/blob/master/examples/force/force-cluster.html) and [gist 3104394](http://bl.ocks.org/3104394).\n\nFeatures\n========\n\n- all of [gist 3104394](http://bl.ocks.org/3104394) [@ github](https://gist.github.com/3104394)\n- keep SHIFT or CTRL pressed when ending a drag move to 'pin' the node/group there: SHIFT will 'pin' all group nodes; you may drag individual nodes of the group around while they will remain pinned hat way.\n- showcases a tweaked 'miserables.json' file which includes 'circular links' i.e. links which connect node A to node A (~ self-reference)\n\nKnown Bugs\n----------\n\n- doesn't work with vanilla d3.layout.force as it would clear out the .fixed member; this code uses an augmented d3.js file. [pull request #798](https://github.com/mbostock/d3/pull/798)\n- .fixed PIN state doesn't correctly propagate/clear when you click nodes to expand/contract them from/to group nodes.\n\nUsage\n-----\n\n* Slide the 'debug level' slider to see the various debug levels visually; the hospital curves are (top): force.alpha and (bottom) total x/y change squared: a measurement for the amount of movement of nodes in the graph. Note that the bottom curve is inverted, so that when both meet, you're getting close to done. :-)\n* Click on node to expand or collapse. When a node has 'bundled' outgoing links, the first click will expand only those (a.k.a. 2nd display mode / expand state = 1), the next click will then expand the group node itself.\n* Click on hull (which shows up when you expanded a group node) to collapse the group.\n* Drag node to move entire graph around.\n\nNotes\n-----\n\nThe ability to draw circular references is following the overall force design used here, \nwhere helper nodes (and ditto links) are used to produce the bezier-based links; \na self-reference is nothing but yet another nodeA -> helper -> nodeB link chain where\n'nodeB' just happens to be nodeA again.\n\nThis code uses two(2) d3.layout.force() forces: one to layout the original nodes (or their group node equivalent),\nthe second is used to layout all the helper nodes (which are only visible in debug modes 1 and 2): the latter are \nused to construct the bezier paths representing the links.",
      "language": "Markdown"
    },
    "sync-d3.sh": {
      "type": "application/sh",
      "filename": "sync-d3.sh",
      "raw_url": "https://gist.github.com/raw/3637711/91f2f14f5001e8e3dbb168552b3b2053d3a87d1f/sync-d3.sh",
      "size": 137,
      "content": "#! /bin/bash\n#\n# copy latest d3.js from local D3 work repo\n#\n\nrm -f d3.v2.js\npushd ../html/js/d3/\nmake\npopd\ncp ../html/js/d3/d3.v2.js ./\n",
      "language": "Shell"
    },
    "d3.v2.js": {
      "type": "application/javascript",
      "filename": "d3.v2.js",
      "raw_url": "https://gist.github.com/raw/3637711/b91a95fdffbd1dc48cd0dc533ae8e481e052b835/d3.v2.js",
      "size": 276284,
      "content": "(function(){if (!Date.now) Date.now = function() {\n  return +new Date;\n};\ntry {\n  document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\n} catch (error) {\n  var d3_style_prototype = CSSStyleDeclaration.prototype,\n      d3_style_setProperty = d3_style_prototype.setProperty;\n  d3_style_prototype.setProperty = function(name, value, priority) {\n    d3_style_setProperty.call(this, name, value + \"\", priority);\n  };\n}\nd3 = {version: \"2.10.0\"}; // semver\nfunction d3_class(ctor, properties) {\n  try {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  } catch (e) {\n    ctor.prototype = properties;\n  }\n}\nvar d3_array = d3_arraySlice; // conversion for NodeLists\n\nfunction d3_arrayCopy(pseudoarray) {\n  var i = -1, n = pseudoarray.length, array = [];\n  while (++i < n) array.push(pseudoarray[i]);\n  return array;\n}\n\nfunction d3_arraySlice(pseudoarray) {\n  return Array.prototype.slice.call(pseudoarray);\n}\n\ntry {\n  d3_array(document.documentElement.childNodes)[0].nodeType;\n} catch(e) {\n  d3_array = d3_arrayCopy;\n}\n\nvar d3_arraySubclass = [].__proto__?\n\n// Until ECMAScript supports array subclassing, prototype injection works well.\nfunction(array, prototype) {\n  array.__proto__ = prototype;\n}:\n\n// And if your browser doesn't support __proto__, we'll use direct extension.\nfunction(array, prototype) {\n  for (var property in prototype) array[property] = prototype[property];\n};\nd3.map = function(object) {\n  var map = new d3_Map;\n  for (var key in object) map.set(key, object[key]);\n  return map;\n};\n\nfunction d3_Map() {}\n\nd3_class(d3_Map, {\n  has: function(key) {\n    return d3_map_prefix + key in this;\n  },\n  get: function(key) {\n    return this[d3_map_prefix + key];\n  },\n  set: function(key, value) {\n    return this[d3_map_prefix + key] = value;\n  },\n  remove: function(key) {\n    key = d3_map_prefix + key;\n    return key in this && delete this[key];\n  },\n  keys: function() {\n    var keys = [];\n    this.forEach(function(key) { keys.push(key); });\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    this.forEach(function(key, value) { values.push(value); });\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    this.forEach(function(key, value) { entries.push({key: key, value: value}); });\n    return entries;\n  },\n  forEach: function(f) {\n    for (var key in this) {\n      if (key.charCodeAt(0) === d3_map_prefixCode) {\n        f.call(this, key.substring(1), this[key]);\n      }\n    }\n  }\n});\n\nvar d3_map_prefix = \"\\0\", // prevent collision with built-ins\n    d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\nfunction d3_identity(d) {\n  return d;\n}\nfunction d3_this() {\n  return this;\n}\nfunction d3_true() {\n  return true;\n}\nfunction d3_functor(v) {\n  return typeof v === \"function\" ? v : function() { return v; };\n}\n\nd3.functor = d3_functor;\n// Copies a variable number of methods from source to target.\nd3.rebind = function(target, source) {\n  var i = 1, n = arguments.length, method;\n  while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n  return target;\n};\n\n// Method is assumed to be a standard D3 getter-setter:\n// If passed with no arguments, gets the value.\n// If passed with arguments, sets the value and returns the target.\nfunction d3_rebind(target, source, method) {\n  return function() {\n    var value = method.apply(source, arguments);\n    return arguments.length ? target : value;\n  };\n}\nd3.ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\nd3.descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\nd3.mean = function(array, f) {\n  var n = array.length,\n      a,\n      m = 0,\n      i = -1,\n      j = 0;\n  if (arguments.length === 1) {\n    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\n  } else {\n    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\n  }\n  return j ? m : undefined;\n};\nd3.median = function(array, f) {\n  if (arguments.length > 1) array = array.map(f);\n  array = array.filter(d3_number);\n  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;\n};\nd3.min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n  }\n  return a;\n};\nd3.max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n  }\n  return a;\n};\nd3.extent = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b,\n      c;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  } else {\n    while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  }\n  return [a, c];\n};\nd3.random = {\n  normal: function(µ, σ) {\n    var n = arguments.length;\n    if (n < 2) σ = 1;\n    if (n < 1) µ = 0;\n    return function() {\n      var x, y, r;\n      do {\n        x = Math.random() * 2 - 1;\n        y = Math.random() * 2 - 1;\n        r = x * x + y * y;\n      } while (!r || r > 1);\n      return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  },\n  logNormal: function(µ, σ) {\n    var n = arguments.length;\n    if (n < 2) σ = 1;\n    if (n < 1) µ = 0;\n    var random = d3.random.normal();\n    return function() {\n      return Math.exp(µ + σ * random());\n    };\n  },\n  irwinHall: function(m) {\n    return function() {\n      for (var s = 0, j = 0; j < m; j++) s += Math.random();\n      return s / m;\n    };\n  }\n};\nfunction d3_number(x) {\n  return x != null && !isNaN(x);\n}\nd3.sum = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1;\n\n  if (arguments.length === 1) {\n    while (++i < n) if (!isNaN(a = +array[i])) s += a;\n  } else {\n    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\n  }\n\n  return s;\n};\n// R-7 per <http://en.wikipedia.org/wiki/Quantile>\nd3.quantile = function(values, p) {\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = values[h - 1],\n      e = H - h;\n  return e ? v + e * (values[h] - v) : v;\n};\nd3.transpose = function(matrix) {\n  return d3.zip.apply(d3, matrix);\n};\nd3.zip = function() {\n  if (!(n = arguments.length)) return [];\n  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {\n    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {\n      zip[j] = arguments[j][i];\n    }\n  }\n  return zips;\n};\n\nfunction d3_zipLength(d) {\n  return d.length;\n}\nd3.bisector = function(f) {\n  return {\n    left: function(a, x, lo, hi) {\n      if (arguments.length < 3) lo = 0;\n      if (arguments.length < 4) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (f.call(a, a[mid], mid) < x) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (arguments.length < 3) lo = 0;\n      if (arguments.length < 4) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (x < f.call(a, a[mid], mid)) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nvar d3_bisector = d3.bisector(function(d) { return d; });\nd3.bisectLeft = d3_bisector.left;\nd3.bisect = d3.bisectRight = d3_bisector.right;\nd3.first = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) > 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.last = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) <= 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.nest = function() {\n  var nest = {},\n      keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup;\n\n  function map(array, depth) {\n    if (depth >= keys.length) return rollup\n        ? rollup.call(nest, array) : (sortValues\n        ? array.sort(sortValues)\n        : array);\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        object,\n        valuesByKey = new d3_Map,\n        values,\n        o = {};\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n        values.push(object);\n      } else {\n        valuesByKey.set(keyValue, [object]);\n      }\n    }\n\n    valuesByKey.forEach(function(keyValue) {\n      o[keyValue] = map(valuesByKey.get(keyValue), depth);\n    });\n\n    return o;\n  }\n\n  function entries(map, depth) {\n    if (depth >= keys.length) return map;\n\n    var a = [],\n        sortKey = sortKeys[depth++],\n        key;\n\n    for (key in map) {\n      a.push({key: key, values: entries(map[key], depth)});\n    }\n\n    if (sortKey) a.sort(function(a, b) {\n      return sortKey(a.key, b.key);\n    });\n\n    return a;\n  }\n\n  nest.map = function(array) {\n    return map(array, 0);\n  };\n\n  nest.entries = function(array) {\n    return entries(map(array, 0), 0);\n  };\n\n  nest.key = function(d) {\n    keys.push(d);\n    return nest;\n  };\n\n  // Specifies the order for the most-recently specified key.\n  // Note: only applies to entries. Map keys are unordered!\n  nest.sortKeys = function(order) {\n    sortKeys[keys.length - 1] = order;\n    return nest;\n  };\n\n  // Specifies the order for leaf values.\n  // Applies to both maps and entries array.\n  nest.sortValues = function(order) {\n    sortValues = order;\n    return nest;\n  };\n\n  nest.rollup = function(f) {\n    rollup = f;\n    return nest;\n  };\n\n  return nest;\n};\nd3.keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\nd3.values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\nd3.entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\nd3.permute = function(array, indexes) {\n  var permutes = [],\n      i = -1,\n      n = indexes.length;\n  while (++i < n) permutes[i] = array[indexes[i]];\n  return permutes;\n};\nd3.merge = function(arrays) {\n  return Array.prototype.concat.apply([], arrays);\n};\nd3.split = function(array, f) {\n  var arrays = [],\n      values = [],\n      value,\n      i = -1,\n      n = array.length;\n  if (arguments.length < 2) f = d3_splitter;\n  while (++i < n) {\n    if (f.call(values, value = array[i], i)) {\n      values = [];\n    } else {\n      if (!values.length) arrays.push(values);\n      values.push(value);\n    }\n  }\n  return arrays;\n};\n\nfunction d3_splitter(d) {\n  return d == null;\n}\nfunction d3_collapse(s) {\n  return s.trim().replace(/\\s+/g, \" \");\n}\nd3.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       k = d3_range_integerScale(Math.abs(step)),\n       i = -1,\n       j;\n  start *= k, stop *= k, step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n  else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n};\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\nd3.requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\nd3.round = function(x, n) {\n  return n\n      ? Math.round(x * (n = Math.pow(10, n))) / n\n      : Math.round(x);\n};\nd3.xhr = function(url, mime, callback) {\n  var req = new XMLHttpRequest;\n  if (arguments.length < 3) callback = mime, mime = null;\n  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);\n  req.open(\"GET\", url, true);\n  if (mime) req.setRequestHeader(\"Accept\", mime);\n  req.onreadystatechange = function() {\n    if (req.readyState === 4) {\n      var s = req.status;\n      callback(!s && req.response || s >= 200 && s < 300 || s === 304 ? req : null);\n    }\n  };\n  req.send(null);\n};\nd3.text = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseText);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.json = function(url, callback) {\n  d3.text(url, \"application/json\", function(text) {\n    callback(text ? JSON.parse(text) : null);\n  });\n};\nd3.html = function(url, callback) {\n  d3.text(url, \"text/html\", function(text) {\n    if (text != null) { // Treat empty string as valid HTML.\n      var range = document.createRange();\n      range.selectNode(document.body);\n      text = range.createContextualFragment(text);\n    }\n    callback(text);\n  });\n};\nd3.xml = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseXML);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nvar d3_nsPrefix = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nd3.ns = {\n  prefix: d3_nsPrefix,\n  qualify: function(name) {\n    var i = name.indexOf(\":\"),\n        prefix = name;\n    if (i >= 0) {\n      prefix = name.substring(0, i);\n      name = name.substring(i + 1);\n    }\n    return d3_nsPrefix.hasOwnProperty(prefix)\n        ? {space: d3_nsPrefix[prefix], local: name}\n        : name;\n  }\n};\nd3.dispatch = function() {\n  var dispatch = new d3_dispatch,\n      i = -1,\n      n = arguments.length;\n  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n  return dispatch;\n};\n\nfunction d3_dispatch() {}\n\nd3_dispatch.prototype.on = function(type, listener) {\n  var i = type.indexOf(\".\"),\n      name = \"\";\n\n  // Extract optional namespace, e.g., \"click.foo\"\n  if (i > 0) {\n    name = type.substring(i + 1);\n    type = type.substring(0, i);\n  }\n\n  return arguments.length < 2\n      ? this[type].on(name)\n      : this[type].on(name, listener);\n};\n\nfunction d3_dispatch_event(dispatch) {\n  var listeners = [],\n      listenerByName = new d3_Map;\n\n  function event() {\n    var z = listeners, // defensive reference\n        i = -1,\n        n = z.length,\n        l;\n    while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n    return dispatch;\n  }\n\n  event.on = function(name, listener) {\n    var l = listenerByName.get(name),\n        i;\n\n    // return the current listener, if any\n    if (arguments.length < 2) return l && l.on;\n\n    // remove the old listener, if any (with copy-on-write)\n    if (l) {\n      l.on = null;\n      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n      listenerByName.remove(name);\n    }\n\n    // add the new listener, if any\n    if (listener) listeners.push(listenerByName.set(name, {on: listener}));\n\n    return dispatch;\n  };\n\n  return event;\n}\n// TODO align\nd3.format = function(specifier) {\n  var match = d3_format_re.exec(specifier),\n      fill = match[1] || \" \",\n      sign = match[3] || \"\",\n      zfill = match[5],\n      width = +match[6],\n      comma = match[7],\n      precision = match[8],\n      type = match[9],\n      scale = 1,\n      suffix = \"\",\n      integer = false;\n\n  if (precision) precision = +precision.substring(1);\n\n  if (zfill) {\n    fill = \"0\"; // TODO align = \"=\";\n    if (comma) width -= Math.floor((width - 1) / 4);\n  }\n\n  switch (type) {\n    case \"n\": comma = true; type = \"g\"; break;\n    case \"%\": scale = 100; suffix = \"%\"; type = \"f\"; break;\n    case \"p\": scale = 100; suffix = \"%\"; type = \"r\"; break;\n    case \"d\": integer = true; precision = 0; break;\n    case \"s\": scale = -1; type = \"r\"; break;\n  }\n\n  // If no precision is specified for r, fallback to general notation.\n  if (type == \"r\" && !precision) type = \"g\";\n\n  type = d3_format_types.get(type) || d3_format_typeDefault;\n\n  return function(value) {\n\n    // Return the empty string for floats formatted as ints.\n    if (integer && (value % 1)) return \"\";\n\n    // Convert negative to positive, and record the sign prefix.\n    var negative = (value < 0) && (value = -value) ? \"-\" : sign;\n\n    // Apply the scale, computing it from the value's exponent for si format.\n    if (scale < 0) {\n      var prefix = d3.formatPrefix(value, precision);\n      value = prefix.scale(value);\n      suffix = prefix.symbol;\n    } else {\n      value *= scale;\n    }\n\n    // Convert to the desired precision.\n    value = type(value, precision);\n\n    // If the fill character is 0, the sign and group is applied after the fill.\n    if (zfill) {\n      var length = value.length + negative.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n    }\n\n    // Otherwise (e.g., space-filling), the sign and group is applied before.\n    else {\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n      var length = value.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n    }\n\n    return value + suffix;\n  };\n};\n\n// [[fill]align][sign][#][0][width][,][.precision][type]\nvar d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n\nvar d3_format_types = d3.map({\n  g: function(x, p) { return x.toPrecision(p); },\n  e: function(x, p) { return x.toExponential(p); },\n  E: function(x, p) {\n    var rv;\n    var p1 = d3_format_precision(x, 1);\n    if (p1 >= -5 && p1 <= 3)\n      rv = x.toFixed(Math.max(0, p, p1));\n    else\n      rv = x.toExponential(p);\n    return rv;\n  },\n  f: function(x, p) { return x.toFixed(p); },\n  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }\n});\n\nfunction d3_format_precision(x, p) {\n  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);\n}\n\nd3.formatPrecision = function(x, p) {\n  return d3_format_precision(x, p || 0);\n};\n\nfunction d3_format_typeDefault(x) {\n  return x + \"\";\n}\n\n// Apply comma grouping for thousands.\nfunction d3_format_group(value) {\n  var i = value.lastIndexOf(\".\"),\n      f = i >= 0 ? value.substring(i) : (i = value.length, \"\"),\n      t = [];\n  while (i > 0) t.push(value.substring(i -= 3, i + 3));\n  return t.reverse().join(\",\") + f;\n}\nvar d3_formatPrefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"μ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"].map(d3_formatPrefix);\n\nd3.formatPrefix = function(value, precision) {\n  var i = 0;\n  if (value) {\n    if (value < 0) value *= -1;\n    if (precision) value = d3.round(value, d3_format_precision(value, precision));\n    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n  }\n  return d3_formatPrefixes[8 + i / 3];\n};\n\nfunction d3_formatPrefix(d, i) {\n  var k = Math.pow(10, Math.abs(8 - i) * 3);\n  return {\n    scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; },\n    symbol: d\n  };\n}\n/*\n * TERMS OF USE - EASING EQUATIONS\n *\n * Open source under the BSD License.\n *\n * Copyright 2001 Robert Penner\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of contributors may be used to\n *   endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar d3_ease_quad = d3_ease_poly(2),\n    d3_ease_cubic = d3_ease_poly(3),\n    d3_ease_default = function() { return d3_ease_identity; };\n\nvar d3_ease = d3.map({\n  linear: d3_ease_default,\n  poly: d3_ease_poly,\n  quad: function() { return d3_ease_quad; },\n  cubic: function() { return d3_ease_cubic; },\n  sin: function() { return d3_ease_sin; },\n  exp: function() { return d3_ease_exp; },\n  circle: function() { return d3_ease_circle; },\n  elastic: d3_ease_elastic,\n  back: d3_ease_back,\n  bounce: function() { return d3_ease_bounce; }\n});\n\nvar d3_ease_mode = d3.map({\n  \"in\": d3_ease_identity,\n  \"out\": d3_ease_reverse,\n  \"in-out\": d3_ease_reflect,\n  \"out-in\": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }\n});\n\nd3.ease = function(name) {\n  var i = name.indexOf(\"-\"),\n      t = i >= 0 ? name.substring(0, i) : name,\n      m = i >= 0 ? name.substring(i + 1) : \"in\";\n  t = d3_ease.get(t) || d3_ease_default;\n  m = d3_ease_mode.get(m) || d3_ease_identity;\n  return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));\n};\n\nfunction d3_ease_clamp(f) {\n  return function(t) {\n    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n  };\n}\n\nfunction d3_ease_reverse(f) {\n  return function(t) {\n    return 1 - f(1 - t);\n  };\n}\n\nfunction d3_ease_reflect(f) {\n  return function(t) {\n    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n  };\n}\n\nfunction d3_ease_identity(t) {\n  return t;\n}\n\nfunction d3_ease_poly(e) {\n  return function(t) {\n    return Math.pow(t, e);\n  };\n}\n\nfunction d3_ease_sin(t) {\n  return 1 - Math.cos(t * Math.PI / 2);\n}\n\nfunction d3_ease_exp(t) {\n  return Math.pow(2, 10 * (t - 1));\n}\n\nfunction d3_ease_circle(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction d3_ease_elastic(a, p) {\n  var s;\n  if (arguments.length < 2) p = 0.45;\n  if (arguments.length < 1) { a = 1; s = p / 4; }\n  else s = p / (2 * Math.PI) * Math.asin(1 / a);\n  return function(t) {\n    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);\n  };\n}\n\nfunction d3_ease_back(s) {\n  if (!s) s = 1.70158;\n  return function(t) {\n    return t * t * ((s + 1) * t - s);\n  };\n}\n\nfunction d3_ease_bounce(t) {\n  return t < 1 / 2.75 ? 7.5625 * t * t\n      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75\n      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375\n      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n}\nd3.event = null;\n\nfunction d3_eventCancel() {\n  d3.event.stopPropagation();\n  d3.event.preventDefault();\n}\n\nfunction d3_eventSource() {\n  var e = d3.event, s;\n  while (s = e.sourceEvent) e = s;\n  return e;\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3_eventDispatch(target) {\n  var dispatch = new d3_dispatch,\n      i = 0,\n      n = arguments.length;\n\n  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n  // Creates a dispatch context for the specified `thiz` (typically, the target\n  // DOM element that received the source event) and `argumentz` (typically, the\n  // data `d` and index `i` of the target element). The returned function can be\n  // used to dispatch an event to any registered listeners; the function takes a\n  // single argument as input, being the event to dispatch. The event must have\n  // a \"type\" attribute which corresponds to a type registered in the\n  // constructor. This context will automatically populate the \"sourceEvent\" and\n  // \"target\" attributes of the event, as well as setting the `d3.event` global\n  // for the duration of the notification.\n  dispatch.of = function(thiz, argumentz) {\n    return function(e1) {\n      try {\n        var e0 =\n        e1.sourceEvent = d3.event;\n        e1.target = target;\n        d3.event = e1;\n        dispatch[e1.type].apply(thiz, argumentz);\n      } finally {\n        d3.event = e0;\n      }\n    };\n  };\n\n  return dispatch;\n}\nd3.transform = function(string) {\n  var g = document.createElementNS(d3.ns.prefix.svg, \"g\");\n  return (d3.transform = function(string) {\n    g.setAttribute(\"transform\", string);\n    var t = g.transform.baseVal.consolidate();\n    return new d3_transform(t ? t.matrix : d3_transformIdentity);\n  })(string);\n};\n\n// Compute x-scale and normalize the first row.\n// Compute shear and make second row orthogonal to first.\n// Compute y-scale and normalize the second row.\n// Finally, compute the rotation.\nfunction d3_transform(m) {\n  var r0 = [m.a, m.b],\n      r1 = [m.c, m.d],\n      kx = d3_transformNormalize(r0),\n      kz = d3_transformDot(r0, r1),\n      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n  if (r0[0] * r1[1] < r1[0] * r0[1]) {\n    r0[0] *= -1;\n    r0[1] *= -1;\n    kx *= -1;\n    kz *= -1;\n  }\n  this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;\n  this.translate = [m.e, m.f];\n  this.scale = [kx, ky];\n  this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;\n};\n\nd3_transform.prototype.toString = function() {\n  return \"translate(\" + this.translate\n      + \")rotate(\" + this.rotate\n      + \")skewX(\" + this.skew\n      + \")scale(\" + this.scale\n      + \")\";\n};\n\nfunction d3_transformDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\nfunction d3_transformNormalize(a) {\n  var k = Math.sqrt(d3_transformDot(a, a));\n  if (k) {\n    a[0] /= k;\n    a[1] /= k;\n  }\n  return k;\n}\n\nfunction d3_transformCombine(a, b, k) {\n  a[0] += k * b[0];\n  a[1] += k * b[1];\n  return a;\n}\n\nvar d3_transformDegrees = 180 / Math.PI,\n    d3_transformIdentity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};\nd3.interpolate = function(a, b) {\n  var i = d3.interpolators.length, f;\n  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n  return f;\n};\n\nd3.interpolateNumber = function(a, b) {\n  b -= a;\n  return function(t) { return a + b * t; };\n};\n\nd3.interpolateRound = function(a, b) {\n  b -= a;\n  return function(t) { return Math.round(a + b * t); };\n};\n\nd3.interpolateString = function(a, b) {\n  var m, // current match\n      i, // current index\n      j, // current index (for coalescing)\n      s0 = 0, // start index of current string prefix\n      s1 = 0, // end index of current string prefix\n      s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n, // q.length\n      o;\n\n  // Reset our regular expression!\n  d3_interpolate_number.lastIndex = 0;\n\n  // Find all numbers in b.\n  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\n    if (m.index) s.push(b.substring(s0, s1 = m.index));\n    q.push({i: s.length, x: m[0]});\n    s.push(null);\n    s0 = d3_interpolate_number.lastIndex;\n  }\n  if (s0 < b.length) s.push(b.substring(s0));\n\n  // Find all numbers in a.\n  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\n    o = q[i];\n    if (o.x == m[0]) { // The numbers match, so coalesce.\n      if (o.i) {\n        if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i - 1] += o.x;\n          s.splice(o.i, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        } else { // This match is followed by a string, so coalesce twice.\n          s[o.i - 1] += o.x + s[o.i + 1];\n          s.splice(o.i, 2);\n          for (j = i + 1; j < n; ++j) q[j].i -= 2;\n        }\n      } else {\n          if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i] = o.x;\n        } else { // This match is followed by a string, so coalesce twice.\n          s[o.i] = o.x + s[o.i + 1];\n          s.splice(o.i + 1, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        }\n      }\n      q.splice(i, 1);\n      n--;\n      i--;\n    } else {\n      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n    }\n  }\n\n  // Remove any numbers in b not found in a.\n  while (i < n) {\n    o = q.pop();\n    if (s[o.i + 1] == null) { // This match is followed by another number.\n      s[o.i] = o.x;\n    } else { // This match is followed by a string, so coalesce twice.\n      s[o.i] = o.x + s[o.i + 1];\n      s.splice(o.i + 1, 1);\n    }\n    n--;\n  }\n\n  // Special optimization for only a single match.\n  if (s.length === 1) {\n    return s[0] == null ? q[0].x : function() { return b; };\n  }\n\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return function(t) {\n    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateTransform = function(a, b) {\n  var s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n,\n      A = d3.transform(a),\n      B = d3.transform(b),\n      ta = A.translate,\n      tb = B.translate,\n      ra = A.rotate,\n      rb = B.rotate,\n      wa = A.skew,\n      wb = B.skew,\n      ka = A.scale,\n      kb = B.scale;\n\n  if (ta[0] != tb[0] || ta[1] != tb[1]) {\n    s.push(\"translate(\", null, \",\", null, \")\");\n    q.push({i: 1, x: d3.interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3.interpolateNumber(ta[1], tb[1])});\n  } else if (tb[0] || tb[1]) {\n    s.push(\"translate(\" + tb + \")\");\n  } else {\n    s.push(\"\");\n  }\n\n  if (ra != rb) {\n    if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360; // shortest path\n    q.push({i: s.push(s.pop() + \"rotate(\", null, \")\") - 2, x: d3.interpolateNumber(ra, rb)});\n  } else if (rb) {\n    s.push(s.pop() + \"rotate(\" + rb + \")\");\n  }\n\n  if (wa != wb) {\n    q.push({i: s.push(s.pop() + \"skewX(\", null, \")\") - 2, x: d3.interpolateNumber(wa, wb)});\n  } else if (wb) {\n    s.push(s.pop() + \"skewX(\" + wb + \")\");\n  }\n\n  if (ka[0] != kb[0] || ka[1] != kb[1]) {\n    n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\n    q.push({i: n - 4, x: d3.interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3.interpolateNumber(ka[1], kb[1])});\n  } else if (kb[0] != 1 || kb[1] != 1) {\n    s.push(s.pop() + \"scale(\" + kb + \")\");\n  }\n\n  n = q.length;\n  return function(t) {\n    var i = -1, o;\n    while (++i < n) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateRgb = function(a, b) {\n  a = d3.rgb(a);\n  b = d3.rgb(b);\n  var ar = a.r,\n      ag = a.g,\n      ab = a.b,\n      br = b.r - ar,\n      bg = b.g - ag,\n      bb = b.b - ab;\n  return function(t) {\n    return \"#\"\n        + d3_rgb_hex(Math.round(ar + br * t))\n        + d3_rgb_hex(Math.round(ag + bg * t))\n        + d3_rgb_hex(Math.round(ab + bb * t));\n  };\n};\n\n// interpolates HSL space, but outputs RGB string (for compatibility)\nd3.interpolateHsl = function(a, b) {\n  a = d3.hsl(a);\n  b = d3.hsl(b);\n  var h0 = a.h,\n      s0 = a.s,\n      l0 = a.l,\n      h1 = b.h - h0,\n      s1 = b.s - s0,\n      l1 = b.l - l0;\n  if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360; // shortest path\n  return function(t) {\n    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + \"\";\n  };\n};\n\nd3.interpolateLab = function(a, b) {\n  a = d3.lab(a);\n  b = d3.lab(b);\n  var al = a.l,\n      aa = a.a,\n      ab = a.b,\n      bl = b.l - al,\n      ba = b.a - aa,\n      bb = b.b - ab;\n  return function(t) {\n    return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n  };\n};\n\nd3.interpolateHcl = function(a, b) {\n  a = d3.hcl(a);\n  b = d3.hcl(b);\n  var ah = a.h,\n      ac = a.c,\n      al = a.l,\n      bh = b.h - ah,\n      bc = b.c - ac,\n      bl = b.l - al;\n  if (bh > 180) bh -= 360; else if (bh < -180) bh += 360; // shortest path\n  return function(t) {\n    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n  };\n};\n\nd3.interpolateArray = function(a, b) {\n  var x = [],\n      c = [],\n      na = a.length,\n      nb = b.length,\n      n0 = Math.min(a.length, b.length),\n      i;\n  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n  for (; i < na; ++i) c[i] = a[i];\n  for (; i < nb; ++i) c[i] = b[i];\n  return function(t) {\n    for (i = 0; i < n0; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nd3.interpolateObject = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n  for (k in a) {\n    if (k in b) {\n      i[k] = d3_interpolateByName(k)(a[k], b[k]);\n    } else {\n      c[k] = a[k];\n    }\n  }\n  for (k in b) {\n    if (!(k in a)) {\n      c[k] = b[k];\n    }\n  }\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n};\n\nvar d3_interpolate_number = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\n\nfunction d3_interpolateByName(name) {\n  return name == \"transform\"\n      ? d3.interpolateTransform\n      : d3.interpolate;\n}\n\nd3.interpolators = [\n  d3.interpolateObject,\n  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },\n  function(a, b) { return (typeof a === \"string\" || typeof b === \"string\") && d3.interpolateString(a + \"\", b + \"\"); },\n  function(a, b) { return (typeof b === \"string\" ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(a, b); },\n  function(a, b) { return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b); }\n];\nfunction d3_uninterpolateNumber(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return (x - a) * b; };\n}\n\nfunction d3_uninterpolateClamp(a, b) {\n  b = b - (a = +a) ? 1 / (b - a) : 0;\n  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };\n}\nd3.rgb = function(r, g, b) {\n  return arguments.length === 1\n      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)\n      : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb))\n      : d3_rgb(~~r, ~~g, ~~b);\n};\n\nfunction d3_rgb(r, g, b) {\n  return new d3_Rgb(r, g, b);\n}\n\nfunction d3_Rgb(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n}\n\nd3_Rgb.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  var r = this.r,\n      g = this.g,\n      b = this.b,\n      i = 30;\n  if (!r && !g && !b) return d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return d3_rgb(\n      Math.min(255, Math.floor(r / k)),\n      Math.min(255, Math.floor(g / k)),\n      Math.min(255, Math.floor(b / k)));\n};\n\nd3_Rgb.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_rgb(\n      Math.floor(k * this.r),\n      Math.floor(k * this.g),\n      Math.floor(k * this.b));\n};\n\nd3_Rgb.prototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\n\nd3_Rgb.prototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 0x10\n      ? \"0\" + Math.max(0, v).toString(16)\n      : Math.min(255, v).toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0, // red channel; int in [0, 255]\n      g = 0, // green channel; int in [0, 255]\n      b = 0, // blue channel; int in [0, 255]\n      m1, // CSS color specification match\n      m2, // CSS color specification type (e.g., rgb)\n      name;\n\n  /* Handle hsl, rgb. */\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\": {\n        return hsl(\n          parseFloat(m2[0]), // degrees\n          parseFloat(m2[1]) / 100, // percentage\n          parseFloat(m2[2]) / 100 // percentage\n        );\n      }\n      case \"rgb\": {\n        return rgb(\n          d3_rgb_parseNumber(m2[0]),\n          d3_rgb_parseNumber(m2[1]),\n          d3_rgb_parseNumber(m2[2])\n        );\n      }\n    }\n  }\n\n  /* Named colors. */\n  if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);\n\n  /* Hexadecimal colors: #rgb and #rrggbb. */\n  if (format != null && format.charAt(0) === \"#\") {\n    if (format.length === 4) {\n      r = format.charAt(1); r += r;\n      g = format.charAt(2); g += g;\n      b = format.charAt(3); b += b;\n    } else if (format.length === 7) {\n      r = format.substring(1, 3);\n      g = format.substring(3, 5);\n      b = format.substring(5, 7);\n    }\n    r = parseInt(r, 16);\n    g = parseInt(g, 16);\n    b = parseInt(b, 16);\n  }\n\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n      max = Math.max(r, g, b),\n      d = max - min,\n      h,\n      s,\n      l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    s = h = 0;\n  }\n  return d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_lab(r, g, b) {\n  r = d3_rgb_xyz(r);\n  g = d3_rgb_xyz(g);\n  b = d3_rgb_xyz(b);\n  var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X),\n      y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / d3_lab_Y),\n      z = d3_xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / d3_lab_Z);\n  return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n}\n\nfunction d3_rgb_xyz(r) {\n  return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n}\n\nfunction d3_rgb_parseNumber(c) { // either integer or percentage\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\n\nvar d3_rgb_names = d3.map({\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n});\n\nd3_rgb_names.forEach(function(key, value) {\n  d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));\n});\nd3.hsl = function(h, s, l) {\n  return arguments.length === 1\n      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)\n      : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl))\n      : d3_hsl(+h, +s, +l);\n};\n\nfunction d3_hsl(h, s, l) {\n  return new d3_Hsl(h, s, l);\n}\n\nfunction d3_Hsl(h, s, l) {\n  this.h = h;\n  this.s = s;\n  this.l = l;\n}\n\nd3_Hsl.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, this.l / k);\n};\n\nd3_Hsl.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, k * this.l);\n};\n\nd3_Hsl.prototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nd3_Hsl.prototype.toString = function() {\n  return this.rgb().toString();\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1,\n      m2;\n\n  /* Some simple corrections for h, s and l. */\n  h = h % 360; if (h < 0) h += 360;\n  s = s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n\n  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nd3.hcl = function(h, c, l) {\n  return arguments.length === 1\n      ? (h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l)\n      : (h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b)\n      : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b)))\n      : d3_hcl(+h, +c, +l);\n};\n\nfunction d3_hcl(h, c, l) {\n  return new d3_Hcl(h, c, l);\n}\n\nfunction d3_Hcl(h, c, l) {\n  this.h = h;\n  this.c = c;\n  this.l = l;\n}\n\nd3_Hcl.prototype.brighter = function(k) {\n  return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n};\n\nd3_Hcl.prototype.darker = function(k) {\n  return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n};\n\nd3_Hcl.prototype.rgb = function() {\n  return d3_hcl_lab(this.h, this.c, this.l).rgb();\n};\n\nd3_Hcl.prototype.toString = function() {\n  return this.rgb() + \"\";\n};\n\nfunction d3_hcl_lab(h, c, l) {\n  return d3_lab(l, Math.cos(h *= Math.PI / 180) * c, Math.sin(h) * c);\n}\nd3.lab = function(l, a, b) {\n  return arguments.length === 1\n      ? (l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b)\n      : (l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h)\n      : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b)))\n      : d3_lab(+l, +a, +b);\n};\n\nfunction d3_lab(l, a, b) {\n  return new d3_Lab(l, a, b);\n}\n\nfunction d3_Lab(l, a, b) {\n  this.l = l;\n  this.a = a;\n  this.b = b;\n}\n\n// Corresponds roughly to RGB brighter/darker\nvar d3_lab_K = 18;\n\n// D65 standard referent\nvar d3_lab_X = 0.950470,\n    d3_lab_Y = 1,\n    d3_lab_Z = 1.088830;\n\nd3_Lab.prototype.brighter = function(k) {\n  return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n};\n\nd3_Lab.prototype.darker = function(k) {\n  return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n};\n\nd3_Lab.prototype.rgb = function() {\n  return d3_lab_rgb(this.l, this.a, this.b);\n};\n\nd3_Lab.prototype.toString = function() {\n  return this.rgb() + \"\";\n};\n\nfunction d3_lab_rgb(l, a, b) {\n  var y = (l + 16) / 116,\n      x = y + a / 500,\n      z = y - b / 200;\n  x = d3_lab_xyz(x) * d3_lab_X;\n  y = d3_lab_xyz(y) * d3_lab_Y;\n  z = d3_lab_xyz(z) * d3_lab_Z;\n  return d3_rgb(\n    d3_xyz_rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z),\n    d3_xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n    d3_xyz_rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n  );\n}\n\nfunction d3_lab_hcl(l, a, b) {\n  return d3_hcl(Math.atan2(b, a) / Math.PI * 180, Math.sqrt(a * a + b * b), l);\n}\n\nfunction d3_lab_xyz(x) {\n  return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n}\nfunction d3_xyz_lab(x) {\n  return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n}\n\nfunction d3_xyz_rgb(r) {\n  return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));\n}\nfunction d3_selection(groups) {\n  d3_arraySubclass(groups, d3_selectionPrototype);\n  groups.enter = groups.exit = function() { return d3.select(); };\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectRoot = document.documentElement,\n    d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,\n    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nvar d3_selectionPrototype = [];\n\nd3.selection = function() {\n  return d3_selectionRoot;\n};\n\nd3.selection.prototype = d3_selectionPrototype;\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return function() {\n    return d3_select(selector, this);\n  };\n}\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return function() {\n    return d3_selectAll(selector, this);\n  };\n}\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3.ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3.ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = name.trim().split(/^|\\s+/g)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.className;\n        if (value.baseVal != null) value = value.baseVal;\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = name.trim().split(/\\s+/).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.className,\n        cb = c.baseVal != null,\n        cv = cb ? c.baseVal : c;\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(cv)) {\n        cv = d3_collapse(cv + \" \" + name);\n        if (cb) c.baseVal = cv;\n        else node.className = cv;\n      }\n    } else if (cv) {\n      cv = d3_collapse(cv.replace(re, \" \"));\n      if (cb) c.baseVal = cv;\n      else node.className = cv;\n    }\n  };\n}\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) return window\n        .getComputedStyle(this.node(), null)\n        .getPropertyValue(name);\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\nd3_selectionPrototype.text = function(value) {\n  return arguments.length < 1\n      ? this.node().textContent : this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; });\n};\nd3_selectionPrototype.html = function(value) {\n  return arguments.length < 1\n      ? this.node().innerHTML : this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; });\n};\n// TODO append(node)?\n// TODO append(function)?\nd3_selectionPrototype.append = function(name) {\n  name = d3.ns.qualify(name);\n\n  function append() {\n    return this.appendChild(document.createElementNS(this.namespaceURI, name));\n  }\n\n  function appendNS() {\n    return this.appendChild(document.createElementNS(name.space, name.local));\n  }\n\n  return this.select(name.local ? appendNS : append);\n};\n// TODO insert(node, function)?\n// TODO insert(function, string)?\n// TODO insert(function, function)?\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3.ns.qualify(name);\n\n  function insert() {\n    return this.insertBefore(\n        document.createElementNS(this.namespaceURI, name),\n        d3_select(before, this));\n  }\n\n  function insertNS() {\n    return this.insertBefore(\n        document.createElementNS(name.space, name.local),\n        d3_select(before, this));\n  }\n\n  return this.select(name.local ? insertNS : insert);\n};\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(function() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  });\n};\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        n1 = Math.max(n, m),\n        updateNodes = [],\n        enterNodes = [],\n        exitNodes = [],\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = [],\n          keyValue,\n          j = groupData.length;\n\n      for (i = -1; ++i < n;) {\n        keyValue = key.call(node = group[i], node.__data__, i);\n        if (nodeByKeyValue.has(keyValue)) {\n          exitNodes[j++] = node; // duplicate key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues.push(keyValue);\n      }\n\n      for (i = -1; ++i < m;) {\n        keyValue = key.call(groupData, nodeData = groupData[i], i)\n        if (nodeByKeyValue.has(keyValue)) {\n          updateNodes[i] = node = nodeByKeyValue.get(keyValue);\n          node.__data__ = nodeData;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n        nodeByKeyValue.remove(keyValue);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValues[i])) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n          enterNodes[i] = exitNodes[i] = null;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        updateNodes[i] = exitNodes[i] = null;\n      }\n      for (; i < n1; ++i) {\n        exitNodes[i] = group[i];\n        enterNodes[i] = updateNodes[i] = null;\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\nd3_selectionPrototype.datum =\nd3_selectionPrototype.map = function(value) {\n  return arguments.length < 1\n      ? this.property(\"__data__\")\n      : this.property(\"__data__\", value);\n};\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3.ascending;\n  return function(a, b) {\n    return comparator(a && a.__data__, b && b.__data__);\n  };\n}\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type, i = type.indexOf(\".\");\n  if (i > 0) type = type.substring(0, i);\n\n  function onRemove() {\n    var wrapper = this[name];\n    if (wrapper) {\n      this.removeEventListener(type, wrapper, wrapper.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var node = this,\n        args = arguments;\n\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);\n    wrapper._ = listener;\n\n    function wrapper(e) {\n      var o = d3.event; // Events can be reentrant (e.g., focus).\n      d3.event = e;\n      args[0] = node.__data__;\n      try {\n        listener.apply(node, args);\n      } finally {\n        d3.event = o;\n      }\n    }\n  }\n\n  return listener ? onAdd : onRemove;\n}\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n//\n// Note: assigning to the arguments array simultaneously changes the value of\n// the corresponding argument!\n//\n// TODO The `this` argument probably shouldn't be the first argument to the\n// callback, anyway, since it's redundant. However, that will require a major\n// version bump due to backwards compatibility, so I'm not changing it right\n// away.\n//\nd3_selectionPrototype.call = function(callback) {\n  callback.apply(this, (arguments[0] = this, arguments));\n  return this;\n};\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\nd3_selectionPrototype.node = function(callback) {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\nd3_selectionPrototype.transition = function() {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      subgroup.push((node = group[i]) ? {node: node, delay: d3_transitionDelay, duration: d3_transitionDuration} : null);\n    }\n  }\n\n  return d3_transition(subgroups, d3_transitionId || ++d3_transitionNextId, Date.now());\n};\nvar d3_selectionRoot = d3_selection([[document]]);\n\nd3_selectionRoot[0].parentNode = d3_selectRoot;\n\n// TODO fast singleton implementation!\n// TODO select(function)\nd3.select = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.select(selector)\n      : d3_selection([[selector]]); // assume node\n};\n\n// TODO selectAll(function)\nd3.selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_selectionRoot.selectAll(selector)\n      : d3_selection([d3_array(selector)]); // assume node[]\n};\nfunction d3_selection_enter(selection) {\n  d3_arraySubclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3.selection.enter = d3_selection_enter;\nd3.selection.enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\nfunction d3_transition(groups, id, time) {\n  d3_arraySubclass(groups, d3_transitionPrototype);\n\n  var tweens = new d3_Map,\n      event = d3.dispatch(\"start\", \"end\"),\n      ease = d3_transitionEase;\n\n  groups.id = id;\n\n  groups.time = time;\n\n  groups.tween = function(name, tween) {\n    if (arguments.length < 2) return tweens.get(name);\n    if (tween == null) tweens.remove(name);\n    else tweens.set(name, tween);\n    return groups;\n  };\n\n  groups.ease = function(value) {\n    if (!arguments.length) return ease;\n    ease = typeof value === \"function\" ? value : d3.ease.apply(d3, arguments);\n    return groups;\n  };\n\n  groups.each = function(type, listener) {\n    if (arguments.length < 2) return d3_transition_each.call(groups, type);\n    event.on(type, listener);\n    return groups;\n  };\n\n  d3.timer(function(elapsed) {\n    return d3_selection_each(groups, function(node, i, j) {\n      var tweened = [],\n          delay = node.delay,\n          duration = node.duration,\n          lock = (node = node.node).__transition__ || (node.__transition__ = {active: 0, count: 0}),\n          d = node.__data__;\n\n      ++lock.count;\n\n      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);\n\n      function start(elapsed) {\n        if (lock.active > id) return stop();\n        lock.active = id;\n\n        tweens.forEach(function(key, value) {\n          if (value = value.call(node, d, i)) {\n            tweened.push(value);\n          }\n        });\n\n        event.start.call(node, d, i);\n        if (!tick(elapsed)) d3.timer(tick, 0, time);\n        return 1;\n      }\n\n      function tick(elapsed) {\n        if (lock.active !== id) return stop();\n\n        var t = (elapsed - delay) / duration,\n            e = ease(t),\n            n = tweened.length;\n\n        while (n > 0) {\n          tweened[--n].call(node, e);\n        }\n\n        if (t >= 1) {\n          stop();\n          d3_transitionId = id;\n          event.end.call(node, d, i);\n          d3_transitionId = 0;\n          return 1;\n        }\n      }\n\n      function stop() {\n        if (!--lock.count) delete node.__transition__;\n        return 1;\n      }\n    });\n  }, 0, time);\n\n  return groups;\n}\n\nvar d3_transitionPrototype = [],\n    d3_transitionNextId = 0,\n    d3_transitionId = 0,\n    d3_transitionDefaultDelay = 0,\n    d3_transitionDefaultDuration = 250,\n    d3_transitionDefaultEase = d3.ease(\"cubic-in-out\"),\n    d3_transitionDelay = d3_transitionDefaultDelay,\n    d3_transitionDuration = d3_transitionDefaultDuration,\n    d3_transitionEase = d3_transitionDefaultEase;\n\nd3_transitionPrototype.call = d3_selectionPrototype.call;\n\nd3.transition = function(selection) {\n  return arguments.length\n      ? (d3_transitionId ? selection.transition() : selection)\n      : d3_selectionRoot.transition();\n};\n\nd3.transition.prototype = d3_transitionPrototype;\nd3_transitionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {\n        if (\"__data__\" in node.node) subnode.__data__ = node.node.__data__;\n        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n};\nd3_transitionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnodes,\n      node;\n\n  if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subnodes = selector.call(node.node, node.node.__data__, i);\n        subgroups.push(subgroup = []);\n        for (var k = -1, o = subnodes.length; ++k < o;) {\n          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});\n        }\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n};\nd3_transitionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node.node, node.node.__data__, i)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n};\nd3_transitionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to transition. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.attrTween(value, d3_tweenByName(name[value], value));\n    return this;\n  }\n\n  return this.attrTween(name, d3_tweenByName(value, name));\n};\n\nd3_transitionPrototype.attrTween = function(nameNS, tween) {\n  var name = d3.ns.qualify(nameNS);\n\n  function attrTween(d, i) {\n    var f = tween.call(this, d, i, this.getAttribute(name));\n    return f === d3_tweenRemove\n        ? (this.removeAttribute(name), null)\n        : f && function(t) { this.setAttribute(name, f(t)); };\n  }\n\n  function attrTweenNS(d, i) {\n    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n    return f === d3_tweenRemove\n        ? (this.removeAttributeNS(name.space, name.local), null)\n        : f && function(t) { this.setAttributeNS(name.space, name.local, f(t)); };\n  }\n\n  return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n};\nd3_transitionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.styleTween(priority, d3_tweenByName(name[priority], priority), value);\n      return this;\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.styleTween(name, d3_tweenByName(value, name), priority);\n};\n\nd3_transitionPrototype.styleTween = function(name, tween, priority) {\n  if (arguments.length < 3) priority = \"\";\n  return this.tween(\"style.\" + name, function(d, i) {\n    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));\n    return f === d3_tweenRemove\n        ? (this.style.removeProperty(name), null)\n        : f && function(t) { this.style.setProperty(name, f(t), priority); };\n  });\n};\nd3_transitionPrototype.text = function(value) {\n  return this.tween(\"text\", function(d, i) {\n    this.textContent = typeof value === \"function\"\n        ? value.call(this, d, i)\n        : value;\n  });\n};\nd3_transitionPrototype.remove = function() {\n  return this.each(\"end.transition\", function() {\n    var p;\n    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\n  });\n};\nd3_transitionPrototype.delay = function(value) {\n  return d3_selection_each(this, typeof value === \"function\"\n      ? function(node, i, j) { node.delay = value.call(node = node.node, node.__data__, i, j) | 0; }\n      : (value = value | 0, function(node) { node.delay = value; }));\n};\nd3_transitionPrototype.duration = function(value) {\n  return d3_selection_each(this, typeof value === \"function\"\n      ? function(node, i, j) { node.duration = Math.max(1, value.call(node = node.node, node.__data__, i, j) | 0); }\n      : (value = Math.max(1, value | 0), function(node) { node.duration = value; }));\n};\nfunction d3_transition_each(callback) {\n  var id = d3_transitionId,\n      ease = d3_transitionEase,\n      delay = d3_transitionDelay,\n      duration = d3_transitionDuration;\n\n  d3_transitionId = this.id;\n  d3_transitionEase = this.ease();\n  d3_selection_each(this, function(node, i, j) {\n    d3_transitionDelay = node.delay;\n    d3_transitionDuration = node.duration;\n    callback.call(node = node.node, node.__data__, i, j);\n  });\n\n  d3_transitionId = id;\n  d3_transitionEase = ease;\n  d3_transitionDelay = delay;\n  d3_transitionDuration = duration;\n  return this;\n}\nd3_transitionPrototype.transition = function() {\n  return this.select(d3_this);\n};\nd3.tween = function(b, interpolate) {\n\n  function tweenFunction(d, i, a) {\n    var v = b.call(this, d, i);\n    return v == null\n        ? a != \"\" && d3_tweenRemove\n        : a != v && interpolate(a, v);\n  }\n\n  function tweenString(d, i, a) {\n    return a != b && interpolate(a, b);\n  }\n\n  return typeof b === \"function\" ? tweenFunction\n      : b == null ? d3_tweenNull\n      : (b += \"\", tweenString);\n};\n\nvar d3_tweenRemove = {};\n\nfunction d3_tweenNull(d, i, a) {\n  return a != \"\" && d3_tweenRemove;\n}\n\nfunction d3_tweenByName(b, name) {\n  return d3.tween(b, d3_interpolateByName(name));\n}\nvar d3_timer_queue = null,\n    d3_timer_interval, // is an interval (or frame) active?\n    d3_timer_timeout; // is a timeout active?\n\n// The timer will continue to fire until callback returns true.\nd3.timer = function(callback, delay, then) {\n  var found = false,\n      t0,\n      t1 = d3_timer_queue;\n\n  if (arguments.length < 3) {\n    if (arguments.length < 2) delay = 0;\n    else if (!isFinite(delay)) return;\n    then = Date.now();\n  }\n\n  // See if the callback's already in the queue.\n  while (t1) {\n    if (t1.callback === callback) {\n      t1.then = then;\n      t1.delay = delay;\n      found = true;\n      break;\n    }\n    t0 = t1;\n    t1 = t1.next;\n  }\n\n  // Otherwise, add the callback to the queue.\n  if (!found) d3_timer_queue = {\n    callback: callback,\n    then: then,\n    delay: delay,\n    next: d3_timer_queue\n  };\n\n  // Start animatin'!\n  if (!d3_timer_interval) {\n    d3_timer_timeout = clearTimeout(d3_timer_timeout);\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nfunction d3_timer_step() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  var delay = d3_timer_flush() - now;\n  if (delay > 24) {\n    if (isFinite(delay)) {\n      clearTimeout(d3_timer_timeout);\n      d3_timer_timeout = setTimeout(d3_timer_step, delay);\n    }\n    d3_timer_interval = 0;\n  } else {\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nd3.timer.flush = function() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (!t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  d3_timer_flush();\n};\n\n// Flush after callbacks, to avoid concurrent queue modification.\nfunction d3_timer_flush() {\n  var t0 = null,\n      t1 = d3_timer_queue,\n      then = Infinity;\n  while (t1) {\n    if (t1.flush) {\n      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\n    } else {\n      then = Math.min(then, t1.then + t1.delay);\n      t1 = (t0 = t1).next;\n    }\n  }\n  return then;\n}\n\nvar d3_timer_frame = window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.oRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || function(callback) { setTimeout(callback, 17); };\nd3.mouse = function(container) {\n  return d3_mousePoint(container, d3_eventSource());\n};\n\n// https://bugs.webkit.org/show_bug.cgi?id=44083\nvar d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n\nfunction d3_mousePoint(container, e) {\n  var svg = container.ownerSVGElement || container;\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {\n      svg = d3.select(document.body)\n        .append(\"svg\")\n          .style(\"position\", \"absolute\")\n          .style(\"top\", 0)\n          .style(\"left\", 0);\n      var ctm = svg[0][0].getScreenCTM();\n      d3_mouse_bug44083 = !(ctm.f || ctm.e);\n      svg.remove();\n    }\n    if (d3_mouse_bug44083) {\n      point.x = e.pageX;\n      point.y = e.pageY;\n    } else {\n      point.x = e.clientX;\n      point.y = e.clientY;\n    }\n    point = point.matrixTransform(container.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n  var rect = container.getBoundingClientRect();\n  return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];\n};\nd3.touches = function(container, touches) {\n  if (arguments.length < 2) touches = d3_eventSource().touches;\n  return touches ? d3_array(touches).map(function(touch) {\n    var point = d3_mousePoint(container, touch);\n    point.identifier = touch.identifier;\n    return point;\n  }) : [];\n};\nfunction d3_noop() {}\nd3.scale = {};\n\nfunction d3_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction d3_scaleRange(scale) {\n  return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n}\nfunction d3_scale_nice(domain, nice) {\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      dx;\n\n  if (x1 < x0) {\n    dx = i0, i0 = i1, i1 = dx;\n    dx = x0, x0 = x1, x1 = dx;\n  }\n\n  if (nice = nice(x1 - x0)) {\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n  }\n\n  return domain;\n}\n\nfunction d3_scale_niceDefault() {\n  return Math;\n}\nd3.scale.linear = function() {\n  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);\n};\n\nfunction d3_scale_linear(domain, range, interpolate, clamp) {\n  var output,\n      input;\n\n  function rescale() {\n    var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,\n        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n    output = linear(domain, range, uninterpolate, interpolate);\n    input = linear(range, domain, uninterpolate, d3.interpolate);\n    return scale;\n  }\n\n  function scale(x) {\n    return output(x);\n  }\n\n  // Note: requires range is coercible to number!\n  scale.invert = function(y) {\n    return input(y);\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(Number);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.rangeRound = function(x) {\n    return scale.range(x).interpolate(d3.interpolateRound);\n  };\n\n  scale.clamp = function(x) {\n    if (!arguments.length) return clamp;\n    clamp = x;\n    return rescale();\n  };\n\n  scale.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolate = x;\n    return rescale();\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  scale.nice = function() {\n    d3_scale_nice(domain, d3_scale_linearNice);\n    return rescale();\n  };\n\n  scale.copy = function() {\n    return d3_scale_linear(domain, range, interpolate, clamp);\n  };\n\n  return rescale();\n}\n\nfunction d3_scale_linearRebind(scale, linear) {\n  return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n}\n\nfunction d3_scale_linearNice(dx) {\n  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n  return dx && {\n    floor: function(x) { return Math.floor(x / dx) * dx; },\n    ceil: function(x) { return Math.ceil(x / dx) * dx; }\n  };\n}\n\nfunction d3_scale_linearTickRange(domain, m) {\n  var extent = d3_scaleExtent(domain),\n      span = extent[1] - extent[0],\n      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n      err = m / span * step;\n\n  // Filter ticks to get closer to the desired count.\n  if (err <= .15) step *= 10;\n  else if (err <= .35) step *= 5;\n  else if (err <= .75) step *= 2;\n\n  // Round start and stop values to step interval.\n  extent[0] = Math.ceil(extent[0] / step) * step;\n  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive\n  extent[2] = step;\n  return extent;\n}\n\nfunction d3_scale_linearTicks(domain, m) {\n  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n}\n\nfunction d3_scale_linearTickFormat(domain, m) {\n  return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\n}\nfunction d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n  var u = uninterpolate(domain[0], domain[1]),\n      i = interpolate(range[0], range[1]);\n  return function(x) {\n    return i(u(x));\n  };\n}\nfunction d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n  var u = [],\n      i = [],\n      j = 0,\n      k = Math.min(domain.length, range.length) - 1;\n\n  // Handle descending domains.\n  if (domain[k] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++j <= k) {\n    u.push(uninterpolate(domain[j - 1], domain[j]));\n    i.push(interpolate(range[j - 1], range[j]));\n  }\n\n  return function(x) {\n    var j = d3.bisect(domain, x, 1, k) - 1;\n    return i[j](u[j](x));\n  };\n}\nd3.scale.log = function() {\n  return d3_scale_log(d3.scale.linear(), d3_scale_logp);\n};\n\nfunction d3_scale_log(linear, log) {\n  var pow = log.pow;\n\n  function scale(x) {\n    return linear(log(x));\n  }\n\n  scale.invert = function(x) {\n    return pow(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(pow);\n    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\n    pow = log.pow;\n    linear.domain(x.map(log));\n    return scale;\n  };\n\n  scale.nice = function() {\n    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n    return scale;\n  };\n\n  scale.ticks = function() {\n    var extent = d3_scaleExtent(linear.domain()),\n        ticks = [];\n    if (extent.every(isFinite)) {\n      var i = Math.floor(extent[0]),\n          j = Math.ceil(extent[1]),\n          u = pow(extent[0]),\n          v = pow(extent[1]);\n      if (log === d3_scale_logn) {\n        ticks.push(pow(i));\n        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n      } else {\n        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n        ticks.push(pow(i));\n      }\n      for (i = 0; ticks[i] < u; i++) {} // strip small values\n      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values\n      ticks = ticks.slice(i, j);\n    }\n    return ticks;\n  };\n\n  scale.tickFormat = function(n, format) {\n    if (arguments.length < 2) format = d3_scale_logFormat;\n    if (arguments.length < 1) return format;\n    var k = Math.max(.1, n / scale.ticks().length),\n        f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),\n        e,\n        h = (k >= 0.5);\n    // Always try to print the .5 tick text whenever possible, f.e.: 1,2,3,5 is better than 1,2,3,4.\n    // If you can do 1,2,3 you can also safely do 1,2,3,5.\n    // If you can do 1,2-and-a-bit you can also safely do 1,2,5.\n    // But 1,2 is better than 1,5 for very tight ticks in a log scale.\n    if (k < 0.5) {\n      if (k >= 0.4) {\n        k -= 0.1;\n        h = true;\n      } else if (k > 0.23) {\n        h = true;\n      }\n    }\n    return function(d) {\n      var r = d / pow(f(log(d) + e));\n      // round to two decimal places to uniquely pull out the half-way (.5) tick\n      // (floating point 'equals' comparisons are dangerous, so we make sure Math.round produces an integer result)\n      if (r <= k || (h && Math.round(200 * r) == 100))\n        return format(d);\n      return \"\";\n    };\n  };\n\n  scale.copy = function() {\n    return d3_scale_log(linear.copy(), log);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n}\n\nvar d3_scale_logFormat = d3.format(\".0E\");\n\nfunction d3_scale_logp(x) {\n  return Math.log(x < 0 ? 0 : x) / Math.LN10;\n}\n\nfunction d3_scale_logn(x) {\n  return -Math.log(x > 0 ? 0 : -x) / Math.LN10;\n}\n\nd3_scale_logp.pow = function(x) {\n  return Math.pow(10, x);\n};\n\nd3_scale_logn.pow = function(x) {\n  return -Math.pow(10, -x);\n};\nd3.scale.pow = function() {\n  return d3_scale_pow(d3.scale.linear(), 1);\n};\n\nfunction d3_scale_pow(linear, exponent) {\n  var powp = d3_scale_powPow(exponent),\n      powb = d3_scale_powPow(1 / exponent);\n\n  function scale(x) {\n    return linear(powp(x));\n  }\n\n  scale.invert = function(x) {\n    return powb(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(powb);\n    linear.domain(x.map(powp));\n    return scale;\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(scale.domain(), m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(scale.domain(), m);\n  };\n\n  scale.nice = function() {\n    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n  };\n\n  scale.exponent = function(x) {\n    if (!arguments.length) return exponent;\n    var domain = scale.domain();\n    powp = d3_scale_powPow(exponent = x);\n    powb = d3_scale_powPow(1 / exponent);\n    return scale.domain(domain);\n  };\n\n  scale.copy = function() {\n    return d3_scale_pow(linear.copy(), exponent);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n}\n\nfunction d3_scale_powPow(e) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n  };\n}\nd3.scale.sqrt = function() {\n  return d3.scale.pow().exponent(.5);\n};\nd3.scale.ordinal = function() {\n  return d3_scale_ordinal([], {t: \"range\", a: [[]]});\n};\n\nfunction d3_scale_ordinal(domain, ranger) {\n  var index,\n      range,\n      rangeBand;\n\n  function scale(x) {\n    return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];\n  }\n\n  function steps(start, step) {\n    return d3.range(domain.length).map(function(i) { return start + step * i; });\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = [];\n    index = new d3_Map;\n    var i = -1, n = x.length, xi;\n    while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n    return scale[ranger.t].apply(scale, ranger.a);\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    rangeBand = 0;\n    ranger = {t: \"range\", a: arguments};\n    return scale;\n  };\n\n  scale.rangePoints = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (Math.max(1, domain.length - 1) + padding);\n    range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);\n    rangeBand = 0;\n    ranger = {t: \"rangePoints\", a: arguments};\n    return scale;\n  };\n\n  scale.rangeBands = function(x, padding, outerPadding) {\n    if (arguments.length < 2) padding = 0;\n    if (arguments.length < 3) outerPadding = padding;\n    var reverse = x[1] < x[0],\n        start = x[reverse - 0],\n        stop = x[1 - reverse],\n        step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n    range = steps(start + step * outerPadding, step);\n    if (reverse) range.reverse();\n    rangeBand = step * (1 - padding);\n    ranger = {t: \"rangeBands\", a: arguments};\n    return scale;\n  };\n\n  scale.rangeRoundBands = function(x, padding, outerPadding) {\n    if (arguments.length < 2) padding = 0;\n    if (arguments.length < 3) outerPadding = padding;\n    var reverse = x[1] < x[0],\n        start = x[reverse - 0],\n        stop = x[1 - reverse],\n        step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)),\n        error = stop - start - (domain.length - padding) * step;\n    range = steps(start + Math.round(error / 2), step);\n    if (reverse) range.reverse();\n    rangeBand = Math.round(step * (1 - padding));\n    ranger = {t: \"rangeRoundBands\", a: arguments};\n    return scale;\n  };\n\n  scale.rangeBand = function() {\n    return rangeBand;\n  };\n\n  scale.rangeExtent = function() {\n    return d3_scaleExtent(ranger.a[0]);\n  };\n\n  scale.copy = function() {\n    return d3_scale_ordinal(domain, ranger);\n  };\n\n  return scale.domain(domain);\n}\n/*\n * This product includes color specifications and designs developed by Cynthia\n * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.\n */\n\nd3.scale.category10 = function() {\n  return d3.scale.ordinal().range(d3_category10);\n};\n\nd3.scale.category20 = function() {\n  return d3.scale.ordinal().range(d3_category20);\n};\n\nd3.scale.category20b = function() {\n  return d3.scale.ordinal().range(d3_category20b);\n};\n\nd3.scale.category20c = function() {\n  return d3.scale.ordinal().range(d3_category20c);\n};\n\nvar d3_category10 = [\n  \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n  \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"\n];\n\nvar d3_category20 = [\n  \"#1f77b4\", \"#aec7e8\",\n  \"#ff7f0e\", \"#ffbb78\",\n  \"#2ca02c\", \"#98df8a\",\n  \"#d62728\", \"#ff9896\",\n  \"#9467bd\", \"#c5b0d5\",\n  \"#8c564b\", \"#c49c94\",\n  \"#e377c2\", \"#f7b6d2\",\n  \"#7f7f7f\", \"#c7c7c7\",\n  \"#bcbd22\", \"#dbdb8d\",\n  \"#17becf\", \"#9edae5\"\n];\n\nvar d3_category20b = [\n  \"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\",\n  \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\",\n  \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\",\n  \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\",\n  \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\"\n];\n\nvar d3_category20c = [\n  \"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\",\n  \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\",\n  \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\",\n  \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\",\n  \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\"\n];\nd3.scale.quantile = function() {\n  return d3_scale_quantile([], []);\n};\n\nfunction d3_scale_quantile(domain, range) {\n  var thresholds;\n\n  function rescale() {\n    var k = 0,\n        n = domain.length,\n        q = range.length;\n    thresholds = [];\n    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n    return scale;\n  }\n\n  function scale(x) {\n    if (isNaN(x = +x)) return NaN;\n    return range[d3.bisect(thresholds, x)];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.quantiles = function() {\n    return thresholds;\n  };\n\n  scale.ticks = function(m) {\n    return thresholds;\n  };\n\n  scale.copy = function() {\n    return d3_scale_quantile(domain, range); // copy on write!\n  };\n\n  return rescale();\n}\nd3.scale.quantize = function() {\n  return d3_scale_quantize(0, 1, [0, 1]);\n};\n\nfunction d3_scale_quantize(x0, x1, range) {\n  var kx, i;\n\n  function scale(x) {\n    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n  }\n\n  function rescale() {\n    kx = range.length / (x1 - x0);\n    i = range.length - 1;\n    return scale;\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return [x0, x1];\n    x0 = +x[0];\n    x1 = +x[x.length - 1];\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.ticks = function(m) {\n    if (i <= 0) return [];\n    // produce nice tick values (erase the long decimal tails due to floating point calc inaccuracy),\n    // x1 is not inclusive\n    return d3.range(x0, x1 - 0.5 / kx, 1.0 / kx).map(function(x, i) {\n      // heuristic: round to 3 extra digits to remove FP calc inaccuracy\n      var p = d3_format_precision(x, 4);\n      var v = d3.round(x, p);\n      return v;\n    });\n  };\n\n  scale.rangeBand = function() {\n    return kx;\n  }\n\n  scale.copy = function() {\n    return d3_scale_quantize(x0, x1, range); // copy on write\n  };\n\n  return rescale();\n}\nd3.scale.threshold = function() {\n  return d3_scale_threshold([.5], [0, 1]);\n};\n\nfunction d3_scale_threshold(domain, range) {\n\n  function scale(x) {\n    // ASSUMPTION: domain.length == range.length - 1\n    return range[d3.bisect(domain, x)];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain;\n    domain = _;\n    return scale;\n  };\n\n  scale.range = function(_) {\n    if (!arguments.length) return range;\n    range = _;\n    return scale;\n  };\n\n  scale.ticks = function(m) {\n    var l = Math.min(domain.length, range.length - 1);\n    if (l > 0) {\n      var t = [], i;\n      t.push(+domain[0] - 1);\n      for (i = 1; i < l; i++) {\n        t.push((+domain[i] + +domain[i - 1]) / 2);\n      }\n      t.push(+domain[l - 1] + 1);\n      return t;\n    }\n    return [];\n  };\n\n  scale.copy = function() {\n    return d3_scale_threshold(domain, range);\n  };\n\n  return scale;\n};\nd3.scale.identity = function() {\n  return d3_scale_identity([0, 1]);\n};\n\nfunction d3_scale_identity(domain) {\n\n  function identity(x) { return +x; }\n\n  identity.invert = identity;\n\n  identity.domain = identity.range = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(identity);\n    return identity;\n  };\n\n  identity.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  identity.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  identity.copy = function() {\n    return d3_scale_identity(domain);\n  };\n\n  return identity;\n}\nd3.svg = {};\nd3.svg.arc = function() {\n  var innerRadius = d3_svg_arcInnerRadius,\n      outerRadius = d3_svg_arcOuterRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  function arc() {\n    var r0 = innerRadius.apply(this, arguments),\n        r1 = outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),\n        df = da < Math.PI ? \"0\" : \"1\",\n        c0 = Math.cos(a0),\n        s0 = Math.sin(a0),\n        c1 = Math.cos(a1),\n        s1 = Math.sin(a1);\n    return da >= d3_svg_arcMax\n      ? (r0\n      ? \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"M0,\" + r0\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + (-r0)\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0\n      + \"Z\"\n      : \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"Z\")\n      : (r0\n      ? \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L\" + r0 * c1 + \",\" + r0 * s1\n      + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0\n      + \"Z\"\n      : \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L0,0\"\n      + \"Z\");\n  }\n\n  arc.innerRadius = function(v) {\n    if (!arguments.length) return innerRadius;\n    innerRadius = d3_functor(v);\n    return arc;\n  };\n\n  arc.outerRadius = function(v) {\n    if (!arguments.length) return outerRadius;\n    outerRadius = d3_functor(v);\n    return arc;\n  };\n\n  arc.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3_functor(v);\n    return arc;\n  };\n\n  arc.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3_functor(v);\n    return arc;\n  };\n\n  arc.centroid = function() {\n    var r = (innerRadius.apply(this, arguments)\n        + outerRadius.apply(this, arguments)) / 2,\n        a = (startAngle.apply(this, arguments)\n        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\n    return [Math.cos(a) * r, Math.sin(a) * r];\n  };\n\n  return arc;\n};\n\nvar d3_svg_arcOffset = -Math.PI / 2,\n    d3_svg_arcMax = 2 * Math.PI - 1e-6;\n\nfunction d3_svg_arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction d3_svg_arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction d3_svg_arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction d3_svg_line(projection) {\n  var x = d3_svg_lineX,\n      y = d3_svg_lineY,\n      defined = d3_true,\n      interpolate = d3_svg_lineLinear,\n      interpolateKey = interpolate.key,\n      tension = .7;\n\n  function line(data) {\n    var segments = [],\n        points = [],\n        i = -1,\n        n = data.length,\n        d,\n        fx = d3_functor(x),\n        fy = d3_functor(y);\n\n    function segment() {\n      segments.push(\"M\", interpolate(projection(points), tension));\n    }\n\n    while (++i < n) {\n      if (defined.call(this, d = data[i], i)) {\n        points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);\n      } else if (points.length) {\n        segment();\n        points = [];\n      }\n    }\n\n    if (points.length) segment();\n\n    return segments.length ? segments.join(\"\") : null;\n  }\n\n  line.x = function(_) {\n    if (!arguments.length) return x;\n    x = _;\n    return line;\n  };\n\n  line.y = function(_) {\n    if (!arguments.length) return y;\n    y = _;\n    return line;\n  };\n\n  line.defined  = function(_) {\n    if (!arguments.length) return defined;\n    defined = _;\n    return line;\n  };\n\n  line.interpolate = function(_) {\n    if (!arguments.length) return interpolateKey;\n    if (typeof _ === \"function\") interpolateKey = interpolate = _;\n    else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n    return line;\n  };\n\n  line.tension = function(_) {\n    if (!arguments.length) return tension;\n    tension = _;\n    return line;\n  };\n\n  return line;\n}\n\nd3.svg.line = function() {\n  return d3_svg_line(d3_identity);\n};\n\n// The default `x` property, which references d[0].\nfunction d3_svg_lineX(d) {\n  return d[0];\n}\n\n// The default `y` property, which references d[1].\nfunction d3_svg_lineY(d) {\n  return d[1];\n}\n\n// The various interpolators supported by the `line` class.\nvar d3_svg_lineInterpolators = d3.map({\n  \"linear\": d3_svg_lineLinear,\n  \"linear-closed\": d3_svg_lineLinearClosed,\n  \"step-before\": d3_svg_lineStepBefore,\n  \"step-after\": d3_svg_lineStepAfter,\n  \"basis\": d3_svg_lineBasis,\n  \"basis-open\": d3_svg_lineBasisOpen,\n  \"basis-closed\": d3_svg_lineBasisClosed,\n  \"bundle\": d3_svg_lineBundle,\n  \"cardinal\": d3_svg_lineCardinal,\n  \"cardinal-open\": d3_svg_lineCardinalOpen,\n  \"cardinal-closed\": d3_svg_lineCardinalClosed,\n  \"monotone\": d3_svg_lineMonotone\n});\n\nd3_svg_lineInterpolators.forEach(function(key, value) {\n  value.key = key;\n  value.closed = /-closed$/.test(key);\n});\n\n// Linear interpolation; generates \"L\" commands.\nfunction d3_svg_lineLinear(points) {\n  return points.join(\"L\");\n}\n\nfunction d3_svg_lineLinearClosed(points) {\n  return d3_svg_lineLinear(points) + \"Z\";\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepBefore(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepAfter(points) {\n  var i = 0,\n      n = points.length,\n      p = points[0],\n      path = [p[0], \",\", p[1]];\n  while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n  return path.join(\"\");\n}\n\n// Open cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalOpen(points, tension) {\n  return points.length < 4\n      ? d3_svg_lineLinear(points)\n      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Closed cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalClosed(points, tension) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),\n        d3_svg_lineCardinalTangents([points[points.length - 2]]\n        .concat(points, [points[1]]), tension));\n}\n\n// Cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinal(points, tension, closed) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineCubicPolynomialSpline(points,\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Hermite spline construction; generates \"C\" commands.\nfunction d3_svg_lineHermite(points, tangents) {\n  if (tangents.length < 1\n      || (points.length != tangents.length\n      && points.length != tangents.length + 2)) {\n    return d3_svg_lineLinear(points);\n  }\n\n  var quad = points.length != tangents.length,\n      path = \"\",\n      p0 = points[0],\n      p = points[1],\n      t0 = tangents[0],\n      t = t0,\n      pi = 1;\n\n  if (quad) {\n    path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3)\n        + \",\" + p[0] + \",\" + p[1];\n    p0 = points[1];\n    pi = 2;\n  }\n\n  if (tangents.length > 1) {\n    t = tangents[1];\n    p = points[pi];\n    pi++;\n    path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1])\n        + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n        + \",\" + p[0] + \",\" + p[1];\n    for (var i = 2; i < tangents.length; i++, pi++) {\n      p = points[pi];\n      t = tangents[i];\n      path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n          + \",\" + p[0] + \",\" + p[1];\n    }\n  }\n\n  if (quad) {\n    var lp = points[pi];\n    path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3)\n        + \",\" + lp[0] + \",\" + lp[1];\n  }\n\n  return path;\n}\n\n// Cubic polynomial spline construction; generates \"C\" commands.\nfunction d3_svg_lineCubicPolynomialSpline(points, tangents) {\n  if (tangents.length < 1\n      || (points.length != tangents.length\n      && points.length != tangents.length + 2)) {\n    return d3_svg_lineLinear(points);\n  }\n\n  var quad = points.length != tangents.length,\n      path = \"\",\n      p0 = points[0],\n      p = points[1],\n      t0 = tangents[0],\n      t = t0,\n      pi = 0,\n      dx = points[1][0] - points[0][0],\n      tp, pp;\n\n  if (quad) {\n    path += \"Q\" + (p[0] - (dx / 2)) + \",\" + (p[1] - t0[1]/t0[0] * (dx / 2))\n        + \",\" + p[0] + \",\" + p[1];\n    p0 = points[1];\n    pi = 1;\n  }\n\n  if (tangents.length > 1) {\n    tp = tangents[0];\n    pp = points[pi];\n    pi++;\n    for (var i = 1; i < tangents.length; i++, pi++) {\n      p = points[pi]; t = tangents[i];\n      dx = p[0] - pp[0];\n      path += \"C\" + (pp[0] + (dx / 3)) + \",\" + (pp[1] + (tp[1]/tp[0]) * (dx / 3))\n        + \",\" + (p[0] - (dx / 3)) + \",\" + (p[1] - (t[1]/t[0]) * (dx / 3))\n        + \",\" + p[0] + \",\" + p[1];\n      pp = p; tp = t;\n    }\n  }\n\n  if (quad) {\n    var lp = points[pi];\n    dx = lp[0] - p[0];\n    path += \"Q\" + (p[0] + (dx / 2)) + \",\" + (p[1] + t[1]/t[0] * (dx / 2))\n        + \",\" + lp[0] + \",\" + lp[1];\n  }\n\n  return path;\n}\n\n// Generates tangents for a cardinal spline.\nfunction d3_svg_lineCardinalTangents(points, tension) {\n  var tangents = [],\n      a = (1 - tension) / 2,\n      p0,\n      p1 = points[0],\n      p2 = points[1],\n      i = 1,\n      n = points.length;\n  while (++i < n) {\n    p0 = p1;\n    p1 = p2;\n    p2 = points[i];\n    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n  }\n  return tangents;\n}\n\n// B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasis(points) {\n  if (points.length < 3) return d3_svg_lineLinear(points);\n  var i = 1,\n      n = points.length,\n      pi = points[0],\n      x0 = pi[0],\n      y0 = pi[1],\n      px = [x0, x0, x0, (pi = points[1])[0]],\n      py = [y0, y0, y0, pi[1]],\n      path = [x0, \",\", y0];\n  d3_svg_lineBasisBezier(path, px, py);\n  while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  i = -1;\n  while (++i < 2) {\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Open B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisOpen(points) {\n  if (points.length < 4) return d3_svg_lineLinear(points);\n  var path = [],\n      i = -1,\n      n = points.length,\n      pi,\n      px = [0],\n      py = [0];\n  while (++i < 3) {\n    pi = points[i];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)\n    + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n  --i; while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Closed B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisClosed(points) {\n  var path,\n      i = -1,\n      n = points.length,\n      m = n + 4,\n      pi,\n      px = [],\n      py = [];\n  while (++i < 4) {\n    pi = points[i % n];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path = [\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\",\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)\n  ];\n  --i; while (++i < m) {\n    pi = points[i % n];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\nfunction d3_svg_lineBundle(points, tension) {\n  var n = points.length - 1;\n  if (n) {\n    var x0 = points[0][0],\n        y0 = points[0][1],\n        dx = points[n][0] - x0,\n        dy = points[n][1] - y0,\n        i = -1,\n        p,\n        t;\n    while (++i <= n) {\n      p = points[i];\n      t = i / n;\n      p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n      p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n    }\n  }\n  return d3_svg_lineBasis(points);\n}\n\n// Returns the dot product of the given four-element vectors.\nfunction d3_svg_lineDot4(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n// Matrix to transform basis (b-spline) control points to bezier\n// control points. Derived from FvD 11.2.8.\nvar d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],\n    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],\n    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];\n\n// Pushes a \"C\" Bézier curve onto the specified path array, given the\n// two specified four-element arrays which define the control points.\nfunction d3_svg_lineBasisBezier(path, x, y) {\n  path.push(\n      \"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n}\n\n// Computes the slope from points p0 to p1.\nfunction d3_svg_lineSlope(p0, p1) {\n  return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n}\n\n// Compute three-point differences for the given points.\n// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference\nfunction d3_svg_lineFiniteDifferences(points) {\n  var i = 0,\n      j = points.length - 1,\n      m = [],\n      p0 = points[0],\n      p1 = points[1],\n      d = m[0] = d3_svg_lineSlope(p0, p1);\n  while (++i < j) {\n    m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n  }\n  m[i] = d;\n  return m;\n}\n\n// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite\n// interpolation. Returns an array of tangent vectors. For details, see\n// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation\nfunction d3_svg_lineMonotoneTangents(points) {\n  var tangents = [],\n      d,\n      a,\n      b,\n      s,\n      m = d3_svg_lineFiniteDifferences(points),\n      i = -1,\n      j = points.length - 1;\n\n  // The first two steps are done by computing finite-differences:\n  // 1. Compute the slopes of the secant lines between successive points.\n  // 2. Initialize the tangents at every point as the average of the secants.\n\n  // Then, for each segment…\n  while (++i < j) {\n    d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set\n    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to\n    // preserve monotonicity. Ignore step 4 and 5 for those k.\n\n    if (Math.abs(d) < 1e-6) {\n      m[i] = m[i + 1] = 0;\n    } else {\n      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.\n      a = m[i] / d;\n      b = m[i + 1] / d;\n\n      // 5. Prevent overshoot and ensure monotonicity by restricting the\n      // magnitude of vector <ak, bk> to a circle of radius 3.\n      s = a * a + b * b;\n      if (s > 9) {\n        s = d * 3 / Math.sqrt(s);\n        m[i] = s * a;\n        m[i + 1] = s * b;\n      }\n    }\n  }\n\n  // Compute the normalized tangent vector from the slopes. Note that if x is\n  // not monotonic, it's possible that the slope will be infinite, so we protect\n  // against NaN by setting the coordinate to zero.\n  i = -1; while (++i <= j) {\n    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n    tangents.push([s || 0, m[i] * s || 0]);\n  }\n\n  return tangents;\n}\n\nfunction d3_svg_lineMonotone(points) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineCubicPolynomialSpline(points, d3_svg_lineMonotoneTangents(points));\n}\nd3.svg.line.radial = function() {\n  var line = d3_svg_line(d3_svg_lineRadial);\n  line.radius = line.x, delete line.x;\n  line.angle = line.y, delete line.y;\n  return line;\n};\n\nfunction d3_svg_lineRadial(points) {\n  var point,\n      i = -1,\n      n = points.length,\n      r,\n      a;\n  while (++i < n) {\n    point = points[i];\n    r = point[0];\n    a = point[1] + d3_svg_arcOffset;\n    point[0] = r * Math.cos(a);\n    point[1] = r * Math.sin(a);\n  }\n  return points;\n}\nfunction d3_svg_area(projection) {\n  var x0 = d3_svg_lineX,\n      x1 = d3_svg_lineX,\n      y0 = 0,\n      y1 = d3_svg_lineY,\n      defined = d3_true,\n      interpolate = d3_svg_lineLinear,\n      interpolateKey = interpolate.key,\n      interpolateReverse = interpolate,\n      L = \"L\",\n      tension = .7;\n\n  function area(data) {\n    var segments = [],\n        points0 = [],\n        points1 = [],\n        i = -1,\n        n = data.length,\n        d,\n        fx0 = d3_functor(x0),\n        fy0 = d3_functor(y0),\n        fx1 = x0 === x1 ? function() { return x; } : d3_functor(x1),\n        fy1 = y0 === y1 ? function() { return y; } : d3_functor(y1),\n        x,\n        y;\n\n    function segment() {\n      segments.push(\"M\", interpolate(projection(points1), tension),\n          L, interpolateReverse(projection(points0.reverse()), tension),\n          \"Z\");\n    }\n\n    while (++i < n) {\n      if (defined.call(this, d = data[i], i)) {\n        points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);\n        points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);\n      } else if (points0.length) {\n        segment();\n        points0 = [];\n        points1 = [];\n      }\n    }\n\n    if (points0.length) segment();\n\n    return segments.length ? segments.join(\"\") : null;\n  }\n\n  area.x = function(_) {\n    if (!arguments.length) return x1;\n    x0 = x1 = _;\n    return area;\n  };\n\n  area.x0 = function(_) {\n    if (!arguments.length) return x0;\n    x0 = _;\n    return area;\n  };\n\n  area.x1 = function(_) {\n    if (!arguments.length) return x1;\n    x1 = _;\n    return area;\n  };\n\n  area.y = function(_) {\n    if (!arguments.length) return y1;\n    y0 = y1 = _;\n    return area;\n  };\n\n  area.y0 = function(_) {\n    if (!arguments.length) return y0;\n    y0 = _;\n    return area;\n  };\n\n  area.y1 = function(_) {\n    if (!arguments.length) return y1;\n    y1 = _;\n    return area;\n  };\n\n  area.defined  = function(_) {\n    if (!arguments.length) return defined;\n    defined = _;\n    return area;\n  };\n\n  area.interpolate = function(_) {\n    if (!arguments.length) return interpolateKey;\n    if (typeof _ === \"function\") interpolateKey = interpolate = _;\n    else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n    interpolateReverse = interpolate.reverse || interpolate;\n    L = interpolate.closed ? \"M\" : \"L\";\n    return area;\n  };\n\n  area.tension = function(_) {\n    if (!arguments.length) return tension;\n    tension = _;\n    return area;\n  };\n\n  return area;\n}\n\nd3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\nd3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n\nd3.svg.area = function() {\n  return d3_svg_area(d3_identity);\n};\nd3.svg.area.radial = function() {\n  var area = d3_svg_area(d3_svg_lineRadial);\n  area.radius = area.x, delete area.x;\n  area.innerRadius = area.x0, delete area.x0;\n  area.outerRadius = area.x1, delete area.x1;\n  area.angle = area.y, delete area.y;\n  area.startAngle = area.y0, delete area.y0;\n  area.endAngle = area.y1, delete area.y1;\n  return area;\n};\nd3.svg.chord = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      radius = d3_svg_chordRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  // TODO Allow control point to be customized.\n\n  function chord(d, i) {\n    var s = subgroup(this, source, d, i),\n        t = subgroup(this, target, d, i);\n    return \"M\" + s.p0\n      + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)\n      ? curve(s.r, s.p1, s.r, s.p0)\n      : curve(s.r, s.p1, t.r, t.p0)\n      + arc(t.r, t.p1, t.a1 - t.a0)\n      + curve(t.r, t.p1, s.r, s.p0))\n      + \"Z\";\n  }\n\n  function subgroup(self, f, d, i) {\n    var subgroup = f.call(self, d, i),\n        r = radius.call(self, subgroup, i),\n        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n    return {\n      r: r,\n      a0: a0,\n      a1: a1,\n      p0: [r * Math.cos(a0), r * Math.sin(a0)],\n      p1: [r * Math.cos(a1), r * Math.sin(a1)]\n    };\n  }\n\n  function equals(a, b) {\n    return a.a0 == b.a0 && a.a1 == b.a1;\n  }\n\n  function arc(r, p, a) {\n    return \"A\" + r + \",\" + r + \" 0 \" + +(a > Math.PI) + \",1 \" + p;\n  }\n\n  function curve(r0, p0, r1, p1) {\n    return \"Q 0,0 \" + p1;\n  }\n\n  chord.radius = function(v) {\n    if (!arguments.length) return radius;\n    radius = d3_functor(v);\n    return chord;\n  };\n\n  chord.source = function(v) {\n    if (!arguments.length) return source;\n    source = d3_functor(v);\n    return chord;\n  };\n\n  chord.target = function(v) {\n    if (!arguments.length) return target;\n    target = d3_functor(v);\n    return chord;\n  };\n\n  chord.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3_functor(v);\n    return chord;\n  };\n\n  chord.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3_functor(v);\n    return chord;\n  };\n\n  return chord;\n};\n\nfunction d3_svg_chordSource(d) {\n  return d.source;\n}\n\nfunction d3_svg_chordTarget(d) {\n  return d.target;\n}\n\nfunction d3_svg_chordRadius(d) {\n  return d.radius;\n}\n\nfunction d3_svg_chordStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_chordEndAngle(d) {\n  return d.endAngle;\n}\nd3.svg.diagonal = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      projection = d3_svg_diagonalProjection;\n\n  function diagonal(d, i) {\n    var p0 = source.call(this, d, i),\n        p3 = target.call(this, d, i),\n        m = (p0.y + p3.y) / 2,\n        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];\n    p = p.map(projection);\n    return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n  }\n\n  diagonal.source = function(x) {\n    if (!arguments.length) return source;\n    source = d3_functor(x);\n    return diagonal;\n  };\n\n  diagonal.target = function(x) {\n    if (!arguments.length) return target;\n    target = d3_functor(x);\n    return diagonal;\n  };\n\n  diagonal.projection = function(x) {\n    if (!arguments.length) return projection;\n    projection = x;\n    return diagonal;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalProjection(d) {\n  return [d.x, d.y];\n}\nd3.svg.diagonal.radial = function() {\n  var diagonal = d3.svg.diagonal(),\n      projection = d3_svg_diagonalProjection,\n      projection_ = diagonal.projection;\n\n  diagonal.projection = function(x) {\n    return arguments.length\n        ? projection_(d3_svg_diagonalRadialProjection(projection = x))\n        : projection;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalRadialProjection(projection) {\n  return function() {\n    var d = projection.apply(this, arguments),\n        r = d[0],\n        a = d[1] + d3_svg_arcOffset;\n    return [r * Math.cos(a), r * Math.sin(a)];\n  };\n}\nd3.svg.mouse = d3.mouse;\nd3.svg.touches = d3.touches;\nd3.svg.symbol = function() {\n  var type = d3_svg_symbolType,\n      size = d3_svg_symbolSize;\n\n  function symbol(d, i) {\n    return (d3_svg_symbols.get(type.call(this, d, i))\n        || d3_svg_symbolCircle)\n        (size.call(this, d, i));\n  }\n\n  symbol.type = function(x) {\n    if (!arguments.length) return type;\n    type = d3_functor(x);\n    return symbol;\n  };\n\n  // size of symbol in square pixels\n  symbol.size = function(x) {\n    if (!arguments.length) return size;\n    size = d3_functor(x);\n    return symbol;\n  };\n\n  return symbol;\n};\n\nfunction d3_svg_symbolSize() {\n  return 64;\n}\n\nfunction d3_svg_symbolType() {\n  return \"circle\";\n}\n\nfunction d3_svg_symbolCircle(size) {\n  var r = Math.sqrt(size / Math.PI);\n  return \"M0,\" + r\n      + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r)\n      + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r\n      + \"Z\";\n}\n\n// TODO cross-diagonal?\nvar d3_svg_symbols = d3.map({\n  \"circle\": d3_svg_symbolCircle,\n  \"cross\": function(size) {\n    var r = Math.sqrt(size / 5) / 2;\n    return \"M\" + -3 * r + \",\" + -r\n        + \"H\" + -r\n        + \"V\" + -3 * r\n        + \"H\" + r\n        + \"V\" + -r\n        + \"H\" + 3 * r\n        + \"V\" + r\n        + \"H\" + r\n        + \"V\" + 3 * r\n        + \"H\" + -r\n        + \"V\" + r\n        + \"H\" + -3 * r\n        + \"Z\";\n  },\n  \"diamond\": function(size) {\n    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n        rx = ry * d3_svg_symbolTan30;\n    return \"M0,\" + -ry\n        + \"L\" + rx + \",0\"\n        + \" 0,\" + ry\n        + \" \" + -rx + \",0\"\n        + \"Z\";\n  },\n  \"square\": function(size) {\n    var r = Math.sqrt(size) / 2;\n    return \"M\" + -r + \",\" + -r\n        + \"L\" + r + \",\" + -r\n        + \" \" + r + \",\" + r\n        + \" \" + -r + \",\" + r\n        + \"Z\";\n  },\n  \"triangle-down\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + ry\n        + \"L\" + rx +\",\" + -ry\n        + \" \" + -rx + \",\" + -ry\n        + \"Z\";\n  },\n  \"triangle-up\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + -ry\n        + \"L\" + rx +\",\" + ry\n        + \" \" + -rx + \",\" + ry\n        + \"Z\";\n  }\n});\n\nd3.svg.symbolTypes = d3_svg_symbols.keys();\n\nvar d3_svg_symbolSqrt3 = Math.sqrt(3),\n    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);\nd3.svg.axis = function() {\n  var scale = d3.scale.linear(),\n      orient = \"bottom\",\n      tickMajorSize = d3_functor(6),\n      tickMinorSize = d3_functor(6),\n      tickEndSize = d3_functor(6),\n      tickPadding = 3,\n      tickArguments_ = [10],\n      tickValues = null,\n      tickFormat_ = null,\n      tickFormatExtended_,\n      tickFilter = d3_functor(true),\n      tickSubdivide = null;\n\n  function axis(g) {\n    // Ticks, or domain values for ordinal scales.\n    var ticks = (tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues)\n                  .map(d3_svg_axisMapTicks),\n        tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_;\n\n    // Minor ticks.\n    var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide);\n    subticks = subticks.filter(function(d, i, a) {\n      return tickFilter(d, d.index, ticks, i, a);\n    });\n\n    var range = d3_scaleRange(scale);\n\n    if (g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var subtick = g.selectAll(\".minor\");\n        subtick = subtick.data(subticks, function(d, i) {\n          return String(d.value);\n        });\n        var subtickEnter = subtick.enter().insert(\"line\", \"g\").attr(\"class\", \"tick minor\").style(\"opacity\", 1e-6);\n        var subtickExit = d3.transition(subtick.exit()).style(\"opacity\", 1e-6).remove();\n        var subtickUpdate = d3.transition(subtick).style(\"opacity\", 1);\n\n        // Major ticks.\n        var tick = g.selectAll(\"g.major\").data(ticks, function(d, i) {\n              return String(d.value);\n            }),\n            tickEnter = tick.enter().insert(\"g\", \"path\").attr(\"class\", \"tick major\").style(\"opacity\", 1e-6),\n            tickExit = d3.transition(tick.exit()).style(\"opacity\", 1e-6).remove(),\n            tickUpdate = d3.transition(tick).style(\"opacity\", 1),\n            tickTransform;\n\n        // Domain.\n        var path = g.selectAll(\".domain\").data([0]),\n            pathEnter = path.enter().append(\"path\").attr(\"class\", \"domain\"),\n            pathUpdate = d3.transition(path);\n\n        // Stash a snapshot of the new scale, and retrieve the old snapshot.\n        var scale1 = scale.copy(),\n            scale0 = this.__chart__ || scale1;\n        this.__chart__ = scale1;\n\n        tickEnter.append(\"line\").attr(\"class\", \"tick\");\n        tickEnter.append(\"text\").attr(\"class\", \"tick-text\");\n\n        var lineEnter = tickEnter.select(\"line.tick\"),\n            lineUpdate = tickUpdate.select(\"line.tick\"),\n            text = tick.select(\"text.tick-text\").text(function(d, i) {\n              if (tickFormatExtended_ == null)\n                return tickFormat(d.value);\n              else\n                return tickFormatExtended_(d, i);\n            }),\n            textEnter = tickEnter.select(\"text.tick-text\"),\n            textUpdate = tickUpdate.select(\"text.tick-text\");\n\n        switch (orient) {\n          case \"bottom\": {\n            tickTransform = d3_svg_axisX;\n            subtickEnter.attr(\"x2\", 0).attr(\"y2\", function(d, i) {\n              return +tickMinorSize(d, i);\n            });\n            subtickUpdate.attr(\"x2\", 0).attr(\"y2\", function(d, i) {\n              return +tickMinorSize(d, i);\n            });\n            lineEnter.attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\n            textEnter.attr(\"x\", 0).attr(\"y\", function(d, i) {\n              return Math.max(+tickMajorSize(d, i), 0) + tickPadding;\n            });\n            lineUpdate.attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\n            textUpdate.attr(\"x\", 0).attr(\"y\", function (d, i) {\n              return Math.max(+tickMajorSize(d, i), 0) + tickPadding;\n            });\n            text.attr(\"dy\", \".71em\").attr(\"text-anchor\", \"middle\");\n            pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + tickEndSize(range, 0) + \"V0H\" + range[1] + \"V\" + tickEndSize(range, 1));\n            break;\n          }\n          case \"top\": {\n            tickTransform = d3_svg_axisX;\n            subtickEnter.attr(\"y2\", function(d, i) {\n              return -tickMinorSize(d, i);\n            });\n            subtickUpdate.attr(\"x2\", 0).attr(\"y2\", function(d, i) {\n              return -tickMinorSize(d, i);\n            });\n            lineEnter.attr(\"y2\", function(d, i) {\n              return -tickMajorSize(d, i);\n            });\n            textEnter.attr(\"y\", function(d, i) {\n              return -(Math.max(+tickMajorSize(d, i), 0) + tickPadding);\n            });\n            lineUpdate.attr(\"x2\", 0).attr(\"y2\", function(d, i) {\n              return -tickMajorSize(d, i);\n            });\n            textUpdate.attr(\"x\", 0).attr(\"y\", function(d, i) {\n              return -(Math.max(+tickMajorSize(d, i), 0) + tickPadding);\n            });\n            text.attr(\"dy\", \"0em\").attr(\"text-anchor\", \"middle\");\n            pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + -tickEndSize(range, 0) + \"V0H\" + range[1] + \"V\" + -tickEndSize(range, 1));\n            break;\n          }\n          case \"left\": {\n            tickTransform = d3_svg_axisY;\n            subtickEnter.attr(\"x2\", function(d, i) {\n              return -tickMinorSize(d, i);\n            });\n            subtickUpdate.attr(\"x2\", function(d, i) {\n              return -tickMinorSize(d, i);\n            }).attr(\"y2\", 0);\n            lineEnter.attr(\"x2\", function(d, i) {\n              return -tickMajorSize(d, i);\n            });\n            textEnter.attr(\"x\", function(d, i) {\n              return -(Math.max(+tickMajorSize(d, i), 0) + tickPadding);\n            });\n            lineUpdate.attr(\"x2\", function(d, i) {\n              return -tickMajorSize(d, i);\n            }).attr(\"y2\", 0);\n            textUpdate.attr(\"x\", function(d, i) {\n              return -(Math.max(+tickMajorSize(d, i), 0) + tickPadding);\n            }).attr(\"y\", 0);\n            text.attr(\"dy\", \".32em\").attr(\"text-anchor\", \"end\");\n            pathUpdate.attr(\"d\", \"M\" + -tickEndSize(range, 0) + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + -tickEndSize(range, 1));\n            break;\n          }\n          case \"right\": {\n            tickTransform = d3_svg_axisY;\n            subtickEnter.attr(\"x2\", tickMinorSize);\n            subtickUpdate.attr(\"x2\", tickMinorSize).attr(\"y2\", 0);\n            lineEnter.attr(\"x2\", tickMajorSize);\n            textEnter.attr(\"x\", function(d, i) {\n              return Math.max(+tickMajorSize(d, i), 0) + tickPadding;\n            });\n            lineUpdate.attr(\"x2\", tickMajorSize).attr(\"y2\", 0);\n            textUpdate.attr(\"x\", function(d, i) {\n              return Math.max(+tickMajorSize(d, i), 0) + tickPadding;\n            }).attr(\"y\", 0);\n            text.attr(\"dy\", \".32em\").attr(\"text-anchor\", \"start\");\n            pathUpdate.attr(\"d\", \"M\" + tickEndSize(range, 0) + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + tickEndSize(range, 1));\n            break;\n          }\n        }\n\n        // For quantitative scales:\n        // - enter new ticks from the old scale\n        // - exit old ticks to the new scale\n        if (scale.ticks) {\n          tickEnter.call(tickTransform, scale0);\n          tickUpdate.call(tickTransform, scale1);\n          tickExit.call(tickTransform, scale1);\n          subtickEnter.call(tickTransform, scale0);\n          subtickUpdate.call(tickTransform, scale1);\n          subtickExit.call(tickTransform, scale1);\n        }\n\n        // For ordinal scales:\n        // - any entering ticks are undefined in the old scale\n        // - any exiting ticks are undefined in the new scale\n        // Therefore, we only need to transition updating ticks.\n        else {\n          var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };\n          tickEnter.call(tickTransform, x);\n          tickUpdate.call(tickTransform, x);\n        }\n      });\n      return false;\n    } else {\n      // when using d3.axis other than in a d3.selection.call(...); produce the ticks, etc. for custom work:\n      return {\n        ticks: ticks,\n        subticks: subticks,\n        range: range,                            // array[2]\n        tickMajorSize: tickMajorSize,            // functor(d, i)\n        tickMinorSize: tickMinorSize,            // functor(d, i)\n        tickEndSize: tickEndSize,                // functor(d, i)\n        tickPadding: tickPadding,                // Number\n        tickFormat: tickFormat,                  // functor(d)\n        tickFormatExtended: tickFormatExtended_  // functor(d, i)\n      };\n    }\n  }\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = x;\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x;\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments_;\n    tickArguments_ = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormat_;\n    tickFormat_ = x;\n    return axis;\n  };\n\n  axis.tickFormatEx = function(x) {\n    if (!arguments.length) return tickFormatExtended_;\n    tickFormatExtended_ = extended;\n    return axis;\n  };\n\n  axis.tickSize = function(major, minor, end) {\n    var n = arguments.length;\n    if (!n) return [tickMajorSize, tickMinorSize, tickEndSize];\n    tickMajorSize = d3_functor(major);\n    tickMinorSize = n > 2 ? d3_functor(minor) : tickMajorSize;\n    tickEndSize = d3_functor(arguments[n - 1]);\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    tickPadding = +x;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = (x != null ? typeof x !== \"function\" ? d3_svg_axisTickSubDivideOneTick(+x) : x : null);\n    return axis;\n  };\n\n  axis.tickFilter = function(x) {\n    if (!arguments.length) return tickFilter;\n    tickFilter = (x != null ? d3_functor(x) : d3_functor(true));\n    return axis;\n  };\n\n  return axis;\n};\n\nfunction d3_svg_axisX(selection, x) {\n  selection.attr(\"transform\", function(d) {\n    return \"translate(\" + x(d.value) + \",0)\";\n  });\n}\n\nfunction d3_svg_axisY(selection, y) {\n  selection.attr(\"transform\", function(d) {\n    return \"translate(0,\" + y(d.value) + \")\";\n  });\n}\n\nfunction d3_svg_axisSubdivide(scale, ticks, subdiv) {\n  var subticks = [];\n  if (subdiv && ticks.length > 1) {\n    var extent = d3_scaleExtent(scale.domain()),\n        i,\n        n = ticks.length;\n    for (i = 0; i <= n; i++) {\n      subticks = subdiv(subticks, ticks, i, n, extent);\n    }\n  }\n  return subticks;\n}\n\n// Return a function which produces an array of subtick objects for one tick interval:\nfunction d3_svg_axisTickSubDivideOneTick(modulus) {\n  modulus++;\n  return function(subticks, ticks, i, n, extent) {\n    var t0, t1, delta, s, j, v;\n\n    if (i == 0) {\n      t0 = ticks[0];\n      t1 = ticks[1];\n      delta = (t1.value - t0.value) / modulus;\n      for (j = modulus; j-- > 1; ) {\n        v = t0.value - j * delta;\n        if (v > extent[0]) {\n          subticks.push({\n            value: v,\n            index: -1,\n            base: t0,\n            subindex: -j,\n            modulus: modulus,\n            majors: ticks\n          });\n        }\n      }\n    } else if (i == n) {\n      t0 = ticks[n - 2];\n      t1 = ticks[n - 1];\n      delta = (t1.value - t0.value) / modulus;\n      for (j = modulus; j-- > 1; ) {\n        v = t1.value + j * delta;\n        if (v < extent[1]) {\n          subticks.push({\n            value: v,\n            index: n - 1,\n            base: t1,\n            subindex: j,\n            modulus: modulus,\n            majors: ticks\n          });\n        }\n      }\n    } else {\n      t0 = ticks[i - 1];\n      t1 = ticks[i];\n      delta = (t1.value - t0.value) / modulus;\n      for (j = modulus; j-- > 1; ) {\n        v = t0.value + j * delta;\n        if (v > extent[0]) {\n          subticks.push({\n            value: v,\n            index: i - 1,\n            base: t0,\n            subindex: j,\n            modulus: modulus,\n            majors: ticks\n          });\n        }\n      }\n    }\n    return subticks;\n  };\n}\n\nfunction d3_svg_axisMapTicks(v, i, ticks) {\n  return {\n    value: v,\n    index: i\n  };\n}d3.svg.brush = function() {\n  var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"),\n      x = null, // x-scale, optional\n      y = null, // y-scale, optional\n      resizes = d3_svg_brushResizes[0],\n      extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1], in pixels (integers)\n      extentDomain; // the extent in data space, lazily created\n\n  function brush(g) {\n    g.each(function() {\n      var g = d3.select(this),\n          bg = g.selectAll(\".background\").data([0]),\n          fg = g.selectAll(\".extent\").data([0]),\n          tz = g.selectAll(\".resize\").data(resizes, String),\n          e;\n\n      // Prepare the brush container for events.\n      g\n          .style(\"pointer-events\", \"all\")\n          .on(\"mousedown.brush\", brushstart)\n          .on(\"touchstart.brush\", brushstart);\n\n      // An invisible, mouseable area for starting a new brush.\n      bg.enter().append(\"rect\")\n          .attr(\"class\", \"background\")\n          .style(\"visibility\", \"hidden\")\n          .style(\"cursor\", \"crosshair\");\n\n      // The visible brush extent; style this as you like!\n      fg.enter().append(\"rect\")\n          .attr(\"class\", \"extent\")\n          .style(\"cursor\", \"move\");\n\n      // More invisible rects for resizing the extent.\n      tz.enter().append(\"g\")\n          .attr(\"class\", function(d) { return \"resize \" + d; })\n          .style(\"cursor\", function(d) { return d3_svg_brushCursor[d]; })\n        .append(\"rect\")\n          .attr(\"x\", function(d) { return /[ew]$/.test(d) ? -3 : null; })\n          .attr(\"y\", function(d) { return /^[ns]/.test(d) ? -3 : null; })\n          .attr(\"width\", 6)\n          .attr(\"height\", 6)\n          .style(\"visibility\", \"hidden\");\n\n      // Show or hide the resizers.\n      tz.style(\"display\", brush.empty() ? \"none\" : null);\n\n      // Remove any superfluous resizers.\n      tz.exit().remove();\n\n      // Initialize the background to fill the defined range.\n      // If the range isn't defined, you can post-process.\n      if (x) {\n        e = d3_scaleRange(x);\n        bg.attr(\"x\", e[0]).attr(\"width\", e[1] - e[0]);\n        redrawX(g);\n      }\n      if (y) {\n        e = d3_scaleRange(y);\n        bg.attr(\"y\", e[0]).attr(\"height\", e[1] - e[0]);\n        redrawY(g);\n      }\n      redraw(g);\n    });\n  }\n\n  function redraw(g) {\n    g.selectAll(\".resize\").attr(\"transform\", function(d) {\n      return \"translate(\" + extent[+/e$/.test(d)][0] + \",\" + extent[+/^s/.test(d)][1] + \")\";\n    });\n  }\n\n  function redrawX(g) {\n    g.select(\".extent\").attr(\"x\", extent[0][0]);\n    g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", extent[1][0] - extent[0][0]);\n  }\n\n  function redrawY(g) {\n    g.select(\".extent\").attr(\"y\", extent[0][1]);\n    g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", extent[1][1] - extent[0][1]);\n  }\n\n  function brushstart() {\n    var target = this,\n        eventTarget = d3.select(d3.event.target),\n        event_ = event.of(target, arguments),\n        g = d3.select(target),\n        resizing = eventTarget.datum(),\n        resizingX = !/^(n|s)$/.test(resizing) && x,\n        resizingY = !/^(e|w)$/.test(resizing) && y,\n        dragging = eventTarget.classed(\"extent\"),\n        center,\n        origin = mouse(),\n        offset;\n\n    var w = d3.select(window)\n        .on(\"mousemove.brush\", brushmove)\n        .on(\"mouseup.brush\", brushend)\n        .on(\"touchmove.brush\", brushmove)\n        .on(\"touchend.brush\", brushend)\n        .on(\"keydown.brush\", keydown)\n        .on(\"keyup.brush\", keyup);\n\n    // If the extent was clicked on, drag rather than brush;\n    // store the point between the mouse and extent origin instead.\n    if (dragging) {\n      origin[0] = extent[0][0] - origin[0];\n      origin[1] = extent[0][1] - origin[1];\n    }\n\n    // If a resizer was clicked on, record which side is to be resized.\n    // Also, set the origin to the opposite side.\n    else if (resizing) {\n      var ex = +/w$/.test(resizing),\n          ey = +/^n/.test(resizing);\n      offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];\n      origin[0] = extent[ex][0];\n      origin[1] = extent[ey][1];\n    }\n\n    // If the ALT key is down when starting a brush, the center is at the mouse.\n    else if (d3.event.altKey) center = origin.slice();\n\n    // Propagate the active cursor to the body for the drag duration.\n    g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n    g.selectAll(\".background\").style(\"pointer-events\", \"none\"); // workaround for IE9 bug\n    d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n\n    // Notify listeners.\n    event_({type: \"brushstart\"});\n    brushmove();\n    d3_eventCancel();\n\n    function mouse() {\n      var touches = d3.event.changedTouches;\n      return touches ? d3.touches(target, touches)[0] : d3.mouse(target);\n    }\n\n    function keydown() {\n      if (d3.event.keyCode == 32) {\n        if (!dragging) {\n          center = null;\n          origin[0] -= extent[1][0];\n          origin[1] -= extent[1][1];\n          dragging = 2;\n        }\n        d3_eventCancel();\n      }\n    }\n\n    function keyup() {\n      if (d3.event.keyCode == 32 && dragging == 2) {\n        origin[0] += extent[1][0];\n        origin[1] += extent[1][1];\n        dragging = 0;\n        d3_eventCancel();\n      }\n    }\n\n    function brushmove() {\n      var point = mouse(),\n          moved = false;\n\n      // Preserve the offset for thick resizers.\n      if (offset) {\n        point[0] += offset[0];\n        point[1] += offset[1];\n      }\n\n      if (!dragging) {\n\n        // If needed, determine the center from the current extent.\n        if (d3.event.altKey) {\n          if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];\n\n          // Update the origin, for when the ALT key is released.\n          origin[0] = extent[+(point[0] < center[0])][0];\n          origin[1] = extent[+(point[1] < center[1])][1];\n        }\n\n        // When the ALT key is released, we clear the center.\n        else center = null;\n      }\n\n      // Update the brush extent for each dimension.\n      if (resizingX && move1(point, x, 0)) {\n        redrawX(g);\n        moved = true;\n      }\n      if (resizingY && move1(point, y, 1)) {\n        redrawY(g);\n        moved = true;\n      }\n\n      // Final redraw and notify listeners.\n      if (moved) {\n        redraw(g);\n        event_({type: \"brush\", mode: dragging ? \"move\" : \"resize\"});\n      }\n    }\n\n    function move1(point, scale, i) {\n      var range = d3_scaleRange(scale),\n          r0 = range[0],\n          r1 = range[1],\n          position = origin[i],\n          size = extent[1][i] - extent[0][i],\n          min,\n          max;\n\n      // When dragging, reduce the range by the extent size and position.\n      if (dragging) {\n        r0 -= position;\n        r1 -= size + position;\n      }\n\n      // Clamp the point so that the extent fits within the range extent.\n      min = Math.max(r0, Math.min(r1, point[i]));\n\n      // Compute the new extent bounds.\n      if (dragging) {\n        max = (min += position) + size;\n      } else {\n\n        // If the ALT key is pressed, then preserve the center of the extent.\n        if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n\n        // Compute the min and max of the position and point.\n        if (position < min) {\n          max = min;\n          min = position;\n        } else {\n          max = position;\n        }\n      }\n\n      // Update the stored bounds.\n      if (extent[0][i] !== min || extent[1][i] !== max) {\n        extentDomain = null;\n        extent[0][i] = min;\n        extent[1][i] = max;\n        return true;\n      }\n    }\n\n    function brushend() {\n      brushmove();\n\n      // reset the cursor styles\n      g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n      g.selectAll(\".background\").style(\"pointer-events\", null); // workaround for IE9 bug\n      d3.select(\"body\").style(\"cursor\", null);\n\n      w .on(\"mousemove.brush\", null)\n        .on(\"mouseup.brush\", null)\n        .on(\"touchmove.brush\", null)\n        .on(\"touchend.brush\", null)\n        .on(\"keydown.brush\", null)\n        .on(\"keyup.brush\", null);\n\n      event_({type: \"brushend\"});\n      d3_eventCancel();\n    }\n  }\n\n  brush.x = function(z) {\n    if (!arguments.length) return x;\n    x = z;\n    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!\n    return brush;\n  };\n\n  brush.y = function(z) {\n    if (!arguments.length) return y;\n    y = z;\n    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!\n    return brush;\n  };\n\n  brush.extent = function(z) {\n    var x0, x1, y0, y1, t;\n\n    // Invert the pixel extent to data-space.\n    if (!arguments.length) {\n      z = extentDomain || extent;\n      if (x) {\n        x0 = z[0][0], x1 = z[1][0];\n        if (!extentDomain) {\n          x0 = extent[0][0], x1 = extent[1][0];\n          if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n          if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        }\n      }\n      if (y) {\n        y0 = z[0][1], y1 = z[1][1];\n        if (!extentDomain) {\n          y0 = extent[0][1], y1 = extent[1][1];\n          if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n          if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        }\n      }\n      return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];\n    }\n\n    // Scale the data-space extent to pixels.\n    extentDomain = [[0, 0], [0, 0]];\n    if (x) {\n      x0 = z[0], x1 = z[1];\n      if (y) x0 = x0[0], x1 = x1[0];\n      extentDomain[0][0] = x0, extentDomain[1][0] = x1;\n      if (x.invert) x0 = x(x0), x1 = x(x1);\n      if (x1 < x0) t = x0, x0 = x1, x1 = t;\n      extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;\n    }\n    if (y) {\n      y0 = z[0], y1 = z[1];\n      if (x) y0 = y0[1], y1 = y1[1];\n      extentDomain[0][1] = y0, extentDomain[1][1] = y1;\n      if (y.invert) y0 = y(y0), y1 = y(y1);\n      if (y1 < y0) t = y0, y0 = y1, y1 = t;\n      extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;\n    }\n\n    return brush;\n  };\n\n  brush.clear = function() {\n    extentDomain = null;\n    extent[0][0] =\n    extent[0][1] =\n    extent[1][0] =\n    extent[1][1] = 0;\n    return brush;\n  };\n\n  brush.empty = function() {\n    return (x && extent[0][0] === extent[1][0])\n        || (y && extent[0][1] === extent[1][1]);\n  };\n\n  return d3.rebind(brush, event, \"on\");\n};\n\nvar d3_svg_brushCursor = {\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar d3_svg_brushResizes = [\n  [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"],\n  [\"e\", \"w\"],\n  [\"n\", \"s\"],\n  []\n];\nd3.behavior = {};\nd3.behavior.drag = function() {\n  var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n      origin = null;\n\n  function drag() {\n    this.on(\"mousedown.drag\", mousedown)\n        .on(\"touchstart.drag\", mousedown);\n  }\n\n  function mousedown() {\n    var target = this,\n        event_ = event.of(target, arguments),\n        eventTarget = d3.event.target,\n        touchId = d3.event.touches && d3.event.changedTouches[0].identifier,\n        offset,\n        origin_ = point(),\n        moved = 0;\n\n    var w = d3.select(window)\n        .on(touchId ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", dragmove)\n        .on(touchId ? \"touchend.drag-\" + touchId : \"mouseup.drag\", dragend, true);\n\n    if (origin) {\n      offset = origin.apply(target, arguments);\n      offset = [offset.x - origin_[0], offset.y - origin_[1]];\n    } else {\n      offset = [0, 0];\n    }\n\n    // Only cancel mousedown; touchstart is needed for draggable links.\n    if (!touchId) d3_eventCancel();\n    event_({type: \"dragstart\"});\n\n    function point() {\n      var p = target.parentNode;\n      return touchId\n          ? d3.touches(p).filter(function(p) { return p.identifier === touchId; })[0]\n          : d3.mouse(p);\n    }\n\n    function dragmove() {\n      if (!target.parentNode) return dragend(); // target removed from DOM\n\n      var p = point(),\n          dx = p[0] - origin_[0],\n          dy = p[1] - origin_[1];\n\n      moved |= dx | dy;\n      origin_ = p;\n      d3_eventCancel();\n\n      event_({type: \"drag\", x: p[0] + offset[0], y: p[1] + offset[1], dx: dx, dy: dy});\n    }\n\n    function dragend() {\n      event_({type: \"dragend\"});\n\n      // if moved, prevent the mouseup (and possibly click) from propagating\n      if (moved) {\n        d3_eventCancel();\n        if (d3.event.target === eventTarget) w.on(\"click.drag\", click, true);\n      }\n\n      w .on(touchId ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", null)\n        .on(touchId ? \"touchend.drag-\" + touchId : \"mouseup.drag\", null);\n    }\n\n    // prevent the subsequent click from propagating (e.g., for anchors)\n    function click() {\n      d3_eventCancel();\n      w.on(\"click.drag\", null);\n    }\n  }\n\n  drag.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    return drag;\n  };\n\n  return d3.rebind(drag, event, \"on\");\n};\nd3.behavior.zoom = function() {\n  var translate = [0, 0],\n      translate0, // translate when we started zooming (to avoid drift)\n      scale = 1,\n      scale0, // scale when we started touching\n      scaleExtent = d3_behavior_zoomInfinity,\n      event = d3_eventDispatch(zoom, \"zoom\"),\n      x0,\n      x1,\n      y0,\n      y1,\n      touchtime; // time of last touchstart (to detect double-tap)\n\n  function zoom() {\n    this\n        .on(\"mousedown.zoom\", mousedown)\n        .on(\"mousewheel.zoom\", mousewheel)\n        .on(\"mousemove.zoom\", mousemove)\n        .on(\"DOMMouseScroll.zoom\", mousewheel)\n        .on(\"dblclick.zoom\", dblclick)\n        .on(\"touchstart.zoom\", touchstart)\n        .on(\"touchmove.zoom\", touchmove)\n        .on(\"touchend.zoom\", touchstart);\n  }\n\n  zoom.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = x.map(Number);\n    return zoom;\n  };\n\n  zoom.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return zoom;\n  };\n\n  zoom.scaleExtent = function(x) {\n    if (!arguments.length) return scaleExtent;\n    scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);\n    return zoom;\n  };\n\n  zoom.x = function(z) {\n    if (!arguments.length) return x1;\n    x1 = z;\n    x0 = z.copy();\n    return zoom;\n  };\n\n  zoom.y = function(z) {\n    if (!arguments.length) return y1;\n    y1 = z;\n    y0 = z.copy();\n    return zoom;\n  };\n\n  function location(p) {\n    return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];\n  }\n\n  function point(l) {\n    return [l[0] * scale + translate[0], l[1] * scale + translate[1]];\n  }\n\n  function scaleTo(s) {\n    scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n  }\n\n  function translateTo(p, l) {\n    l = point(l);\n    translate[0] += p[0] - l[0];\n    translate[1] += p[1] - l[1];\n  }\n\n  function dispatch(event) {\n    if (x1) x1.domain(x0.range().map(function(x) { return (x - translate[0]) / scale; }).map(x0.invert));\n    if (y1) y1.domain(y0.range().map(function(y) { return (y - translate[1]) / scale; }).map(y0.invert));\n    d3.event.preventDefault();\n    event({type: \"zoom\", scale: scale, translate: translate});\n  }\n\n  function mousedown() {\n    var target = this,\n        event_ = event.of(target, arguments),\n        eventTarget = d3.event.target,\n        moved = 0,\n        w = d3.select(window).on(\"mousemove.zoom\", mousemove).on(\"mouseup.zoom\", mouseup),\n        l = location(d3.mouse(target));\n\n    window.focus();\n    d3_eventCancel();\n\n    function mousemove() {\n      moved = 1;\n      translateTo(d3.mouse(target), l);\n      dispatch(event_);\n    }\n\n    function mouseup() {\n      if (moved) d3_eventCancel();\n      w.on(\"mousemove.zoom\", null).on(\"mouseup.zoom\", null);\n      if (moved && d3.event.target === eventTarget) w.on(\"click.zoom\", click, true);\n    }\n\n    function click() {\n      d3_eventCancel();\n      w.on(\"click.zoom\", null);\n    }\n  }\n\n  function mousewheel() {\n    if (!translate0) translate0 = location(d3.mouse(this));\n    scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);\n    translateTo(d3.mouse(this), translate0);\n    dispatch(event.of(this, arguments));\n  }\n\n  function mousemove() {\n    translate0 = null;\n  }\n\n  function dblclick() {\n    var p = d3.mouse(this), l = location(p);\n    scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);\n    translateTo(p, l);\n    dispatch(event.of(this, arguments));\n  }\n\n  function touchstart() {\n    var touches = d3.touches(this),\n        now = Date.now();\n\n    scale0 = scale;\n    translate0 = {};\n    touches.forEach(function(t) { translate0[t.identifier] = location(t); });\n    d3_eventCancel();\n\n    if (touches.length === 1) {\n      if (now - touchtime < 500) { // dbltap\n        var p = touches[0], l = location(touches[0]);\n        scaleTo(scale * 2);\n        translateTo(p, l);\n        dispatch(event.of(this, arguments));\n      }\n      touchtime = now;\n    }\n  }\n\n  function touchmove() {\n    var touches = d3.touches(this),\n        p0 = touches[0],\n        l0 = translate0[p0.identifier];\n    if (p1 = touches[1]) {\n      var p1, l1 = translate0[p1.identifier];\n      p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n      scaleTo(d3.event.scale * scale0);\n    }\n    translateTo(p0, l0);\n    touchtime = null;\n    dispatch(event.of(this, arguments));\n  }\n\n  return d3.rebind(zoom, event, \"on\");\n};\n\nvar d3_behavior_zoomDiv, // for interpreting mousewheel events\n    d3_behavior_zoomInfinity = [0, Infinity]; // default scale extent\n\nfunction d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta;\n}\nd3.layout = {};\n// Implements hierarchical edge bundling using Holten's algorithm. For each\n// input link, a path is computed that travels through the tree, up the parent\n// hierarchy to the least common ancestor, and then back down to the destination\n// node. Each path is simply an array of nodes.\nd3.layout.bundle = function() {\n  return function(links) {\n    var paths = [],\n        i = -1,\n        n = links.length;\n    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n    return paths;\n  };\n};\n\nfunction d3_layout_bundlePath(link) {\n  var start = link.source,\n      end = link.target,\n      lca = d3_layout_bundleLeastCommonAncestor(start, end),\n      points = [start];\n  while (start !== lca) {\n    start = start.parent;\n    points.push(start);\n  }\n  var k = points.length;\n  while (end !== lca) {\n    points.splice(k, 0, end);\n    end = end.parent;\n  }\n  return points;\n}\n\nfunction d3_layout_bundleAncestors(node) {\n  var ancestors = [],\n      parent = node.parent;\n  while (parent != null) {\n    ancestors.push(node);\n    node = parent;\n    parent = parent.parent;\n  }\n  ancestors.push(node);\n  return ancestors;\n}\n\nfunction d3_layout_bundleLeastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = d3_layout_bundleAncestors(a),\n      bNodes = d3_layout_bundleAncestors(b),\n      aNode = aNodes.pop(),\n      bNode = bNodes.pop(),\n      sharedNode = null;\n  while (aNode === bNode) {\n    sharedNode = aNode;\n    aNode = aNodes.pop();\n    bNode = bNodes.pop();\n  }\n  return sharedNode;\n}\nd3.layout.chord = function() {\n  var chord = {},\n      chords,\n      groups,\n      matrix,\n      n,\n      padding = 0,\n      sortGroups,\n      sortSubgroups,\n      sortChords;\n\n  function relayout() {\n    var subgroups = {},\n        groupSums = [],\n        groupIndex = d3.range(n),\n        subgroupIndex = [],\n        k,\n        x,\n        x0,\n        i,\n        j;\n\n    chords = [];\n    groups = [];\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(d3.range(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) {\n      groupIndex.sort(function(a, b) {\n        return sortGroups(groupSums[a], groupSums[b]);\n      });\n    }\n\n    // Sort subgroups…\n    if (sortSubgroups) {\n      subgroupIndex.forEach(function(d, i) {\n        d.sort(function(a, b) {\n          return sortSubgroups(matrix[i][a], matrix[i][b]);\n        });\n      });\n    }\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified.\n    // TODO Allow padding to be specified as percentage?\n    k = (2 * Math.PI - padding * n) / k;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[di][j],\n            v = matrix[di][dj],\n            a0 = x,\n            a1 = x += v * k;\n        subgroups[di + \"-\" + dj] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups[di] = {\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: (x - x0) / k\n      };\n      x += padding;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[i + \"-\" + j],\n            target = subgroups[j + \"-\" + i];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    if (sortChords) resort();\n  }\n\n  function resort() {\n    chords.sort(function(a, b) {\n      return sortChords(\n          (a.source.value + a.target.value) / 2,\n          (b.source.value + b.target.value) / 2);\n    });\n  }\n\n  chord.matrix = function(x) {\n    if (!arguments.length) return matrix;\n    n = (matrix = x) && matrix.length;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.padding = function(x) {\n    if (!arguments.length) return padding;\n    padding = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortGroups = function(x) {\n    if (!arguments.length) return sortGroups;\n    sortGroups = x;\n    chords = groups = null;\n    return chord;\n  };\n\n  chord.sortSubgroups = function(x) {\n    if (!arguments.length) return sortSubgroups;\n    sortSubgroups = x;\n    chords = null;\n    return chord;\n  };\n\n  chord.sortChords = function(x) {\n    if (!arguments.length) return sortChords;\n    sortChords = x;\n    if (chords) resort();\n    return chord;\n  };\n\n  chord.chords = function() {\n    if (!chords) relayout();\n    return chords;\n  };\n\n  chord.groups = function() {\n    if (!groups) relayout();\n    return groups;\n  };\n\n  return chord;\n};\n// A rudimentary force layout using Gauss-Seidel.\nd3.layout.force = function() {\n  var force = {},\n      event = d3.dispatch(\"start\", \"tick\", \"end\"),\n      size = [1, 1],\n      drag,\n      alpha,\n      friction = d3_functor(.9),\n      linkDistance = d3_layout_forceLinkDistance,\n      linkStrength = d3_layout_forceLinkStrength,\n      charge = d3_functor(-30),\n      gravity = .1,\n      theta = .8,\n      interval,\n      nodes = [],\n      links = [],\n      distances,\n      strengths,\n      charges;\n\n  function repulse(node) {\n    return function(quad, x1, y1, x2, y2) {\n      if (quad.point !== node) {\n        var dx = quad.cx - node.x,\n            dy = quad.cy - node.y,\n            dn = 1 / Math.sqrt(dx * dx + dy * dy);\n\n        /* Barnes-Hut criterion. */\n        if ((x2 - x1) * dn < theta) {\n          var k = quad.charge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n          return true;\n        }\n\n        if (quad.point && isFinite(dn)) {\n          var k = quad.pointCharge * dn * dn;\n          node.px -= dx * k;\n          node.py -= dy * k;\n        }\n      }\n      return !quad.charge;\n    };\n  }\n\n  force.tick = function() {\n    // simulated annealing, basically\n    if ((alpha *= .99) < .005) {\n      event.end({type: \"end\", alpha: alpha = 0});\n      return true;\n    }\n\n    var n = nodes.length,\n        m = links.length,\n        q,\n        f,\n        i, // current index\n        o, // current object\n        s, // current source\n        t, // current target\n        l, // current distance\n        k, // current force\n        x, // x-distance\n        y; // y-distance\n\n    // gauss-seidel relaxation for links\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      s = o.source;\n      t = o.target;\n      x = t.x - s.x;\n      y = t.y - s.y;\n      if (l = (x * x + y * y)) {\n        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n        x *= l;\n        y *= l;\n        t.x -= x * (k = s.weight / (t.weight + s.weight));\n        t.y -= y * k;\n        s.x += x * (k = 1 - k);\n        s.y += y * k;\n      }\n    }\n\n    // apply gravity forces\n    if (k = alpha * gravity) {\n      x = size[0] / 2;\n      y = size[1] / 2;\n      i = -1; if (k) while (++i < n) {\n        o = nodes[i];\n        o.x += (x - o.x) * k;\n        o.y += (y - o.y) * k;\n      }\n    }\n\n    // compute quadtree center of mass and apply charge forces\n    f = 0;\n    q = d3.geom.quadtree(nodes);\n    // recalculate charges on every tick if need be:\n    charges = [];\n    for (i = 0; i < n; ++i) {\n      charges[i] = k = +charge.call(this, nodes[i], i, q);\n      f += Math.abs(k);\n    }\n    if (f != 0) {\n      d3_layout_forceAccumulate(q, alpha, charges);\n      i = -1; while (++i < n) {\n        if (!(o = nodes[i]).fixed) {\n          q.visit(repulse(o));\n        }\n      }\n    }\n\n    // position verlet integration\n    i = -1; while (++i < n) {\n      o = nodes[i];\n      if (o.fixed) {\n        o.x = o.px;\n        o.y = o.py;\n      } else {\n        f = friction.call(this, o, i);\n        o.x -= (o.px - (o.px = o.x)) * f;\n        o.y -= (o.py - (o.py = o.y)) * f;\n      }\n    }\n\n    event.tick({type: \"tick\", alpha: alpha});\n  };\n\n  force.nodes = function(x) {\n    if (!arguments.length) return nodes;\n    nodes = x;\n    return force;\n  };\n\n  force.links = function(x) {\n    if (!arguments.length) return links;\n    links = x;\n    return force;\n  };\n\n  force.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return force;\n  };\n\n  force.linkDistance = function(x) {\n    if (!arguments.length) return linkDistance;\n    linkDistance = d3_functor(x);\n    return force;\n  };\n\n  // For backwards-compatibility.\n  force.distance = force.linkDistance;\n\n  force.linkStrength = function(x) {\n    if (!arguments.length) return linkStrength;\n    linkStrength = d3_functor(x);\n    return force;\n  };\n\n  force.friction = function(x) {\n    if (!arguments.length) return friction;\n    friction = d3_functor(x);\n    return force;\n  };\n\n  force.charge = function(x) {\n    if (!arguments.length) return charge;\n    charge = d3_functor(x);\n    return force;\n  };\n\n  force.gravity = function(x) {\n    if (!arguments.length) return gravity;\n    gravity = +x;\n    return force;\n  };\n\n  force.theta = function(x) {\n    if (!arguments.length) return theta;\n    theta = +x;\n    return force;\n  };\n\n  force.alpha = function(x) {\n    if (!arguments.length) return alpha;\n\n    if (alpha) { // if we're already running\n      if (x > 0) alpha = x; // we might keep it hot\n      else alpha = 0; // or, next tick will dispatch \"end\"\n    } else if (x > 0) { // otherwise, fire it up!\n      event.start({type: \"start\", alpha: alpha = x});\n      d3.timer(force.tick);\n    }\n\n    return force;\n  };\n\n  force.start = function() {\n    var i,\n        j,\n        n = nodes.length,\n        m = links.length,\n        w = size[0],\n        h = size[1],\n        neighbors,\n        o;\n\n    for (i = 0; i < n; ++i) {\n      (o = nodes[i]).index = i;\n      o.weight = 0;\n    }\n\n    distances = [];\n    strengths = [];\n    for (i = 0; i < m; ++i) {\n      o = links[i];\n      if (typeof o.source == \"number\") o.source = nodes[o.source];\n      if (typeof o.target == \"number\") o.target = nodes[o.target];\n      distances[i] = linkDistance.call(this, o, i);\n      strengths[i] = linkStrength.call(this, o, i);\n      ++o.source.weight;\n      ++o.target.weight;\n    }\n\n    for (i = 0; i < n; ++i) {\n      o = nodes[i];\n      if (isNaN(o.x)) o.x = position(\"x\", w, i);\n      if (isNaN(o.y)) o.y = position(\"y\", h, i);\n      if (isNaN(o.px)) o.px = o.x;\n      if (isNaN(o.py)) o.py = o.y;\n    }\n\n    charges = [];\n    for (i = 0; i < n; ++i) {\n      charges[i] = +charge.call(this, nodes[i], i);\n    }\n\n    // initialize node position based on first neighbor\n    function position(dimension, size, i) {\n      var my_neighbors = neighbor(i),\n          j = -1,\n          m = my_neighbors.length,\n          x;\n      while (++j < m) if (!isNaN(x = my_neighbors[j][dimension])) return x;\n      return Math.random() * size;\n    }\n\n    // initialize neighbors lazily\n    function neighbor(i) {\n      if (!neighbors) {\n        var j;\n        neighbors = [];\n        for (j = 0; j < n; ++j) {\n          neighbors[j] = [];\n        }\n        for (j = 0; j < m; ++j) {\n          var o = links[j];\n          neighbors[o.source.index].push(o.target);\n          neighbors[o.target.index].push(o.source);\n        }\n      }\n      return neighbors[i];\n    }\n\n    return force.resume();\n  };\n\n  force.resume = function() {\n    return force.alpha(.1);\n  };\n\n  force.stop = function() {\n    return force.alpha(0);\n  };\n\n  // use `node.call(force.drag)` to make nodes draggable\n  force.drag = function() {\n    if (!arguments.length) return drag;\n\n    if (!drag) drag = d3.behavior.drag()\n        .origin(d3_identity)\n        .on(\"dragstart.force\", d3_layout_forceDragstart)\n        .on(\"drag.force\", dragmove)\n        .on(\"dragend.force\", d3_layout_forceDragend);\n\n    this.on(\"mouseover.force\", d3_layout_forceMouseover)\n        .on(\"mouseout.force\", d3_layout_forceMouseout)\n        .call(drag);\n  };\n\n  function dragmove(d) {\n    d.px = d3.event.x;\n    d.py = d3.event.y;\n    force.resume(); // restart annealing\n  }\n\n  return d3.rebind(force, event, \"on\");\n};\n\nfunction d3_layout_forceDragstart(d) {\n  d.fixed |= 1;\n}\n\nfunction d3_layout_forceDragend(d) {\n  d.fixed &= ~1;\n}\n\nfunction d3_layout_forceMouseover(d) {\n  d.fixed |= 2;\n}\n\nfunction d3_layout_forceMouseout(d) {\n  d.fixed &= ~2;\n}\n\nfunction d3_layout_forceAccumulate(quad, alpha, charges) {\n  var cx = 0,\n      cy = 0;\n  quad.charge = 0;\n  if (!quad.leaf) {\n    var nodes = quad.nodes,\n        n = nodes.length,\n        i = -1,\n        c;\n    while (++i < n) {\n      c = nodes[i];\n      if (c == null) continue;\n      d3_layout_forceAccumulate(c, alpha, charges);\n      quad.charge += c.charge;\n      cx += c.charge * c.cx;\n      cy += c.charge * c.cy;\n    }\n  }\n  if (quad.point) {\n    // jitter internal nodes that are coincident\n    if (!quad.leaf) {\n      quad.point.x += Math.random() - .5;\n      quad.point.y += Math.random() - .5;\n    }\n    var k = alpha * charges[quad.point.index];\n    quad.charge += quad.pointCharge = k;\n    cx += k * quad.point.x;\n    cy += k * quad.point.y;\n  }\n  quad.cx = cx / quad.charge;\n  quad.cy = cy / quad.charge;\n}\n\nfunction d3_layout_forceLinkDistance(link) {\n  return 20;\n}\n\nfunction d3_layout_forceLinkStrength(link) {\n  return 1;\n}\nd3.layout.partition = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      size = [1, 1]; // width, height\n\n  function position(node, x, dx, dy) {\n    var children = node.children;\n    node.x = x;\n    node.y = node.depth * dy;\n    node.dx = dx;\n    node.dy = dy;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n,\n          c,\n          d;\n      dx = node.value ? dx / node.value : 0;\n      while (++i < n) {\n        position(c = children[i], x, d = c.value * dx, dy);\n        x += d;\n      }\n    }\n  }\n\n  function depth(node) {\n    var children = node.children,\n        d = 0;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n;\n      while (++i < n) d = Math.max(d, depth(children[i]));\n    }\n    return 1 + d;\n  }\n\n  function partition(d, i) {\n    var nodes = hierarchy.call(this, d, i);\n    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n    return nodes;\n  }\n\n  partition.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return partition;\n  };\n\n  return d3_layout_hierarchyRebind(partition, hierarchy);\n};\nd3.layout.pie = function() {\n  var value = Number,\n      sort = d3_layout_pieSortByValue,\n      startAngle = 0,\n      endAngle = 2 * Math.PI;\n\n  function pie(data, i) {\n\n    // Compute the numeric values for each data element.\n    var values = data.map(function(d, i) { return +value.call(pie, d, i); });\n\n    // Compute the start angle.\n    var a = +(typeof startAngle === \"function\"\n        ? startAngle.apply(this, arguments)\n        : startAngle);\n\n    // Compute the angular scale factor: from value to radians.\n    var k = ((typeof endAngle === \"function\"\n        ? endAngle.apply(this, arguments)\n        : endAngle) - startAngle)\n        / d3.sum(values);\n\n    // Optionally sort the data.\n    var index = d3.range(data.length);\n    if (sort != null) index.sort(sort === d3_layout_pieSortByValue\n        ? function(i, j) { return values[j] - values[i]; }\n        : function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs!\n    // They are stored in the original data's order.\n    var arcs = [];\n    index.forEach(function(i) {\n      var d;\n      arcs[i] = {\n        data: data[i],\n        value: d = values[i],\n        startAngle: a,\n        endAngle: a += d * k\n      };\n    });\n    return arcs;\n  }\n\n  /**\n   * Specifies the value function *x*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `Number`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  pie.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return pie;\n  };\n\n  /**\n   * Specifies a sort comparison operator *x*. The comparator is passed two data\n   * elements from the data array, a and b; it returns a negative value if a is\n   * less than b, a positive value if a is greater than b, and zero if a equals\n   * b.\n   */\n  pie.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall start angle of the pie chart. Defaults to 0. The\n   * start angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.startAngle = function(x) {\n    if (!arguments.length) return startAngle;\n    startAngle = x;\n    return pie;\n  };\n\n  /**\n   * Specifies the overall end angle of the pie chart. Defaults to 2π. The\n   * end angle can be specified either as a constant or as a function; in the\n   * case of a function, it is evaluated once per array (as opposed to per\n   * element).\n   */\n  pie.endAngle = function(x) {\n    if (!arguments.length) return endAngle;\n    endAngle = x;\n    return pie;\n  };\n\n  return pie;\n};\n\nvar d3_layout_pieSortByValue = {};\n// data is two-dimensional array of x,y; we populate y0\nd3.layout.stack = function() {\n  var values = d3_identity,\n      order = d3_layout_stackOrderDefault,\n      offset = d3_layout_stackOffsetZero,\n      out = d3_layout_stackOut,\n      x = d3_layout_stackX,\n      y = d3_layout_stackY;\n\n  function stack(data, index) {\n\n    // Convert series to canonical two-dimensional representation.\n    var series = data.map(function(d, i) {\n      return values.call(stack, d, i);\n    });\n\n    // Convert each series to canonical [[x,y]] representation.\n    var points = series.map(function(d, i) {\n      return d.map(function(v, i) {\n        return [x.call(stack, v, i), y.call(stack, v, i)];\n      });\n    });\n\n    // Compute the order of series, and permute them.\n    var orders = order.call(stack, points, index);\n    series = d3.permute(series, orders);\n    points = d3.permute(points, orders);\n\n    // Compute the baseline…\n    var offsets = offset.call(stack, points, index);\n\n    // And propagate it to other series.\n    var n = series.length,\n        m = series[0].length,\n        i,\n        j,\n        o;\n    for (j = 0; j < m; ++j) {\n      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n      for (i = 1; i < n; ++i) {\n        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n      }\n    }\n\n    return data;\n  }\n\n  stack.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return stack;\n  };\n\n  stack.order = function(x) {\n    if (!arguments.length) return order;\n    order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n    return stack;\n  };\n\n  stack.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n    return stack;\n  };\n\n  stack.x = function(z) {\n    if (!arguments.length) return x;\n    x = z;\n    return stack;\n  };\n\n  stack.y = function(z) {\n    if (!arguments.length) return y;\n    y = z;\n    return stack;\n  };\n\n  stack.out = function(z) {\n    if (!arguments.length) return out;\n    out = z;\n    return stack;\n  };\n\n  return stack;\n}\n\nfunction d3_layout_stackX(d) {\n  return d.x;\n}\n\nfunction d3_layout_stackY(d) {\n  return d.y;\n}\n\nfunction d3_layout_stackOut(d, y0, y) {\n  d.y0 = y0;\n  d.y1 = y0+y;\n  d.y = y;\n}\n\nvar d3_layout_stackOrders = d3.map({\n\n  \"inside-out\": function(data) {\n    var n = data.length,\n        i,\n        j,\n        max = data.map(d3_layout_stackMaxIndex),\n        sums = data.map(d3_layout_stackReduceSum),\n        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),\n        top = 0,\n        bottom = 0,\n        tops = [],\n        bottoms = [];\n    for (i = 0; i < n; ++i) {\n      j = index[i];\n      if (top < bottom) {\n        top += sums[j];\n        tops.push(j);\n      } else {\n        bottom += sums[j];\n        bottoms.push(j);\n      }\n    }\n    return bottoms.reverse().concat(tops);\n  },\n\n  \"reverse\": function(data) {\n    return d3.range(data.length).reverse();\n  },\n\n  \"default\": d3_layout_stackOrderDefault\n\n});\n\nvar d3_layout_stackOffsets = d3.map({\n\n  \"silhouette\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        sums = [],\n        max = 0,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o > max) max = o;\n      sums.push(o);\n    }\n    for (j = 0; j < m; ++j) {\n      y0[j] = (max - sums[j]) / 2;\n    }\n    return y0;\n  },\n\n  \"wiggle\": function(data) {\n    var n = data.length,\n        x = data[0],\n        m = x.length,\n        max = 0,\n        i,\n        j,\n        k,\n        s1,\n        s2,\n        s3,\n        dx,\n        o,\n        o0,\n        y0 = [];\n    y0[0] = o = o0 = 0;\n    for (j = 1; j < m; ++j) {\n      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n        }\n        s2 += s3 * data[i][j][1];\n      }\n      y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n      if (o < o0) o0 = o;\n    }\n    for (j = 0; j < m; ++j) y0[j] -= o0;\n    return y0;\n  },\n\n  \"expand\": function(data) {\n    var n = data.length,\n        m = data[0].length,\n        k = 1 / n,\n        i,\n        j,\n        o,\n        y0 = [];\n    for (j = 0; j < m; ++j) {\n      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;\n      else for (i = 0; i < n; i++) data[i][j][1] = k;\n    }\n    for (j = 0; j < m; ++j) y0[j] = 0;\n    return y0;\n  },\n\n  \"zero\": d3_layout_stackOffsetZero\n\n});\n\nfunction d3_layout_stackOrderDefault(data) {\n  return d3.range(data.length);\n}\n\nfunction d3_layout_stackOffsetZero(data) {\n  var j = -1,\n      m = data[0].length,\n      y0 = [];\n  while (++j < m) y0[j] = 0;\n  return y0;\n}\n\nfunction d3_layout_stackMaxIndex(array) {\n  var i = 1,\n      j = 0,\n      v = array[0][1],\n      k,\n      n = array.length;\n  for (; i < n; ++i) {\n    if ((k = array[i][1]) > v) {\n      j = i;\n      v = k;\n    }\n  }\n  return j;\n}\n\nfunction d3_layout_stackReduceSum(d) {\n  return d.reduce(d3_layout_stackSum, 0);\n}\n\nfunction d3_layout_stackSum(p, d) {\n  return p + d[1];\n}\nd3.layout.histogram = function() {\n  var frequency = true,\n      valuer = Number,\n      ranger = d3_layout_histogramRange,\n      binner = d3_layout_histogramBinSturges;\n\n  function histogram(data, i) {\n    var bins = [],\n        values = data.map(valuer, this),\n        range = ranger.call(this, values, i),\n        thresholds = binner.call(this, range, values, i),\n        bin,\n        i = -1,\n        n = values.length,\n        m = thresholds.length - 1,\n        k = frequency ? 1 : 1 / n,\n        x;\n\n    // Initialize the bins.\n    while (++i < m) {\n      bin = bins[i] = [];\n      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n      bin.y = 0;\n    }\n\n    // Fill the bins, ignoring values outside the range.\n    if (m > 0) {\n      i = -1; while(++i < n) {\n        x = values[i];\n        if ((x >= range[0]) && (x <= range[1])) {\n          bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n          bin.y += k;\n          bin.push(data[i]);\n        }\n      }\n    }\n\n    return bins;\n  }\n\n  // Specifies how to extract a value from the associated data. The default\n  // value function is `Number`, which is equivalent to the identity function.\n  histogram.value = function(x) {\n    if (!arguments.length) return valuer;\n    valuer = x;\n    return histogram;\n  };\n\n  // Specifies the range of the histogram. Values outside the specified range\n  // will be ignored. The argument `x` may be specified either as a two-element\n  // array representing the minimum and maximum value of the range, or as a\n  // function that returns the range given the array of values and the current\n  // index `i`. The default range is the extent (minimum and maximum) of the\n  // values.\n  histogram.range = function(x) {\n    if (!arguments.length) return ranger;\n    ranger = d3_functor(x);\n    return histogram;\n  };\n\n  // Specifies how to bin values in the histogram. The argument `x` may be\n  // specified as a number, in which case the range of values will be split\n  // uniformly into the given number of bins. Or, `x` may be an array of\n  // threshold values, defining the bins; the specified array must contain the\n  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`\n  // may be a function which is evaluated, being passed the range, the array of\n  // values, and the current index `i`, returning an array of thresholds. The\n  // default bin function will divide the values into uniform bins using\n  // Sturges' formula.\n  histogram.bins = function(x) {\n    if (!arguments.length) return binner;\n    binner = typeof x === \"number\"\n        ? function(range) { return d3_layout_histogramBinFixed(range, x); }\n        : d3_functor(x);\n    return histogram;\n  };\n\n  // Specifies whether the histogram's `y` value is a count (frequency) or a\n  // probability (density). The default value is true.\n  histogram.frequency = function(x) {\n    if (!arguments.length) return frequency;\n    frequency = !!x;\n    return histogram;\n  };\n\n  return histogram;\n};\n\nfunction d3_layout_histogramBinSturges(range, values) {\n  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n}\n\nfunction d3_layout_histogramBinFixed(range, n) {\n  var x = -1,\n      b = +range[0],\n      m = (range[1] - b) / n,\n      f = [];\n  while (++x <= n) f[x] = m * x + b;\n  return f;\n}\n\nfunction d3_layout_histogramRange(values) {\n  return [d3.min(values), d3.max(values)];\n}\nd3.layout.hierarchy = function() {\n  var sort = d3_layout_hierarchySort,\n      children = d3_layout_hierarchyChildren,\n      value = d3_layout_hierarchyValue;\n\n  // Recursively compute the node depth and value.\n  // Also converts the data representation into a standard hierarchy structure.\n  function recurse(data, depth, nodes) {\n    var childs = children.call(hierarchy, data, depth),\n        node = d3_layout_hierarchyInline ? data : {data: data};\n    node.depth = depth;\n    nodes.push(node);\n    if (childs && (n = childs.length)) {\n      var i = -1,\n          n,\n          c = node.children = [],\n          v = 0,\n          j = depth + 1,\n          d;\n      while (++i < n) {\n        d = recurse(childs[i], j, nodes);\n        d.parent = node;\n        c.push(d);\n        v += d.value;\n      }\n      if (sort) c.sort(sort);\n      if (value) node.value = v;\n    } else if (value) {\n      node.value = +value.call(hierarchy, data, depth) || 0;\n    }\n    return node;\n  }\n\n  // Recursively re-evaluates the node value.\n  function revalue(node, depth) {\n    var children = node.children,\n        v = 0;\n    if (children && (n = children.length)) {\n      var i = -1,\n          n,\n          j = depth + 1;\n      while (++i < n) v += revalue(children[i], j);\n    } else if (value) {\n      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;\n    }\n    if (value) node.value = v;\n    return v;\n  }\n\n  function hierarchy(d) {\n    var nodes = [];\n    recurse(d, 0, nodes);\n    return nodes;\n  }\n\n  hierarchy.sort = function(x) {\n    if (!arguments.length) return sort;\n    sort = x;\n    return hierarchy;\n  };\n\n  hierarchy.children = function(x) {\n    if (!arguments.length) return children;\n    children = x;\n    return hierarchy;\n  };\n\n  hierarchy.value = function(x) {\n    if (!arguments.length) return value;\n    value = x;\n    return hierarchy;\n  };\n\n  // Re-evaluates the `value` property for the specified hierarchy.\n  hierarchy.revalue = function(root) {\n    revalue(root, 0);\n    return root;\n  };\n\n  return hierarchy;\n};\n\n// A method assignment helper for hierarchy subclasses.\nfunction d3_layout_hierarchyRebind(object, hierarchy) {\n  d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n\n  // Add an alias for links, for convenience.\n  object.links = d3_layout_hierarchyLinks;\n\n  // If the new API is used, enabling inlining.\n  object.nodes = function(d) {\n    d3_layout_hierarchyInline = true;\n    return (object.nodes = object)(d);\n  };\n\n  return object;\n}\n\nfunction d3_layout_hierarchyChildren(d) {\n  return d.children;\n}\n\nfunction d3_layout_hierarchyValue(d) {\n  return d.value;\n}\n\nfunction d3_layout_hierarchySort(a, b) {\n  return b.value - a.value;\n}\n\n// Returns an array source+target objects for the specified nodes.\nfunction d3_layout_hierarchyLinks(nodes) {\n  return d3.merge(nodes.map(function(parent) {\n    return (parent.children || []).map(function(child) {\n      return {source: parent, target: child};\n    });\n  }));\n}\n\n// For backwards-compatibility, don't enable inlining by default.\nvar d3_layout_hierarchyInline = false;\nd3.layout.pack = function() {\n  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n      padding = 0,\n      size = [1, 1];\n\n  function pack(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    // Recursively compute the layout.\n    root.x = 0;\n    root.y = 0;\n    d3_layout_treeVisitAfter(root, function(d) { d.r = Math.sqrt(d.value); });\n    d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n\n    // Compute the scale factor the initial layout.\n    var w = size[0],\n        h = size[1],\n        k = Math.max(2 * root.r / w, 2 * root.r / h);\n\n    // When padding, recompute the layout using scaled padding.\n    if (padding > 0) {\n      var dr = padding * k / 2;\n      d3_layout_treeVisitAfter(root, function(d) { d.r += dr; });\n      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n      d3_layout_treeVisitAfter(root, function(d) { d.r -= dr; });\n      k = Math.max(2 * root.r / w, 2 * root.r / h);\n    }\n\n    // Scale the layout to fit the requested size.\n    d3_layout_packTransform(root, w / 2, h / 2, 1 / k);\n\n    return nodes;\n  }\n\n  pack.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return pack;\n  };\n\n  pack.padding = function(_) {\n    if (!arguments.length) return padding;\n    padding = +_;\n    return pack;\n  };\n\n  return d3_layout_hierarchyRebind(pack, hierarchy);\n};\n\nfunction d3_layout_packSort(a, b) {\n  return a.value - b.value;\n}\n\nfunction d3_layout_packInsert(a, b) {\n  var c = a._pack_next;\n  a._pack_next = b;\n  b._pack_prev = a;\n  b._pack_next = c;\n  c._pack_prev = b;\n}\n\nfunction d3_layout_packSplice(a, b) {\n  a._pack_next = b;\n  b._pack_prev = a;\n}\n\nfunction d3_layout_packIntersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return dr * dr - dx * dx - dy * dy > .001; // within epsilon\n}\n\nfunction d3_layout_packSiblings(node) {\n  if (!(nodes = node.children) || !(n = nodes.length)) return;\n\n  var nodes,\n      xMin = Infinity,\n      xMax = -Infinity,\n      yMin = Infinity,\n      yMax = -Infinity,\n      a, b, c, i, j, k, n;\n\n  function bound(node) {\n    xMin = Math.min(node.x - node.r, xMin);\n    xMax = Math.max(node.x + node.r, xMax);\n    yMin = Math.min(node.y - node.r, yMin);\n    yMax = Math.max(node.y + node.r, yMax);\n  }\n\n  // Create node links.\n  nodes.forEach(d3_layout_packLink);\n\n  // Create first node.\n  a = nodes[0];\n  a.x = -a.r;\n  a.y = 0;\n  bound(a);\n\n  // Create second node.\n  if (n > 1) {\n    b = nodes[1];\n    b.x = b.r;\n    b.y = 0;\n    bound(b);\n\n    // Create third node and build chain.\n    if (n > 2) {\n      c = nodes[2];\n      d3_layout_packPlace(a, b, c);\n      bound(c);\n      d3_layout_packInsert(a, c);\n      a._pack_prev = c;\n      d3_layout_packInsert(c, b);\n      b = a._pack_next;\n\n      // Now iterate through the rest.\n      for (i = 3; i < n; i++) {\n        d3_layout_packPlace(a, b, c = nodes[i]);\n\n        // Search for the closest intersection.\n        var isect = 0, s1 = 1, s2 = 1;\n        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n          if (d3_layout_packIntersects(j, c)) {\n            isect = 1;\n            break;\n          }\n        }\n        if (isect == 1) {\n          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n            if (d3_layout_packIntersects(k, c)) {\n              break;\n            }\n          }\n        }\n\n        // Update node chain.\n        if (isect) {\n          if (s1 < s2 || (s1 == s2 && b.r < a.r)) d3_layout_packSplice(a, b = j);\n          else d3_layout_packSplice(a = k, b);\n          i--;\n        } else {\n          d3_layout_packInsert(a, c);\n          b = c;\n          bound(c);\n        }\n      }\n    }\n  }\n\n  // Re-center the circles and compute the encompassing radius.\n  var cx = (xMin + xMax) / 2,\n      cy = (yMin + yMax) / 2,\n      cr = 0;\n  for (i = 0; i < n; i++) {\n    c = nodes[i];\n    c.x -= cx;\n    c.y -= cy;\n    cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n  }\n  node.r = cr;\n\n  // Remove node links.\n  nodes.forEach(d3_layout_packUnlink);\n}\n\nfunction d3_layout_packLink(node) {\n  node._pack_next = node._pack_prev = node;\n}\n\nfunction d3_layout_packUnlink(node) {\n  delete node._pack_next;\n  delete node._pack_prev;\n}\n\nfunction d3_layout_packTransform(node, x, y, k) {\n  var children = node.children;\n  node.x = (x += k * node.x);\n  node.y = (y += k * node.y);\n  node.r *= k;\n  if (children) {\n    var i = -1, n = children.length;\n    while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n  }\n}\n\nfunction d3_layout_packPlace(a, b, c) {\n  var db = a.r + c.r,\n      dx = b.x - a.x,\n      dy = b.y - a.y;\n  if (db && (dx || dy)) {\n    var da = b.r + c.r,\n        dc = dx * dx + dy * dy;\n    da *= da;\n    db *= db;\n    var x = .5 + (db - da) / (2 * dc),\n        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n    c.x = a.x + x * dx + y * dy;\n    c.y = a.y + x * dy - y * dx;\n  } else {\n    c.x = a.x + db;\n    c.y = a.y;\n  }\n}\n// Implements a hierarchical layout using the cluster (or dendrogram)\n// algorithm.\nd3.layout.cluster = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function cluster(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0],\n        previousNode,\n        x = 0,\n        kx,\n        ky;\n\n    // First walk, computing the initial x & y values.\n    d3_layout_treeVisitAfter(root, function(node) {\n      var children = node.children;\n      if (children && children.length) {\n        node.x = d3_layout_clusterX(children);\n        node.y = d3_layout_clusterY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_clusterLeft(root),\n        right = d3_layout_clusterRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n    });\n\n    return nodes;\n  }\n\n  cluster.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return cluster;\n  };\n\n  cluster.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return cluster;\n  };\n\n  return d3_layout_hierarchyRebind(cluster, hierarchy);\n};\n\nfunction d3_layout_clusterY(children) {\n  return 1 + d3.max(children, function(child) {\n    return child.y;\n  });\n}\n\nfunction d3_layout_clusterX(children) {\n  return children.reduce(function(x, child) {\n    return x + child.x;\n  }, 0) / children.length;\n}\n\nfunction d3_layout_clusterLeft(node) {\n  var children = node.children;\n  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n}\n\nfunction d3_layout_clusterRight(node) {\n  var children = node.children, n;\n  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n}\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nd3.layout.tree = function() {\n  var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n      separation = d3_layout_treeSeparation,\n      size = [1, 1]; // width, height\n\n  function tree(d, i) {\n    var nodes = hierarchy.call(this, d, i),\n        root = nodes[0];\n\n    function firstWalk(node, previousSibling) {\n      var children = node.children,\n          layout = node._tree;\n      if (children && (n = children.length)) {\n        var n,\n            firstChild = children[0],\n            previousChild,\n            ancestor = firstChild,\n            child,\n            i = -1;\n        while (++i < n) {\n          child = children[i];\n          firstWalk(child, previousChild);\n          ancestor = apportion(child, previousChild, ancestor);\n          previousChild = child;\n        }\n        d3_layout_treeShift(node);\n        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n          layout.mod = layout.prelim - midpoint;\n        } else {\n          layout.prelim = midpoint;\n        }\n      } else {\n        if (previousSibling) {\n          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n        }\n      }\n    }\n\n    function secondWalk(node, x) {\n      node.x = node._tree.prelim + x;\n      var children = node.children;\n      if (children && (n = children.length)) {\n        var i = -1,\n            n;\n        x += node._tree.mod;\n        while (++i < n) {\n          secondWalk(children[i], x);\n        }\n      }\n    }\n\n    function apportion(node, previousSibling, ancestor) {\n      if (previousSibling) {\n        var vip = node,\n            vop = node,\n            vim = previousSibling,\n            vom = node.parent.children[0],\n            sip = vip._tree.mod,\n            sop = vop._tree.mod,\n            sim = vim._tree.mod,\n            som = vom._tree.mod,\n            shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop._tree.ancestor = node;\n          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim._tree.mod;\n          sip += vip._tree.mod;\n          som += vom._tree.mod;\n          sop += vop._tree.mod;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop._tree.thread = vim;\n          vop._tree.mod += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom._tree.thread = vip;\n          vom._tree.mod += sip - som;\n          ancestor = node;\n        }\n      }\n      return ancestor;\n    }\n\n    // Initialize temporary layout variables.\n    d3_layout_treeVisitAfter(root, function(node, previousSibling) {\n      node._tree = {\n        ancestor: node,\n        prelim: 0,\n        mod: 0,\n        change: 0,\n        shift: 0,\n        number: previousSibling ? previousSibling._tree.number + 1 : 0\n      };\n    });\n\n    // Compute the layout using Buchheim et al.'s algorithm.\n    firstWalk(root);\n    secondWalk(root, -root._tree.prelim);\n\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\n        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\n        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2,\n        y1 = deep.depth || 1;\n\n    // Clear temporary layout variables; transform x and y.\n    d3_layout_treeVisitAfter(root, function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * size[0];\n      node.y = node.depth / y1 * size[1];\n      delete node._tree;\n    });\n\n    return nodes;\n  }\n\n  tree.separation = function(x) {\n    if (!arguments.length) return separation;\n    separation = x;\n    return tree;\n  };\n\n  tree.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return tree;\n  };\n\n  return d3_layout_hierarchyRebind(tree, hierarchy);\n};\n\nfunction d3_layout_treeSeparation(a, b) {\n  return a.parent == b.parent ? 1 : 2;\n}\n\n// function d3_layout_treeSeparationRadial(a, b) {\n//   return (a.parent == b.parent ? 1 : 2) / a.depth;\n// }\n\nfunction d3_layout_treeLeft(node) {\n  var children = node.children;\n  return children && children.length ? children[0] : node._tree.thread;\n}\n\nfunction d3_layout_treeRight(node) {\n  var children = node.children,\n      n;\n  return children && (n = children.length) ? children[n - 1] : node._tree.thread;\n}\n\nfunction d3_layout_treeSearch(node, compare) {\n  var children = node.children;\n  if (children && (n = children.length)) {\n    var child,\n        n,\n        i = -1;\n    while (++i < n) {\n      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\n        node = child;\n      }\n    }\n  }\n  return node;\n}\n\nfunction d3_layout_treeRightmost(a, b) {\n  return a.x - b.x;\n}\n\nfunction d3_layout_treeLeftmost(a, b) {\n  return b.x - a.x;\n}\n\nfunction d3_layout_treeDeepest(a, b) {\n  return a.depth - b.depth;\n}\n\nfunction d3_layout_treeVisitAfter(node, callback) {\n  function visit(node, previousSibling) {\n    var children = node.children;\n    if (children && (n = children.length)) {\n      var child,\n          previousChild = null,\n          i = -1,\n          n;\n      while (++i < n) {\n        child = children[i];\n        visit(child, previousChild);\n        previousChild = child;\n      }\n    }\n    callback(node, previousSibling);\n  }\n  visit(node, null);\n}\n\nfunction d3_layout_treeShift(node) {\n  var shift = 0,\n      change = 0,\n      children = node.children,\n      i = children.length,\n      child;\n  while (--i >= 0) {\n    child = children[i]._tree;\n    child.prelim += shift;\n    child.mod += shift;\n    shift += child.shift + (change += child.change);\n  }\n}\n\nfunction d3_layout_treeMove(ancestor, node, shift) {\n  ancestor = ancestor._tree;\n  node = node._tree;\n  var change = shift / (node.number - ancestor.number);\n  ancestor.change += change;\n  node.change -= change;\n  node.shift += shift;\n  node.prelim += shift;\n  node.mod += shift;\n}\n\nfunction d3_layout_treeAncestor(vim, node, ancestor) {\n  return vim._tree.ancestor.parent == node.parent\n      ? vim._tree.ancestor\n      : ancestor;\n}\n// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n// Modified to support a target aspect ratio by Jeff Heer\nd3.layout.treemap = function() {\n  var hierarchy = d3.layout.hierarchy(),\n      round = Math.round,\n      size = [1, 1], // width, height\n      padding = null,\n      pad = d3_layout_treemapPadNull,\n      sticky = false,\n      stickies,\n      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio\n\n  // Compute the area for each child based on value & scale.\n  function scale(children, k) {\n    var i = -1,\n        n = children.length,\n        child,\n        area;\n    while (++i < n) {\n      area = (child = children[i]).value * (k < 0 ? 0 : k);\n      child.area = isNaN(area) || area <= 0 ? 0 : area;\n    }\n  }\n\n  // Recursively arranges the specified node's children into squarified rows.\n  function squarify(node) {\n    var children = node.children;\n    if (children && children.length) {\n      var rect = pad(node),\n          row = [],\n          remaining = children.slice(), // copy-on-write\n          child,\n          best = Infinity, // the best row score so far\n          score, // the current row score\n          u = Math.min(rect.dx, rect.dy), // initial orientation\n          n;\n      scale(remaining, rect.dx * rect.dy / node.value);\n      row.area = 0;\n      while ((n = remaining.length) > 0) {\n        row.push(child = remaining[n - 1]);\n        row.area += child.area;\n        if ((score = worst(row, u)) <= best) { // continue with this orientation\n          remaining.pop();\n          best = score;\n        } else { // abort, and try a different orientation\n          row.area -= row.pop().area;\n          position(row, u, rect, false);\n          u = Math.min(rect.dx, rect.dy);\n          row.length = row.area = 0;\n          best = Infinity;\n        }\n      }\n      if (row.length) {\n        position(row, u, rect, true);\n        row.length = row.area = 0;\n      }\n      children.forEach(squarify);\n    }\n  }\n\n  // Recursively resizes the specified node's children into existing rows.\n  // Preserves the existing layout!\n  function stickify(node) {\n    var children = node.children;\n    if (children && children.length) {\n      var rect = pad(node),\n          remaining = children.slice(), // copy-on-write\n          child,\n          row = [];\n      scale(remaining, rect.dx * rect.dy / node.value);\n      row.area = 0;\n      while (child = remaining.pop()) {\n        row.push(child);\n        row.area += child.area;\n        if (child.z != null) {\n          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n          row.length = row.area = 0;\n        }\n      }\n      children.forEach(stickify);\n    }\n  }\n\n  // Computes the score for the specified row, as the worst aspect ratio.\n  function worst(row, u) {\n    var s = row.area,\n        r,\n        rmax = 0,\n        rmin = Infinity,\n        i = -1,\n        n = row.length;\n    while (++i < n) {\n      if (!(r = row[i].area)) continue;\n      if (r < rmin) rmin = r;\n      if (r > rmax) rmax = r;\n    }\n    s *= s;\n    u *= u;\n    return s\n        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))\n        : Infinity;\n  }\n\n  // Positions the specified row of nodes. Modifies `rect`.\n  function position(row, u, rect, flush) {\n    var i = -1,\n        n = row.length,\n        x = rect.x,\n        y = rect.y,\n        v = u ? round(row.area / u) : 0,\n        o;\n    if (u == rect.dx) { // horizontal subdivision\n      if (flush || v > rect.dy) v = rect.dy; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dy = v;\n        x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n      }\n      o.z = true;\n      o.dx += rect.x + rect.dx - x; // rounding error\n      rect.y += v;\n      rect.dy -= v;\n    } else { // vertical subdivision\n      if (flush || v > rect.dx) v = rect.dx; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dx = v;\n        y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n      }\n      o.z = false;\n      o.dy += rect.y + rect.dy - y; // rounding error\n      rect.x += v;\n      rect.dx -= v;\n    }\n  }\n\n  function treemap(d) {\n    var nodes = stickies || hierarchy(d),\n        root = nodes[0];\n    root.x = 0;\n    root.y = 0;\n    root.dx = size[0];\n    root.dy = size[1];\n    if (stickies) hierarchy.revalue(root);\n    scale([root], root.dx * root.dy / root.value);\n    (stickies ? stickify : squarify)(root);\n    if (sticky) stickies = nodes;\n    return nodes;\n  }\n\n  treemap.size = function(x) {\n    if (!arguments.length) return size;\n    size = x;\n    return treemap;\n  };\n\n  treemap.padding = function(x) {\n    if (!arguments.length) return padding;\n\n    function padFunction(node) {\n      var p = x.call(treemap, node, node.depth);\n      return p == null\n          ? d3_layout_treemapPadNull(node)\n          : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\n    }\n\n    function padConstant(node) {\n      return d3_layout_treemapPad(node, x);\n    }\n\n    var type;\n    pad = (padding = x) == null ? d3_layout_treemapPadNull\n        : (type = typeof x) === \"function\" ? padFunction\n        : type === \"number\" ? (x = [x, x, x, x], padConstant)\n        : padConstant;\n    return treemap;\n  };\n\n  treemap.round = function(x) {\n    if (!arguments.length) return round != Number;\n    round = x ? Math.round : Number;\n    return treemap;\n  };\n\n  treemap.sticky = function(x) {\n    if (!arguments.length) return sticky;\n    sticky = x;\n    stickies = null;\n    return treemap;\n  };\n\n  treemap.ratio = function(x) {\n    if (!arguments.length) return ratio;\n    ratio = x;\n    return treemap;\n  };\n\n  return d3_layout_hierarchyRebind(treemap, hierarchy);\n};\n\nfunction d3_layout_treemapPadNull(node) {\n  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};\n}\n\nfunction d3_layout_treemapPad(node, padding) {\n  var x = node.x + padding[3],\n      y = node.y + padding[0],\n      dx = node.dx - padding[1] - padding[3],\n      dy = node.dy - padding[0] - padding[2];\n  if (dx < 0) { x += dx / 2; dx = 0; }\n  if (dy < 0) { y += dy / 2; dy = 0; }\n  return {x: x, y: y, dx: dx, dy: dy};\n}\nfunction d3_dsv(delimiter, mimeType) {\n  var reParse = new RegExp(\"\\r\\n|[\" + delimiter + \"\\r\\n]\", \"g\"), // field separator regex\n      reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function dsv(url, callback) {\n    d3.text(url, mimeType, function(text) {\n      callback(text && dsv.parse(text));\n    });\n  }\n\n  dsv.parse = function(text) {\n    var header;\n    return dsv.parseRows(text, function(row, i) {\n      if (i) {\n        var o = {}, j = -1, m = header.length;\n        while (++j < m) o[header[j]] = j < row.length ? row[j] : null;\n        return o;\n      } else {\n        header = row;\n        return null;\n      }\n    });\n  };\n\n  dsv.parseRows = function(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    reParse.lastIndex = 0; // work-around bug in FF 3.6\n\n    function token() {\n      if (reParse.lastIndex >= text.length) return EOF; // special case: end of file\n      if (eol) { eol = false; return EOL; } // special case: end of line\n\n      // special case: quotes\n      var j = reParse.lastIndex;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < text.length) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            i++;\n          }\n        }\n        reParse.lastIndex = i + 2;\n        var c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) reParse.lastIndex++;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.substring(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case\n      var m = reParse.exec(text);\n      if (m) {\n        eol = m[0].charCodeAt(0) !== delimiterCode;\n        return text.substring(j, m.index);\n      }\n      reParse.lastIndex = text.length;\n      return text.substring(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while ((t !== EOL) && (t !== EOF)) {\n        a.push(t);\n        t = token();\n      }\n      if (f && !(a = f(a, n++))) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  };\n\n  dsv.format = function(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  };\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return reFormat.test(text) ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n  }\n\n  return dsv;\n}\nd3.csv = d3_dsv(\",\", \"text/csv\");\nd3.tsv = d3_dsv(\"\\t\", \"text/tab-separated-values\");\nd3.geo = {};\n\nvar d3_geo_radians = Math.PI / 180;\n// TODO clip input coordinates on opposite hemisphere\nd3.geo.azimuthal = function() {\n  var mode = \"orthographic\", // or stereographic, gnomonic, equidistant or equalarea\n      origin,\n      scale = 200,\n      translate = [480, 250],\n      x0,\n      y0,\n      cy0,\n      sy0;\n\n  function azimuthal(coordinates) {\n    var x1 = coordinates[0] * d3_geo_radians - x0,\n        y1 = coordinates[1] * d3_geo_radians,\n        cx1 = Math.cos(x1),\n        sx1 = Math.sin(x1),\n        cy1 = Math.cos(y1),\n        sy1 = Math.sin(y1),\n        cc = mode !== \"orthographic\" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,\n        c,\n        k = mode === \"stereographic\" ? 1 / (1 + cc)\n          : mode === \"gnomonic\" ? 1 / cc\n          : mode === \"equidistant\" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0)\n          : mode === \"equalarea\" ? Math.sqrt(2 / (1 + cc))\n          : 1,\n        x = k * cy1 * sx1,\n        y = k * (sy0 * cy1 * cx1 - cy0 * sy1);\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  azimuthal.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale,\n        p = Math.sqrt(x * x + y * y),\n        c = mode === \"stereographic\" ? 2 * Math.atan(p)\n          : mode === \"gnomonic\" ? Math.atan(p)\n          : mode === \"equidistant\" ? p\n          : mode === \"equalarea\" ? 2 * Math.asin(.5 * p)\n          : Math.asin(p),\n        sc = Math.sin(c),\n        cc = Math.cos(c);\n    return [\n      (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians,\n      Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians\n    ];\n  };\n\n  azimuthal.mode = function(x) {\n    if (!arguments.length) return mode;\n    mode = x + \"\";\n    return azimuthal;\n  };\n\n  azimuthal.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    x0 = origin[0] * d3_geo_radians;\n    y0 = origin[1] * d3_geo_radians;\n    cy0 = Math.cos(y0);\n    sy0 = Math.sin(y0);\n    return azimuthal;\n  };\n\n  azimuthal.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return azimuthal;\n  };\n\n  azimuthal.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return azimuthal;\n  };\n\n  return azimuthal.origin([0, 0]);\n};\n// Derived from Tom Carden's Albers implementation for Protovis.\n// http://gist.github.com/476238\n// http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\n\nd3.geo.albers = function() {\n  var origin = [-98, 38],\n      parallels = [29.5, 45.5],\n      scale = 1000,\n      translate = [480, 250],\n      lng0, // d3_geo_radians * origin[0]\n      n,\n      C,\n      p0;\n\n  function albers(coordinates) {\n    var t = n * (d3_geo_radians * coordinates[0] - lng0),\n        p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;\n    return [\n      scale * p * Math.sin(t) + translate[0],\n      scale * (p * Math.cos(t) - p0) + translate[1]\n    ];\n  }\n\n  albers.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale,\n        p0y = p0 + y,\n        t = Math.atan2(x, p0y),\n        p = Math.sqrt(x * x + p0y * p0y);\n    return [\n      (lng0 + t / n) / d3_geo_radians,\n      Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians\n    ];\n  };\n\n  function reload() {\n    var phi1 = d3_geo_radians * parallels[0],\n        phi2 = d3_geo_radians * parallels[1],\n        lat0 = d3_geo_radians * origin[1],\n        s = Math.sin(phi1),\n        c = Math.cos(phi1);\n    lng0 = d3_geo_radians * origin[0];\n    n = .5 * (s + Math.sin(phi2));\n    C = c * c + 2 * n * s;\n    p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;\n    return albers;\n  }\n\n  albers.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = [+x[0], +x[1]];\n    return reload();\n  };\n\n  albers.parallels = function(x) {\n    if (!arguments.length) return parallels;\n    parallels = [+x[0], +x[1]];\n    return reload();\n  };\n\n  albers.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return albers;\n  };\n\n  albers.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return albers;\n  };\n\n  return reload();\n};\n\n// A composite projection for the United States, 960x500. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n// TODO allow the composite projection to be rescaled?\nd3.geo.albersUsa = function() {\n  var lower48 = d3.geo.albers();\n\n  var alaska = d3.geo.albers()\n      .origin([-160, 60])\n      .parallels([55, 65]);\n\n  var hawaii = d3.geo.albers()\n      .origin([-160, 20])\n      .parallels([8, 18]);\n\n  var puertoRico = d3.geo.albers()\n      .origin([-60, 10])\n      .parallels([8, 18]);\n\n  function albersUsa(coordinates) {\n    var lon = coordinates[0],\n        lat = coordinates[1];\n    return (lat > 50 ? alaska\n        : lon < -140 ? hawaii\n        : lat < 21 ? puertoRico\n        : lower48)(coordinates);\n  }\n\n  albersUsa.scale = function(x) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(x);\n    alaska.scale(x * .6);\n    hawaii.scale(x);\n    puertoRico.scale(x * 1.5);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(x) {\n    if (!arguments.length) return lower48.translate();\n    var dz = lower48.scale() / 1000,\n        dx = x[0],\n        dy = x[1];\n    lower48.translate(x);\n    alaska.translate([dx - 400 * dz, dy + 170 * dz]);\n    hawaii.translate([dx - 190 * dz, dy + 200 * dz]);\n    puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);\n    return albersUsa;\n  };\n\n  return albersUsa.scale(lower48.scale());\n};\nd3.geo.bonne = function() {\n  var scale = 200,\n      translate = [480, 250],\n      x0, // origin longitude in radians\n      y0, // origin latitude in radians\n      y1, // parallel latitude in radians\n      c1; // cot(y1)\n\n  function bonne(coordinates) {\n    var x = coordinates[0] * d3_geo_radians - x0,\n        y = coordinates[1] * d3_geo_radians - y0;\n    if (y1) {\n      var p = c1 + y1 - y, E = x * Math.cos(y) / p;\n      x = p * Math.sin(E);\n      y = p * Math.cos(E) - c1;\n    } else {\n      x *= Math.cos(y);\n      y *= -1;\n    }\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  bonne.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    if (y1) {\n      var c = c1 + y, p = Math.sqrt(x * x + c * c);\n      y = c1 + y1 - p;\n      x = x0 + p * Math.atan2(x, c) / Math.cos(y);\n    } else {\n      y *= -1;\n      x /= Math.cos(y);\n    }\n    return [\n      x / d3_geo_radians,\n      y / d3_geo_radians\n    ];\n  };\n\n  // 90° for Werner, 0° for Sinusoidal\n  bonne.parallel = function(x) {\n    if (!arguments.length) return y1 / d3_geo_radians;\n    c1 = 1 / Math.tan(y1 = x * d3_geo_radians);\n    return bonne;\n  };\n\n  bonne.origin = function(x) {\n    if (!arguments.length) return [x0 / d3_geo_radians, y0 / d3_geo_radians];\n    x0 = x[0] * d3_geo_radians;\n    y0 = x[1] * d3_geo_radians;\n    return bonne;\n  };\n\n  bonne.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return bonne;\n  };\n\n  bonne.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return bonne;\n  };\n\n  return bonne.origin([0, 0]).parallel(45);\n};\nd3.geo.equirectangular = function() {\n  var scale = 500,\n      translate = [480, 250];\n\n  function equirectangular(coordinates) {\n    var x = coordinates[0] / 360,\n        y = -coordinates[1] / 360;\n    return [\n      scale * x + translate[0],\n      scale * y + translate[1]\n    ];\n  }\n\n  equirectangular.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    return [\n      360 * x,\n      -360 * y\n    ];\n  };\n\n  equirectangular.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return equirectangular;\n  };\n\n  equirectangular.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return equirectangular;\n  };\n\n  return equirectangular;\n};\nd3.geo.mercator = function() {\n  var scale = 500,\n      translate = [480, 250];\n\n  function mercator(coordinates) {\n    var x = coordinates[0] / 360,\n        y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;\n    return [\n      scale * x + translate[0],\n      scale * Math.max(-.5, Math.min(.5, y)) + translate[1]\n    ];\n  }\n\n  mercator.invert = function(coordinates) {\n    var x = (coordinates[0] - translate[0]) / scale,\n        y = (coordinates[1] - translate[1]) / scale;\n    return [\n      360 * x,\n      2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90\n    ];\n  };\n\n  mercator.scale = function(x) {\n    if (!arguments.length) return scale;\n    scale = +x;\n    return mercator;\n  };\n\n  mercator.translate = function(x) {\n    if (!arguments.length) return translate;\n    translate = [+x[0], +x[1]];\n    return mercator;\n  };\n\n  return mercator;\n};\nfunction d3_geo_type(types, defaultValue) {\n  return function(object) {\n    return object && types.hasOwnProperty(object.type) ? types[object.type](object) : defaultValue;\n  };\n}\n/**\n * Returns a function that, given a GeoJSON object (e.g., a feature), returns\n * the corresponding SVG path. The function can be customized by overriding the\n * projection. Point features are mapped to circles with a default radius of\n * 4.5px; the radius can be specified either as a constant or a function that\n * is evaluated per object.\n */\nd3.geo.path = function() {\n  var pointRadius = 4.5,\n      pointCircle = d3_path_circle(pointRadius),\n      projection = d3.geo.albersUsa(),\n      buffer = [];\n\n  function path(d, i) {\n    if (typeof pointRadius === \"function\") pointCircle = d3_path_circle(pointRadius.apply(this, arguments));\n    pathType(d);\n    var result = buffer.length ? buffer.join(\"\") : null;\n    buffer = [];\n    return result;\n  }\n\n  function project(coordinates) {\n    return projection(coordinates).join(\",\");\n  }\n\n  var pathType = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var features = o.features,\n          i = -1, // features.index\n          n = features.length;\n      while (++i < n) buffer.push(pathType(features[i].geometry));\n    },\n\n    Feature: function(o) {\n      pathType(o.geometry);\n    },\n\n    Point: function(o) {\n      buffer.push(\"M\", project(o.coordinates), pointCircle);\n    },\n\n    MultiPoint: function(o) {\n      var coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length;\n      while (++i < n) buffer.push(\"M\", project(coordinates[i]), pointCircle);\n    },\n\n    LineString: function(o) {\n      var coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length;\n      buffer.push(\"M\");\n      while (++i < n) buffer.push(project(coordinates[i]), \"L\");\n      buffer.pop();\n    },\n\n    MultiLineString: function(o) {\n      var coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates.index\n          m; // subcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        m = subcoordinates.length;\n        buffer.push(\"M\");\n        while (++j < m) buffer.push(project(subcoordinates[j]), \"L\");\n        buffer.pop();\n      }\n    },\n\n    Polygon: function(o) {\n      var coordinates = o.coordinates,\n          i = -1, // coordinates.index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates.index\n          m; // subcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        if ((m = subcoordinates.length - 1) > 0) {\n          buffer.push(\"M\");\n          while (++j < m) buffer.push(project(subcoordinates[j]), \"L\");\n          buffer[buffer.length - 1] = \"Z\";\n        }\n      }\n    },\n\n    MultiPolygon: function(o) {\n      var coordinates = o.coordinates,\n          i = -1, // coordinates index\n          n = coordinates.length,\n          subcoordinates, // coordinates[i]\n          j, // subcoordinates index\n          m, // subcoordinates.length\n          subsubcoordinates, // subcoordinates[j]\n          k, // subsubcoordinates index\n          p; // subsubcoordinates.length\n      while (++i < n) {\n        subcoordinates = coordinates[i];\n        j = -1;\n        m = subcoordinates.length;\n        while (++j < m) {\n          subsubcoordinates = subcoordinates[j];\n          k = -1;\n          if ((p = subsubcoordinates.length - 1) > 0) {\n            buffer.push(\"M\");\n            while (++k < p) buffer.push(project(subsubcoordinates[k]), \"L\");\n            buffer[buffer.length - 1] = \"Z\";\n          }\n        }\n      }\n    },\n\n    GeometryCollection: function(o) {\n      var geometries = o.geometries,\n          i = -1, // geometries index\n          n = geometries.length;\n      while (++i < n) buffer.push(pathType(geometries[i]));\n    }\n\n  });\n\n  var areaType = path.area = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var area = 0,\n          features = o.features,\n          i = -1, // features.index\n          n = features.length;\n      while (++i < n) area += areaType(features[i]);\n      return area;\n    },\n\n    Feature: function(o) {\n      return areaType(o.geometry);\n    },\n\n    Polygon: function(o) {\n      return polygonArea(o.coordinates);\n    },\n\n    MultiPolygon: function(o) {\n      var sum = 0,\n          coordinates = o.coordinates,\n          i = -1, // coordinates index\n          n = coordinates.length;\n      while (++i < n) sum += polygonArea(coordinates[i]);\n      return sum;\n    },\n\n    GeometryCollection: function(o) {\n      var sum = 0,\n          geometries = o.geometries,\n          i = -1, // geometries index\n          n = geometries.length;\n      while (++i < n) sum += areaType(geometries[i]);\n      return sum;\n    }\n\n  }, 0);\n\n  function polygonArea(coordinates) {\n    var sum = area(coordinates[0]), // exterior ring\n        i = 0, // coordinates.index\n        n = coordinates.length;\n    while (++i < n) sum -= area(coordinates[i]); // holes\n    return sum;\n  }\n\n  function polygonCentroid(coordinates) {\n    var polygon = d3.geom.polygon(coordinates[0].map(projection)), // exterior ring\n        area = polygon.area(),\n        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1),\n        x = centroid[0],\n        y = centroid[1],\n        z = area,\n        i = 0, // coordinates index\n        n = coordinates.length;\n    while (++i < n) {\n      polygon = d3.geom.polygon(coordinates[i].map(projection)); // holes\n      area = polygon.area();\n      centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);\n      x -= centroid[0];\n      y -= centroid[1];\n      z -= area;\n    }\n    return [x, y, 6 * z]; // weighted centroid\n  }\n\n  var centroidType = path.centroid = d3_geo_type({\n\n    // TODO FeatureCollection\n    // TODO Point\n    // TODO MultiPoint\n    // TODO LineString\n    // TODO MultiLineString\n    // TODO GeometryCollection\n\n    Feature: function(o) {\n      return centroidType(o.geometry);\n    },\n\n    Polygon: function(o) {\n      var centroid = polygonCentroid(o.coordinates);\n      return [centroid[0] / centroid[2], centroid[1] / centroid[2]];\n    },\n\n    MultiPolygon: function(o) {\n      var area = 0,\n          coordinates = o.coordinates,\n          centroid,\n          x = 0,\n          y = 0,\n          z = 0,\n          i = -1, // coordinates index\n          n = coordinates.length;\n      while (++i < n) {\n        centroid = polygonCentroid(coordinates[i]);\n        x += centroid[0];\n        y += centroid[1];\n        z += centroid[2];\n      }\n      return [x / z, y / z];\n    }\n\n  });\n\n  function area(coordinates) {\n    return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());\n  }\n\n  path.projection = function(x) {\n    projection = x;\n    return path;\n  };\n\n  path.pointRadius = function(x) {\n    if (typeof x === \"function\") pointRadius = x;\n    else {\n      pointRadius = +x;\n      pointCircle = d3_path_circle(pointRadius);\n    }\n    return path;\n  };\n\n  return path;\n};\n\nfunction d3_path_circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + (-2 * radius)\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + (+2 * radius)\n      + \"z\";\n}\n/**\n * Given a GeoJSON object, returns the corresponding bounding box. The bounding\n * box is represented by a two-dimensional array: [[left, bottom], [right,\n * top]], where left is the minimum longitude, bottom is the minimum latitude,\n * right is maximum longitude, and top is the maximum latitude.\n */\nd3.geo.bounds = function(feature) {\n  var left = Infinity,\n      bottom = Infinity,\n      right = -Infinity,\n      top = -Infinity;\n  d3_geo_bounds(feature, function(x, y) {\n    if (x < left) left = x;\n    if (x > right) right = x;\n    if (y < bottom) bottom = y;\n    if (y > top) top = y;\n  });\n  return [[left, bottom], [right, top]];\n};\n\nfunction d3_geo_bounds(o, f) {\n  if (d3_geo_boundsTypes.hasOwnProperty(o.type)) d3_geo_boundsTypes[o.type](o, f);\n}\n\nvar d3_geo_boundsTypes = {\n  Feature: d3_geo_boundsFeature,\n  FeatureCollection: d3_geo_boundsFeatureCollection,\n  GeometryCollection: d3_geo_boundsGeometryCollection,\n  LineString: d3_geo_boundsLineString,\n  MultiLineString: d3_geo_boundsMultiLineString,\n  MultiPoint: d3_geo_boundsLineString,\n  MultiPolygon: d3_geo_boundsMultiPolygon,\n  Point: d3_geo_boundsPoint,\n  Polygon: d3_geo_boundsPolygon\n};\n\nfunction d3_geo_boundsFeature(o, f) {\n  d3_geo_bounds(o.geometry, f);\n}\n\nfunction d3_geo_boundsFeatureCollection(o, f) {\n  for (var a = o.features, i = 0, n = a.length; i < n; i++) {\n    d3_geo_bounds(a[i].geometry, f);\n  }\n}\n\nfunction d3_geo_boundsGeometryCollection(o, f) {\n  for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {\n    d3_geo_bounds(a[i], f);\n  }\n}\n\nfunction d3_geo_boundsLineString(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    f.apply(null, a[i]);\n  }\n}\n\nfunction d3_geo_boundsMultiLineString(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    for (var b = a[i], j = 0, m = b.length; j < m; j++) {\n      f.apply(null, b[j]);\n    }\n  }\n}\n\nfunction d3_geo_boundsMultiPolygon(o, f) {\n  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {\n    for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {\n      f.apply(null, b[j]);\n    }\n  }\n}\n\nfunction d3_geo_boundsPoint(o, f) {\n  f.apply(null, o.coordinates);\n}\n\nfunction d3_geo_boundsPolygon(o, f) {\n  for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {\n    f.apply(null, a[i]);\n  }\n}\n// TODO breakAtDateLine?\n\nd3.geo.circle = function() {\n  var origin = [0, 0],\n      degrees = 90 - 1e-2,\n      radians = degrees * d3_geo_radians,\n      arc = d3.geo.greatArc().source(origin).target(d3_identity);\n\n  function circle() {\n    // TODO render a circle as a Polygon\n  }\n\n  function visible(point) {\n    return arc.distance(point) < radians;\n  }\n\n  circle.clip = function(d) {\n    if (typeof origin === \"function\") arc.source(origin.apply(this, arguments));\n    return clipType(d) || null;\n  };\n\n  var clipType = d3_geo_type({\n\n    FeatureCollection: function(o) {\n      var features = o.features.map(clipType).filter(d3_identity);\n      return features && (o = Object.create(o), o.features = features, o);\n    },\n\n    Feature: function(o) {\n      var geometry = clipType(o.geometry);\n      return geometry && (o = Object.create(o), o.geometry = geometry, o);\n    },\n\n    Point: function(o) {\n      return visible(o.coordinates) && o;\n    },\n\n    MultiPoint: function(o) {\n      var coordinates = o.coordinates.filter(visible);\n      return coordinates.length && {\n        type: o.type,\n        coordinates: coordinates\n      };\n    },\n\n    LineString: function(o) {\n      var coordinates = clip(o.coordinates);\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    MultiLineString: function(o) {\n      var coordinates = o.coordinates.map(clip).filter(function(d) { return d.length; });\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    Polygon: function(o) {\n      var coordinates = o.coordinates.map(clip);\n      return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    MultiPolygon: function(o) {\n      var coordinates = o.coordinates.map(function(d) { return d.map(clip); }).filter(function(d) { return d[0].length; });\n      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);\n    },\n\n    GeometryCollection: function(o) {\n      var geometries = o.geometries.map(clipType).filter(d3_identity);\n      return geometries.length && (o = Object.create(o), o.geometries = geometries, o);\n    }\n\n  });\n\n  function clip(coordinates) {\n    var i = -1,\n        n = coordinates.length,\n        clipped = [],\n        p0,\n        p1,\n        p2,\n        d0,\n        d1;\n\n    while (++i < n) {\n      d1 = arc.distance(p2 = coordinates[i]);\n      if (d1 < radians) {\n        if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));\n        clipped.push(p2);\n        p0 = p1 = null;\n      } else {\n        p1 = p2;\n        if (!p0 && clipped.length) {\n          clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));\n          p0 = p1;\n        }\n      }\n      d0 = d1;\n    }\n\n    // Close the clipped polygon if necessary.\n    p0 = coordinates[0];\n    p1 = clipped[0];\n    if (p1 && p2[0] === p0[0] && p2[1] === p0[1] && !(p2[0] === p1[0] && p2[1] === p1[1])) {\n      clipped.push(p1);\n    }\n\n    return resample(clipped);\n  }\n\n  // Resample coordinates, creating great arcs between each.\n  function resample(coordinates) {\n    var i = 0,\n        n = coordinates.length,\n        j,\n        m,\n        resampled = n ? [coordinates[0]] : coordinates,\n        resamples,\n        origin = arc.source();\n\n    while (++i < n) {\n      resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;\n      for (j = 0, m = resamples.length; ++j < m;) resampled.push(resamples[j]);\n    }\n\n    arc.source(origin);\n    return resampled;\n  }\n\n  circle.origin = function(x) {\n    if (!arguments.length) return origin;\n    origin = x;\n    if (typeof origin !== \"function\") arc.source(origin);\n    return circle;\n  };\n\n  circle.angle = function(x) {\n    if (!arguments.length) return degrees;\n    radians = (degrees = +x) * d3_geo_radians;\n    return circle;\n  };\n\n  return d3.rebind(circle, arc, \"precision\");\n}\nd3.geo.greatArc = function() {\n  var source = d3_geo_greatArcSource, p0,\n      target = d3_geo_greatArcTarget, p1,\n      precision = 6 * d3_geo_radians,\n      interpolate = d3_geo_greatArcInterpolator();\n\n  function greatArc() {\n    var d = greatArc.distance.apply(this, arguments), // initializes the interpolator, too\n        t = 0,\n        dt = precision / d,\n        coordinates = [p0];\n    while ((t += dt) < 1) coordinates.push(interpolate(t));\n    coordinates.push(p1);\n    return {type: \"LineString\", coordinates: coordinates};\n  }\n\n  // Length returned in radians; multiply by radius for distance.\n  greatArc.distance = function() {\n    if (typeof source === \"function\") interpolate.source(p0 = source.apply(this, arguments));\n    if (typeof target === \"function\") interpolate.target(p1 = target.apply(this, arguments));\n    return interpolate.distance();\n  };\n\n  greatArc.source = function(_) {\n    if (!arguments.length) return source;\n    source = _;\n    if (typeof source !== \"function\") interpolate.source(p0 = source);\n    return greatArc;\n  };\n\n  greatArc.target = function(_) {\n    if (!arguments.length) return target;\n    target = _;\n    if (typeof target !== \"function\") interpolate.target(p1 = target);\n    return greatArc;\n  };\n\n  // Precision is specified in degrees.\n  greatArc.precision = function(_) {\n    if (!arguments.length) return precision / d3_geo_radians;\n    precision = _ * d3_geo_radians;\n    return greatArc;\n  };\n\n  return greatArc;\n};\n\nfunction d3_geo_greatArcSource(d) {\n  return d.source;\n}\n\nfunction d3_geo_greatArcTarget(d) {\n  return d.target;\n}\n\nfunction d3_geo_greatArcInterpolator() {\n  var x0, y0, cy0, sy0, kx0, ky0,\n      x1, y1, cy1, sy1, kx1, ky1,\n      d,\n      k;\n\n  function interpolate(t) {\n    var B = Math.sin(t *= d) * k,\n        A = Math.sin(d - t) * k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      Math.atan2(y, x) / d3_geo_radians,\n      Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians\n    ];\n  }\n\n  interpolate.distance = function() {\n    if (d == null) k = 1 / Math.sin(d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))));\n    return d;\n  };\n\n  interpolate.source = function(_) {\n    var cx0 = Math.cos(x0 = _[0] * d3_geo_radians),\n        sx0 = Math.sin(x0);\n    cy0 = Math.cos(y0 = _[1] * d3_geo_radians);\n    sy0 = Math.sin(y0);\n    kx0 = cy0 * cx0;\n    ky0 = cy0 * sx0;\n    d = null;\n    return interpolate;\n  };\n\n  interpolate.target = function(_) {\n    var cx1 = Math.cos(x1 = _[0] * d3_geo_radians),\n        sx1 = Math.sin(x1);\n    cy1 = Math.cos(y1 = _[1] * d3_geo_radians);\n    sy1 = Math.sin(y1);\n    kx1 = cy1 * cx1;\n    ky1 = cy1 * sx1;\n    d = null;\n    return interpolate;\n  };\n\n  return interpolate;\n}\n\nfunction d3_geo_greatArcInterpolate(a, b) {\n  var i = d3_geo_greatArcInterpolator().source(a).target(b);\n  i.distance();\n  return i;\n}\nd3.geo.greatCircle = d3.geo.circle;\nd3.geom = {};\n/**\n * Computes a contour for a given input grid function using the <a\n * href=\"http://en.wikipedia.org/wiki/Marching_squares\">marching\n * squares</a> algorithm. Returns the contour polygon as an array of points.\n *\n * @param grid a two-input function(x, y) that returns true for values\n * inside the contour and false for values outside the contour.\n * @param start an optional starting point [x, y] on the grid.\n * @returns polygon [[x1, y1], [x2, y2], …]\n */\nd3.geom.contour = function(grid, start) {\n  var s = start || d3_geom_contourStart(grid), // starting point\n      c = [],    // contour polygon\n      x = s[0],  // current x position\n      y = s[1],  // current y position\n      dx = 0,    // next x direction\n      dy = 0,    // next y direction\n      pdx = NaN, // previous x direction\n      pdy = NaN, // previous y direction\n      i = 0;\n\n  do {\n    // determine marching squares index\n    i = 0;\n    if (grid(x-1, y-1)) i += 1;\n    if (grid(x,   y-1)) i += 2;\n    if (grid(x-1, y  )) i += 4;\n    if (grid(x,   y  )) i += 8;\n\n    // determine next direction\n    if (i === 6) {\n      dx = pdy === -1 ? -1 : 1;\n      dy = 0;\n    } else if (i === 9) {\n      dx = 0;\n      dy = pdx === 1 ? -1 : 1;\n    } else {\n      dx = d3_geom_contourDx[i];\n      dy = d3_geom_contourDy[i];\n    }\n\n    // update contour polygon\n    if (dx != pdx && dy != pdy) {\n      c.push([x, y]);\n      pdx = dx;\n      pdy = dy;\n    }\n\n    x += dx;\n    y += dy;\n  } while (s[0] != x || s[1] != y);\n\n  return c;\n};\n\n// lookup tables for marching directions\nvar d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],\n    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];\n\nfunction d3_geom_contourStart(grid) {\n  var x = 0,\n      y = 0;\n\n  // search for a starting point; begin at origin\n  // and proceed along outward-expanding diagonals\n  while (true) {\n    if (grid(x,y)) {\n      return [x,y];\n    }\n    if (x === 0) {\n      x = y + 1;\n      y = 0;\n    } else {\n      x = x - 1;\n      y = y + 1;\n    }\n  }\n}\n/**\n * Computes the 2D convex hull of a set of points using Graham's scanning\n * algorithm. The algorithm has been implemented as described in Cormen,\n * Leiserson, and Rivest's Introduction to Algorithms. The running time of\n * this algorithm is O(n log n), where n is the number of input points.\n *\n * @param vertices [[x1, y1], [x2, y2], …]\n * @returns polygon [[x1, y1], [x2, y2], …]\n */\nd3.geom.hull = function(vertices) {\n  if (vertices.length < 3) return [];\n\n  var len = vertices.length,\n      plen = len - 1,\n      points = [],\n      stack = [],\n      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;\n\n  // find the starting ref point: leftmost point with the minimum y coord\n  for (i=1; i<len; ++i) {\n    if (vertices[i][1] < vertices[h][1]) {\n      h = i;\n    } else if (vertices[i][1] == vertices[h][1]) {\n      h = (vertices[i][0] < vertices[h][0] ? i : h);\n    }\n  }\n\n  // calculate polar angles from ref point and sort\n  for (i=0; i<len; ++i) {\n    if (i === h) continue;\n    y1 = vertices[i][1] - vertices[h][1];\n    x1 = vertices[i][0] - vertices[h][0];\n    points.push({angle: Math.atan2(y1, x1), index: i});\n  }\n  points.sort(function(a, b) { return a.angle - b.angle; });\n\n  // toss out duplicate angles\n  a = points[0].angle;\n  v = points[0].index;\n  u = 0;\n  for (i=1; i<plen; ++i) {\n    j = points[i].index;\n    if (a == points[i].angle) {\n      // keep angle for point most distant from the reference\n      x1 = vertices[v][0] - vertices[h][0];\n      y1 = vertices[v][1] - vertices[h][1];\n      x2 = vertices[j][0] - vertices[h][0];\n      y2 = vertices[j][1] - vertices[h][1];\n      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {\n        points[i].index = -1;\n      } else {\n        points[u].index = -1;\n        a = points[i].angle;\n        u = i;\n        v = j;\n      }\n    } else {\n      a = points[i].angle;\n      u = i;\n      v = j;\n    }\n  }\n\n  // initialize the stack\n  stack.push(h);\n  for (i=0, j=0; i<2; ++j) {\n    if (points[j].index !== -1) {\n      stack.push(points[j].index);\n      i++;\n    }\n  }\n  sp = stack.length;\n\n  // do graham's scan\n  for (; j<plen; ++j) {\n    if (points[j].index === -1) continue; // skip tossed out points\n    while (sp >= 2 && !d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {\n      --sp;\n    }\n    stack[sp++] = points[j].index;\n  }\n\n  // construct the hull\n  var poly = [];\n  for (i=0; i<sp; ++i) {\n    poly.push(vertices[stack[i]]);\n  }\n  return poly;\n}\n\n// are three points in counter-clockwise order?\nfunction d3_geom_hullCCW(i1, i2, i3, v) {\n  var t, a, b, c, d, e, f;\n  t = v[i1]; a = t[0]; b = t[1];\n  t = v[i2]; c = t[0]; d = t[1];\n  t = v[i3]; e = t[0]; f = t[1];\n  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;\n}\n// Note: requires coordinates to be counterclockwise and convex!\nd3.geom.polygon = function(coordinates) {\n\n  coordinates.area = function() {\n    var i = 0,\n        n = coordinates.length,\n        a = coordinates[n - 1][0] * coordinates[0][1],\n        b = coordinates[n - 1][1] * coordinates[0][0];\n    while (++i < n) {\n      a += coordinates[i - 1][0] * coordinates[i][1];\n      b += coordinates[i - 1][1] * coordinates[i][0];\n    }\n    return (b - a) * .5;\n  };\n\n  coordinates.centroid = function(k) {\n    var i = -1,\n        n = coordinates.length,\n        x = 0,\n        y = 0,\n        a,\n        b = coordinates[n - 1],\n        c;\n    if (!arguments.length) k = -1 / (6 * coordinates.area());\n    while (++i < n) {\n      a = b;\n      b = coordinates[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [x * k, y * k];\n  };\n\n  // The Sutherland-Hodgman clipping algorithm.\n  coordinates.clip = function(subject) {\n    var input,\n        i = -1,\n        n = coordinates.length,\n        j,\n        m,\n        a = coordinates[n - 1],\n        b,\n        c,\n        d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = coordinates[i];\n      c = input[(m = input.length) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      a = b;\n    }\n    return subject;\n  };\n\n  return coordinates;\n};\n\nfunction d3_geom_polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\nfunction d3_geom_polygonIntersect(c, d, a, b) {\n  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],\n      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],\n      x13 = x1 - x3,\n      x21 = x2 - x1,\n      x43 = x4 - x3,\n      y13 = y1 - y3,\n      y21 = y2 - y1,\n      y43 = y4 - y3,\n      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];\n}\n// Adapted from Nicolas Garcia Belmonte's JIT implementation:\n// http://blog.thejit.org/2010/02/12/voronoi-tessellation/\n// http://blog.thejit.org/assets/voronoijs/voronoi.js\n// See lib/jit/LICENSE for details.\n\n// Notes:\n//\n// This implementation does not clip the returned polygons, so if you want to\n// clip them to a particular shape you will need to do that either in SVG or by\n// post-processing with d3.geom.polygon's clip method.\n//\n// If any vertices are coincident or have NaN positions, the behavior of this\n// method is undefined. Most likely invalid polygons will be returned. You\n// should filter invalid points, and consolidate coincident points, before\n// computing the tessellation.\n\n/**\n * @param vertices [[x1, y1], [x2, y2], …]\n * @returns polygons [[[x1, y1], [x2, y2], …], …]\n */\nd3.geom.voronoi = function(vertices) {\n  var polygons = vertices.map(function() { return []; });\n\n  d3_voronoi_tessellate(vertices, function(e) {\n    var s1,\n        s2,\n        x1,\n        x2,\n        y1,\n        y2;\n    if (e.a === 1 && e.b >= 0) {\n      s1 = e.ep.r;\n      s2 = e.ep.l;\n    } else {\n      s1 = e.ep.l;\n      s2 = e.ep.r;\n    }\n    if (e.a === 1) {\n      y1 = s1 ? s1.y : -1e6;\n      x1 = e.c - e.b * y1;\n      y2 = s2 ? s2.y : 1e6;\n      x2 = e.c - e.b * y2;\n    } else {\n      x1 = s1 ? s1.x : -1e6;\n      y1 = e.c - e.a * x1;\n      x2 = s2 ? s2.x : 1e6;\n      y2 = e.c - e.a * x2;\n    }\n    var v1 = [x1, y1],\n        v2 = [x2, y2];\n    polygons[e.region.l.index].push(v1, v2);\n    polygons[e.region.r.index].push(v1, v2);\n  });\n\n  // Reconnect the polygon segments into counterclockwise loops.\n  return polygons.map(function(polygon, i) {\n    var cx = vertices[i][0],\n        cy = vertices[i][1];\n    polygon.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    return polygon.sort(function(a, b) {\n      return a.angle - b.angle;\n    }).filter(function(d, i) {\n      return !i || (d.angle - polygon[i - 1].angle > 1e-10);\n    });\n  });\n};\n\nvar d3_voronoi_opposite = {\"l\": \"r\", \"r\": \"l\"};\n\nfunction d3_voronoi_tessellate(vertices, callback) {\n\n  var Sites = {\n    list: vertices\n      .map(function(v, i) {\n        return {\n          index: i,\n          x: v[0],\n          y: v[1]\n        };\n      })\n      .sort(function(a, b) {\n        return a.y < b.y ? -1\n          : a.y > b.y ? 1\n          : a.x < b.x ? -1\n          : a.x > b.x ? 1\n          : 0;\n      }),\n    bottomSite: null\n  };\n\n  var EdgeList = {\n    list: [],\n    leftEnd: null,\n    rightEnd: null,\n\n    init: function() {\n      EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\n      EdgeList.leftEnd.r = EdgeList.rightEnd;\n      EdgeList.rightEnd.l = EdgeList.leftEnd;\n      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\n    },\n\n    createHalfEdge: function(edge, side) {\n      return {\n        edge: edge,\n        side: side,\n        vertex: null,\n        \"l\": null,\n        \"r\": null\n      };\n    },\n\n    insert: function(lb, he) {\n      he.l = lb;\n      he.r = lb.r;\n      lb.r.l = he;\n      lb.r = he;\n    },\n\n    leftBound: function(p) {\n      var he = EdgeList.leftEnd;\n      do {\n        he = he.r;\n      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\n      he = he.l;\n      return he;\n    },\n\n    del: function(he) {\n      he.l.r = he.r;\n      he.r.l = he.l;\n      he.edge = null;\n    },\n\n    right: function(he) {\n      return he.r;\n    },\n\n    left: function(he) {\n      return he.l;\n    },\n\n    leftRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[he.side];\n    },\n\n    rightRegion: function(he) {\n      return he.edge == null\n          ? Sites.bottomSite\n          : he.edge.region[d3_voronoi_opposite[he.side]];\n    }\n  };\n\n  var Geom = {\n\n    bisect: function(s1, s2) {\n      var newEdge = {\n        region: {\"l\": s1, \"r\": s2},\n        ep: {\"l\": null, \"r\": null}\n      };\n\n      var dx = s2.x - s1.x,\n          dy = s2.y - s1.y,\n          adx = dx > 0 ? dx : -dx,\n          ady = dy > 0 ? dy : -dy;\n\n      newEdge.c = s1.x * dx + s1.y * dy\n          + (dx * dx + dy * dy) * .5;\n\n      if (adx > ady) {\n        newEdge.a = 1;\n        newEdge.b = dy / dx;\n        newEdge.c /= dx;\n      } else {\n        newEdge.b = 1;\n        newEdge.a = dx / dy;\n        newEdge.c /= dy;\n      }\n\n      return newEdge;\n    },\n\n    intersect: function(el1, el2) {\n      var e1 = el1.edge,\n          e2 = el2.edge;\n      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {\n        return null;\n      }\n      var d = (e1.a * e2.b) - (e1.b * e2.a);\n      if (Math.abs(d) < 1e-10) {\n        return null;\n      }\n      var xint = (e1.c * e2.b - e2.c * e1.b) / d,\n          yint = (e2.c * e1.a - e1.c * e2.a) / d,\n          e1r = e1.region.r,\n          e2r = e2.region.r,\n          el,\n          e;\n      if ((e1r.y < e2r.y) ||\n         (e1r.y == e2r.y && e1r.x < e2r.x)) {\n        el = el1;\n        e = e1;\n      } else {\n        el = el2;\n        e = e2;\n      }\n      var rightOfSite = (xint >= e.region.r.x);\n      if ((rightOfSite && (el.side === \"l\")) ||\n        (!rightOfSite && (el.side === \"r\"))) {\n        return null;\n      }\n      return {\n        x: xint,\n        y: yint\n      };\n    },\n\n    rightOf: function(he, p) {\n      var e = he.edge,\n          topsite = e.region.r,\n          rightOfSite = (p.x > topsite.x);\n\n      if (rightOfSite && (he.side === \"l\")) {\n        return 1;\n      }\n      if (!rightOfSite && (he.side === \"r\")) {\n        return 0;\n      }\n      if (e.a === 1) {\n        var dyp = p.y - topsite.y,\n            dxp = p.x - topsite.x,\n            fast = 0,\n            above = 0;\n\n        if ((!rightOfSite && (e.b < 0)) ||\n          (rightOfSite && (e.b >= 0))) {\n          above = fast = (dyp >= e.b * dxp);\n        } else {\n          above = ((p.x + p.y * e.b) > e.c);\n          if (e.b < 0) {\n            above = !above;\n          }\n          if (!above) {\n            fast = 1;\n          }\n        }\n        if (!fast) {\n          var dxs = topsite.x - e.region.l.x;\n          above = (e.b * (dxp * dxp - dyp * dyp)) <\n            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));\n\n          if (e.b < 0) {\n            above = !above;\n          }\n        }\n      } else /* e.b == 1 */ {\n        var yl = e.c - e.a * p.x,\n            t1 = p.y - yl,\n            t2 = p.x - topsite.x,\n            t3 = yl - topsite.y;\n\n        above = (t1 * t1) > (t2 * t2 + t3 * t3);\n      }\n      return he.side === \"l\" ? above : !above;\n    },\n\n    endPoint: function(edge, side, site) {\n      edge.ep[side] = site;\n      if (!edge.ep[d3_voronoi_opposite[side]]) return;\n      callback(edge);\n    },\n\n    distance: function(s, t) {\n      var dx = s.x - t.x,\n          dy = s.y - t.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  };\n\n  var EventQueue = {\n    list: [],\n\n    insert: function(he, site, offset) {\n      he.vertex = site;\n      he.ystar = site.y + offset;\n      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {\n        var next = list[i];\n        if (he.ystar > next.ystar ||\n          (he.ystar == next.ystar &&\n          site.x > next.vertex.x)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      list.splice(i, 0, he);\n    },\n\n    del: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}\n      ls.splice(i, 1);\n    },\n\n    empty: function() { return EventQueue.list.length === 0; },\n\n    nextEvent: function(he) {\n      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {\n        if (ls[i] == he) return ls[i+1];\n      }\n      return null;\n    },\n\n    min: function() {\n      var elem = EventQueue.list[0];\n      return {\n        x: elem.vertex.x,\n        y: elem.ystar\n      };\n    },\n\n    extractMin: function() {\n      return EventQueue.list.shift();\n    }\n  };\n\n  EdgeList.init();\n  Sites.bottomSite = Sites.list.shift();\n\n  var newSite = Sites.list.shift(), newIntStar;\n  var lbnd, rbnd, llbnd, rrbnd, bisector;\n  var bot, top, temp, p, v;\n  var e, pm;\n\n  while (true) {\n    if (!EventQueue.empty()) {\n      newIntStar = EventQueue.min();\n    }\n    if (newSite && (EventQueue.empty()\n      || newSite.y < newIntStar.y\n      || (newSite.y == newIntStar.y\n      && newSite.x < newIntStar.x))) { //new site is smallest\n      lbnd = EdgeList.leftBound(newSite);\n      rbnd = EdgeList.right(lbnd);\n      bot = EdgeList.rightRegion(lbnd);\n      e = Geom.bisect(bot, newSite);\n      bisector = EdgeList.createHalfEdge(e, \"l\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(lbnd, bisector);\n      if (p) {\n        EventQueue.del(lbnd);\n        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\n      }\n      lbnd = bisector;\n      bisector = EdgeList.createHalfEdge(e, \"r\");\n      EdgeList.insert(lbnd, bisector);\n      p = Geom.intersect(bisector, rbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, newSite));\n      }\n      newSite = Sites.list.shift();\n    } else if (!EventQueue.empty()) { //intersection is smallest\n      lbnd = EventQueue.extractMin();\n      llbnd = EdgeList.left(lbnd);\n      rbnd = EdgeList.right(lbnd);\n      rrbnd = EdgeList.right(rbnd);\n      bot = EdgeList.leftRegion(lbnd);\n      top = EdgeList.rightRegion(rbnd);\n      v = lbnd.vertex;\n      Geom.endPoint(lbnd.edge, lbnd.side, v);\n      Geom.endPoint(rbnd.edge, rbnd.side, v);\n      EdgeList.del(lbnd);\n      EventQueue.del(rbnd);\n      EdgeList.del(rbnd);\n      pm = \"l\";\n      if (bot.y > top.y) {\n        temp = bot;\n        bot = top;\n        top = temp;\n        pm = \"r\";\n      }\n      e = Geom.bisect(bot, top);\n      bisector = EdgeList.createHalfEdge(e, pm);\n      EdgeList.insert(llbnd, bisector);\n      Geom.endPoint(e, d3_voronoi_opposite[pm], v);\n      p = Geom.intersect(llbnd, bisector);\n      if (p) {\n        EventQueue.del(llbnd);\n        EventQueue.insert(llbnd, p, Geom.distance(p, bot));\n      }\n      p = Geom.intersect(bisector, rrbnd);\n      if (p) {\n        EventQueue.insert(bisector, p, Geom.distance(p, bot));\n      }\n    } else {\n      break;\n    }\n  }//end while\n\n  for (lbnd = EdgeList.right(EdgeList.leftEnd);\n      lbnd != EdgeList.rightEnd;\n      lbnd = EdgeList.right(lbnd)) {\n    callback(lbnd.edge);\n  }\n}\n/**\n* @param vertices [[x1, y1], [x2, y2], …]\n* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], …]\n */\nd3.geom.delaunay = function(vertices) {\n  var edges = vertices.map(function() { return []; }),\n      triangles = [];\n\n  // Use the Voronoi tessellation to determine Delaunay edges.\n  d3_voronoi_tessellate(vertices, function(e) {\n    edges[e.region.l.index].push(vertices[e.region.r.index]);\n  });\n\n  // Reconnect the edges into counterclockwise triangles.\n  edges.forEach(function(edge, i) {\n    var v = vertices[i],\n        cx = v[0],\n        cy = v[1];\n    edge.forEach(function(v) {\n      v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n    });\n    edge.sort(function(a, b) {\n      return a.angle - b.angle;\n    });\n    for (var j = 0, m = edge.length - 1; j < m; j++) {\n      triangles.push([v, edge[j], edge[j + 1]]);\n    }\n  });\n\n  return triangles;\n};\n// Constructs a new quadtree for the specified array of points. A quadtree is a\n// two-dimensional recursive spatial subdivision. This implementation uses\n// square partitions, dividing each square into four equally-sized squares. Each\n// point exists in a unique node; if multiple points are in the same position,\n// some points may be stored on internal nodes rather than leaf nodes. Quadtrees\n// can be used to accelerate various spatial operations, such as the Barnes-Hut\n// approximation for computing n-body forces, or collision detection.\nd3.geom.quadtree = function(points, x1, y1, x2, y2) {\n  var p,\n      i = -1,\n      n = points.length;\n\n  // Type conversion for deprecated API.\n  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);\n\n  // Allow bounds to be specified explicitly.\n  if (arguments.length < 5) {\n    if (arguments.length === 3) {\n      y2 = x2 = y1;\n      y1 = x1;\n    } else {\n      x1 = y1 = Infinity;\n      x2 = y2 = -Infinity;\n\n      // Compute bounds.\n      while (++i < n) {\n        p = points[i];\n        if (p.x < x1) x1 = p.x;\n        if (p.y < y1) y1 = p.y;\n        if (p.x > x2) x2 = p.x;\n        if (p.y > y2) y2 = p.y;\n      }\n\n      // Squarify the bounds.\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      if (dx > dy) y2 = y1 + dx;\n      else x2 = x1 + dy;\n    }\n  }\n\n  // Recursively inserts the specified point p at the node n or one of its\n  // descendants. The bounds are defined by [x1, x2] and [y1, y2].\n  function insert(n, p, x1, y1, x2, y2) {\n    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points\n    if (n.leaf) {\n      var v = n.point;\n      if (v) {\n        // If the point at this leaf node is at the same position as the new\n        // point we are adding, we leave the point associated with the\n        // internal node while adding the new point to a child node. This\n        // avoids infinite recursion.\n        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {\n          insertChild(n, p, x1, y1, x2, y2);\n        } else {\n          n.point = null;\n          insertChild(n, v, x1, y1, x2, y2);\n          insertChild(n, p, x1, y1, x2, y2);\n        }\n      } else {\n        n.point = p;\n      }\n    } else {\n      insertChild(n, p, x1, y1, x2, y2);\n    }\n  }\n\n  // Recursively inserts the specified point p into a descendant of node n. The\n  // bounds are defined by [x1, x2] and [y1, y2].\n  function insertChild(n, p, x1, y1, x2, y2) {\n    // Compute the split point, and the quadrant in which to insert p.\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        right = p.x >= sx,\n        bottom = p.y >= sy,\n        i = (bottom << 1) + right;\n\n    // Recursively insert into the child node.\n    n.leaf = false;\n    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n\n    // Update the bounds as we recurse.\n    if (right) x1 = sx; else x2 = sx;\n    if (bottom) y1 = sy; else y2 = sy;\n    insert(n, p, x1, y1, x2, y2);\n  }\n\n  // Create the root node.\n  var root = d3_geom_quadtreeNode();\n\n  root.add = function(p) {\n    insert(root, p, x1, y1, x2, y2);\n  };\n\n  root.visit = function(f) {\n    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\n  };\n\n  // Insert all points.\n  points.forEach(root.add);\n  return root;\n};\n\nfunction d3_geom_quadtreeNode() {\n  return {\n    leaf: true,\n    nodes: [],\n    point: null\n  };\n}\n\nfunction d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n  if (!f(node, x1, y1, x2, y2)) {\n    var sx = (x1 + x2) * .5,\n        sy = (y1 + y2) * .5,\n        children = node.nodes;\n    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n  }\n}\n\nfunction d3_geom_quadtreePoint(p) {\n  return {\n    x: p[0],\n    y: p[1]\n  };\n}\nd3.time = {};\n\nvar d3_time = Date,\n    d3_time_daySymbols = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\nfunction d3_time_utc() {\n  this._ = new Date(arguments.length > 1\n      ? Date.UTC.apply(this, arguments)\n      : arguments[0]);\n}\n\nd3_time_utc.prototype = {\n  getDate: function() { return this._.getUTCDate(); },\n  getDay: function() { return this._.getUTCDay(); },\n  getFullYear: function() { return this._.getUTCFullYear(); },\n  getHours: function() { return this._.getUTCHours(); },\n  getMilliseconds: function() { return this._.getUTCMilliseconds(); },\n  getMinutes: function() { return this._.getUTCMinutes(); },\n  getMonth: function() { return this._.getUTCMonth(); },\n  getSeconds: function() { return this._.getUTCSeconds(); },\n  getTime: function() { return this._.getTime(); },\n  getTimezoneOffset: function() { return 0; },\n  valueOf: function() { return this._.valueOf(); },\n  setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); },\n  setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); },\n  setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); },\n  setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); },\n  setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); },\n  setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); },\n  setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); },\n  setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); },\n  setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); }\n};\n\nvar d3_time_prototype = Date.prototype;\n// The date and time format (%c), date format (%x) and time format (%X).\nvar d3_time_formatDateTime = \"%a %b %e %H:%M:%S %Y\",\n    d3_time_formatDate = \"%m/%d/%y\",\n    d3_time_formatTime = \"%H:%M:%S\";\n\n// The weekday and month names.\nvar d3_time_days = d3_time_daySymbols,\n    d3_time_dayAbbreviations = d3_time_days.map(d3_time_formatAbbreviate),\n    d3_time_months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    d3_time_monthAbbreviations = d3_time_months.map(d3_time_formatAbbreviate);\n\nfunction d3_time_formatAbbreviate(name) {\n  return name.substring(0, 3);\n}\nd3.time.format = function(template) {\n  var n = template.length;\n\n  function format(date) {\n    var string = [],\n        i = -1,\n        j = 0,\n        c,\n        f;\n    while (++i < n) {\n      if (template.charCodeAt(i) == 37) {\n        string.push(\n            template.substring(j, i),\n            (f = d3_time_formats[c = template.charAt(++i)])\n            ? f(date) : c);\n        j = i + 1;\n      }\n    }\n    string.push(template.substring(j, i));\n    return string.join(\"\");\n  }\n\n  format.parse = function(string) {\n    var d = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0},\n        i = d3_time_parse(d, template, string, 0);\n    if (i != string.length) return null;\n\n    // The am-pm flag is 0 for AM, and 1 for PM.\n    if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n    var date = new d3_time();\n    date.setFullYear(d.y, d.m, d.d);\n    date.setHours(d.H, d.M, d.S, d.L);\n    return date;\n  };\n\n  format.toString = function() {\n    return template;\n  };\n\n  return format;\n};\n\nfunction d3_time_parse(date, template, string, j) {\n  var c,\n      p,\n      i = 0,\n      n = template.length,\n      m = string.length;\n  while (i < n) {\n    if (j >= m) return -1;\n    c = template.charCodeAt(i++);\n    if (c == 37) {\n      p = d3_time_parsers[template.charAt(i++)];\n      if (!p || ((j = p(date, string, j)) < 0)) return -1;\n    } else if (c != string.charCodeAt(j++)) {\n      return -1;\n    }\n  }\n  return j;\n}\n\nfunction d3_time_formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction d3_time_formatLookup(names) {\n  var map = new d3_Map, i = -1, n = names.length;\n  while (++i < n) map.set(names[i].toLowerCase(), i);\n  return map;\n}\n\nvar d3_time_zfill2 = d3.format(\"02d\"),\n    d3_time_zfill3 = d3.format(\"03d\"),\n    d3_time_zfill4 = d3.format(\"04d\"),\n    d3_time_sfill2 = d3.format(\"2d\");\n\nfunction d3_time_ordinal_suffix(number) {\n  var suffix = \"th\",\n      tail = number % 100;\n\n  if (tail < 11 || tail > 13) {\n    switch (tail % 10) {\n      case 1: suffix = \"st\"; break;\n      case 2: suffix = \"nd\"; break;\n      case 3: suffix = \"rd\"; break;\n      default: break;\n    }\n  }\n\n  return suffix;\n}\n\nvar d3_time_dayRe = d3_time_formatRe(d3_time_days),\n    d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations),\n    d3_time_monthRe = d3_time_formatRe(d3_time_months),\n    d3_time_monthLookup = d3_time_formatLookup(d3_time_months),\n    d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations),\n    d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);\n\nvar d3_time_formats = {\n  a: function(d) { return d3_time_dayAbbreviations[d.getDay()]; },\n  A: function(d) { return d3_time_days[d.getDay()]; },\n  b: function(d) { return d3_time_monthAbbreviations[d.getMonth()]; },\n  B: function(d) { return d3_time_months[d.getMonth()]; },\n  c: d3.time.format(d3_time_formatDateTime),\n  d: function(d) { return d3_time_zfill2(d.getDate()); },\n  e: function(d) { return d3_time_sfill2(d.getDate()); },\n  H: function(d) { return d3_time_zfill2(d.getHours()); },\n  I: function(d) { return d3_time_zfill2(d.getHours() % 12 || 12); },\n  j: function(d) { return d3_time_zfill3(1 + d3.time.dayOfYear(d)); },\n  L: function(d) { return d3_time_zfill3(d.getMilliseconds()); },\n  m: function(d) { return d3_time_zfill2(d.getMonth() + 1); },\n  M: function(d) { return d3_time_zfill2(d.getMinutes()); },\n  p: function(d) { return d.getHours() >= 12 ? \"PM\" : \"AM\"; },\n  s: function(d) { return d3_time_ordinal_suffix(d.getDate()); },\n  S: function(d) { return d3_time_zfill2(d.getSeconds()); },\n  U: function(d) { return d3_time_zfill2(d3.time.sundayOfYear(d)); },\n  w: function(d) { return d.getDay(); },\n  W: function(d) { return d3_time_zfill2(d3.time.mondayOfYear(d)); },\n  x: d3.time.format(d3_time_formatDate),\n  X: d3.time.format(d3_time_formatTime),\n  y: function(d) { return d3_time_zfill2(d.getFullYear() % 100); },\n  Y: function(d) { return d3_time_zfill4(d.getFullYear() % 10000); },\n  Z: d3_time_zone,\n  \"%\": function(d) { return \"%\"; }\n};\n\nvar d3_time_parsers = {\n  a: d3_time_parseWeekdayAbbrev,\n  A: d3_time_parseWeekday,\n  b: d3_time_parseMonthAbbrev,\n  B: d3_time_parseMonth,\n  c: d3_time_parseLocaleFull,\n  d: d3_time_parseDay,\n  e: d3_time_parseDay,\n  H: d3_time_parseHour24,\n  I: d3_time_parseHour24,\n  // j: function(d, s, i) { /*TODO day of year [001,366] */ return i; },\n  L: d3_time_parseMilliseconds,\n  m: d3_time_parseMonthNumber,\n  M: d3_time_parseMinutes,\n  p: d3_time_parseAmPm,\n  S: d3_time_parseSeconds,\n  // U: function(d, s, i) { /*TODO week number (sunday) [00,53] */ return i; },\n  // w: function(d, s, i) { /*TODO weekday [0,6] */ return i; },\n  // W: function(d, s, i) { /*TODO week number (monday) [00,53] */ return i; },\n  x: d3_time_parseLocaleDate,\n  X: d3_time_parseLocaleTime,\n  y: d3_time_parseYear,\n  Y: d3_time_parseFullYear\n  // ,\n  // Z: function(d, s, i) { /*TODO time zone */ return i; },\n  // \"%\": function(d, s, i) { /*TODO literal % */ return i; }\n};\n\n// Note: weekday is validated, but does not set the date.\nfunction d3_time_parseWeekdayAbbrev(date, string, i) {\n  d3_time_dayAbbrevRe.lastIndex = 0;\n  var n = d3_time_dayAbbrevRe.exec(string.substring(i));\n  return n ? i += n[0].length : -1;\n}\n\n// Note: weekday is validated, but does not set the date.\nfunction d3_time_parseWeekday(date, string, i) {\n  d3_time_dayRe.lastIndex = 0;\n  var n = d3_time_dayRe.exec(string.substring(i));\n  return n ? i += n[0].length : -1;\n}\n\nfunction d3_time_parseMonthAbbrev(date, string, i) {\n  d3_time_monthAbbrevRe.lastIndex = 0;\n  var n = d3_time_monthAbbrevRe.exec(string.substring(i));\n  return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\n}\n\nfunction d3_time_parseMonth(date, string, i) {\n  d3_time_monthRe.lastIndex = 0;\n  var n = d3_time_monthRe.exec(string.substring(i));\n  return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\n}\n\nfunction d3_time_parseLocaleFull(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n}\n\nfunction d3_time_parseLocaleDate(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n}\n\nfunction d3_time_parseLocaleTime(date, string, i) {\n  return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n}\n\nfunction d3_time_parseFullYear(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 4));\n  return n ? (date.y = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseYear(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;\n}\n\nfunction d3_time_expandYear(d) {\n  // convert to 4-digit year according to POSIX/ISO rules (strptime) ~ http://docs.python.org/py3k/library/time.html\n  return d + (((d >= 69) && (d < 100)) ? 1900 : 2000);\n}\n\nfunction d3_time_parseMonthNumber(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.m = n[0] - 1, i += n[0].length) : -1;\n}\n\nfunction d3_time_parseDay(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.d = +n[0], i += n[0].length) : -1;\n}\n\n// Note: we don't validate that the hour is in the range [0,23] or [1,12].\nfunction d3_time_parseHour24(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.H = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseMinutes(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.M = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseSeconds(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n  return n ? (date.S = +n[0], i += n[0].length) : -1;\n}\n\nfunction d3_time_parseMilliseconds(date, string, i) {\n  d3_time_numberRe.lastIndex = 0;\n  var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n  return n ? (date.L = +n[0], i += n[0].length) : -1;\n}\n\n// Note: we don't look at the next directive.\nvar d3_time_numberRe = /^\\s*\\d+/;\n\nfunction d3_time_parseAmPm(date, string, i) {\n  var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());\n  return n == null ? -1 : (date.p = n, i);\n}\n\nvar d3_time_amPmLookup = d3.map({\n  am: 0,\n  pm: 1\n});\n\n// TODO table of time zone offset names?\nfunction d3_time_zone(d) {\n  var z = d.getTimezoneOffset(),\n      zs = z > 0 ? \"-\" : \"+\",\n      zh = ~~(Math.abs(z) / 60),\n      zm = Math.abs(z) % 60;\n  return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);\n}\nd3.time.format.utc = function(template) {\n  var local = d3.time.format(template);\n\n  function format(date) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time();\n      utc._ = date;\n      return local(utc);\n    } finally {\n      d3_time = Date;\n    }\n  }\n\n  format.parse = function(string) {\n    try {\n      d3_time = d3_time_utc;\n      var date = local.parse(string);\n      return date && date._;\n    } finally {\n      d3_time = Date;\n    }\n  };\n\n  format.toString = local.toString;\n\n  return format;\n};\nvar d3_time_formatIso = d3.time.format.utc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n\nd3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;\n\nfunction d3_time_formatIsoNative(date) {\n  return date.toISOString();\n}\n\nd3_time_formatIsoNative.parse = function(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n};\n\nd3_time_formatIsoNative.toString = d3_time_formatIso.toString;\nfunction d3_time_interval(local, step, number) {\n\n  function round(date) {\n    var d0 = local(date), d1 = offset(d0, 1);\n    return date - d0 < d1 - date ? d0 : d1;\n  }\n\n  function ceil(date) {\n    step(date = local(new d3_time(date - 1)), 1);\n    return date;\n  }\n\n  function offset(date, k) {\n    step(date = new d3_time(+date), k);\n    return date;\n  }\n\n  function range(t0, t1, dt) {\n    var time = ceil(t0), times = [];\n    if (dt > 1) {\n      while (time < t1) {\n        if (!(number(time) % dt)) times.push(new Date(+time));\n        step(time, 1);\n      }\n    } else {\n      while (time < t1) times.push(new Date(+time)), step(time, 1);\n    }\n    return times;\n  }\n\n  function range_utc(t0, t1, dt) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time_utc();\n      utc._ = t0;\n      return range(utc, t1, dt);\n    } finally {\n      d3_time = Date;\n    }\n  }\n\n  local.floor = local;\n  local.round = round;\n  local.ceil = ceil;\n  local.offset = offset;\n  local.range = range;\n\n  var utc = local.utc = d3_time_interval_utc(local);\n  utc.floor = utc;\n  utc.round = d3_time_interval_utc(round);\n  utc.ceil = d3_time_interval_utc(ceil);\n  utc.offset = d3_time_interval_utc(offset);\n  utc.range = range_utc;\n\n  return local;\n}\n\nfunction d3_time_interval_utc(method) {\n  return function(date, k) {\n    try {\n      d3_time = d3_time_utc;\n      var utc = new d3_time_utc();\n      utc._ = date;\n      return method(utc, k)._;\n    } finally {\n      d3_time = Date;\n    }\n  };\n}\nd3.time.second = d3_time_interval(function(date) {\n  return new d3_time(Math.floor(date / 1e3) * 1e3);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 1e3); // DST breaks setSeconds\n}, function(date) {\n  return date.getSeconds();\n});\n\nd3.time.seconds = d3.time.second.range;\nd3.time.seconds.utc = d3.time.second.utc.range;\nd3.time.minute = d3_time_interval(function(date) {\n  return new d3_time(Math.floor(date / 6e4) * 6e4);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 6e4); // DST breaks setMinutes\n}, function(date) {\n  return date.getMinutes();\n});\n\nd3.time.minutes = d3.time.minute.range;\nd3.time.minutes.utc = d3.time.minute.utc.range;\nd3.time.hour = d3_time_interval(function(date) {\n  var timezone = date.getTimezoneOffset() / 60;\n  return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n}, function(date, offset) {\n  date.setTime(date.getTime() + Math.floor(offset) * 36e5); // DST breaks setHours\n}, function(date) {\n  return date.getHours();\n});\n\nd3.time.hours = d3.time.hour.range;\nd3.time.hours.utc = d3.time.hour.utc.range;\nd3.time.day = d3_time_interval(function(date) {\n  var day = new d3_time(0, date.getMonth(), date.getDate());\n  day.setFullYear(date.getFullYear());\n  return day;\n}, function(date, offset) {\n  date.setDate(date.getDate() + offset);\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nd3.time.days = d3.time.day.range;\nd3.time.days.utc = d3.time.day.utc.range;\n\nd3.time.dayOfYear = function(date) {\n  var year = d3.time.year(date);\n  return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n};\nd3_time_daySymbols.forEach(function(day, i) {\n  day = day.toLowerCase();\n  i = 7 - i;\n\n  var interval = d3.time[day] = d3_time_interval(function(date) {\n    (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n    return date;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + Math.floor(offset) * 7);\n  }, function(date) {\n    var day = d3.time.year(date).getDay();\n    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n  });\n\n  d3.time[day + \"s\"] = interval.range;\n  d3.time[day + \"s\"].utc = interval.utc.range;\n\n  d3.time[day + \"OfYear\"] = function(date) {\n    var day = d3.time.year(date).getDay();\n    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);\n  };\n});\n\nd3.time.week = d3.time.sunday;\nd3.time.weeks = d3.time.sunday.range;\nd3.time.weeks.utc = d3.time.sunday.utc.range;\nd3.time.weekOfYear = d3.time.sundayOfYear;\nd3.time.month = d3_time_interval(function(date) {\n  date = d3.time.day(date);\n  date.setDate(1);\n  return date;\n}, function(date, offset) {\n  date.setMonth(date.getMonth() + offset);\n}, function(date) {\n  return date.getMonth();\n});\n\nd3.time.months = d3.time.month.range;\nd3.time.months.utc = d3.time.month.utc.range;\nd3.time.year = d3_time_interval(function(date) {\n  date = d3.time.day(date);\n  date.setMonth(0, 1);\n  return date;\n}, function(date, offset) {\n  date.setFullYear(date.getFullYear() + offset);\n}, function(date) {\n  return date.getFullYear();\n});\n\nd3.time.years = d3.time.year.range;\nd3.time.years.utc = d3.time.year.utc.range;\nfunction d3_time_scale(linear, methods, format) {\n\n  function scale(x) {\n    return linear(x);\n  }\n\n  scale.invert = function(x) {\n    return d3_time_scaleDate(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n    linear.domain(x);\n    return scale;\n  };\n\n  scale.nice = function(m) {\n    return scale.domain(d3_scale_nice(scale.domain(), function() { return m; }));\n  };\n\n  scale.ticks = function(m, k) {\n    var extent = d3_time_scaleExtent(scale.domain());\n    if (typeof m !== \"function\") {\n      var span = extent[1] - extent[0],\n          target = span / m,\n          i = d3.bisect(d3_time_scaleSteps, target);\n      if (i == d3_time_scaleSteps.length) return methods.year(extent, m);\n      if (!i) return linear.ticks(m).map(d3_time_scaleDate);\n      if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;\n      m = methods[i];\n      k = m[1];\n      m = m[0].range;\n    }\n    return m(extent[0], new Date(+extent[1] + 1), k); // inclusive upper bound\n  };\n\n  scale.tickFormat = function() {\n    return format;\n  };\n\n  scale.copy = function() {\n    return d3_time_scale(linear.copy(), methods, format);\n  };\n\n  // TOOD expose d3_scale_linear_rebind?\n  return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n}\n\n// TODO expose d3_scaleExtent?\nfunction d3_time_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction d3_time_scaleDate(t) {\n  return new Date(t);\n}\n\nfunction d3_time_scaleFormat(formats) {\n  return function(date) {\n    var i = formats.length - 1, f = formats[i];\n    while (!f[1](date)) f = formats[--i];\n    return f[0](date);\n  };\n}\n\nfunction d3_time_scaleSetYear(y) {\n  var d = new Date(y, 0, 1);\n  d.setFullYear(y); // Y2K fail\n  return d;\n}\n\nfunction d3_time_scaleGetYear(d) {\n  var y = d.getFullYear(),\n      d0 = d3_time_scaleSetYear(y),\n      d1 = d3_time_scaleSetYear(y + 1);\n  return y + (d - d0) / (d1 - d0);\n}\n\nvar d3_time_scaleSteps = [\n  1e3,    // 1-second\n  5e3,    // 5-second\n  15e3,   // 15-second\n  3e4,    // 30-second\n  6e4,    // 1-minute\n  3e5,    // 5-minute\n  9e5,    // 15-minute\n  18e5,   // 30-minute\n  36e5,   // 1-hour\n  108e5,  // 3-hour\n  216e5,  // 6-hour\n  432e5,  // 12-hour\n  864e5,  // 1-day\n  1728e5, // 2-day\n  6048e5, // 1-week\n  2592e6, // 1-month\n  7776e6, // 3-month\n  31536e6 // 1-year\n];\n\nvar d3_time_scaleLocalMethods = [\n  [d3.time.second, 1],\n  [d3.time.second, 5],\n  [d3.time.second, 15],\n  [d3.time.second, 30],\n  [d3.time.minute, 1],\n  [d3.time.minute, 5],\n  [d3.time.minute, 15],\n  [d3.time.minute, 30],\n  [d3.time.hour, 1],\n  [d3.time.hour, 3],\n  [d3.time.hour, 6],\n  [d3.time.hour, 12],\n  [d3.time.day, 1],\n  [d3.time.day, 2],\n  [d3.time.week, 1],\n  [d3.time.month, 1],\n  [d3.time.month, 3],\n  [d3.time.year, 1]\n];\n\nvar d3_time_scaleLocalFormats = [\n  [d3.time.format(\"%Y\"), function(d) { return true; }],\n  [d3.time.format(\"%B\"), function(d) { return d.getMonth(); }],\n  [d3.time.format(\"%b %d\"), function(d) { return d.getDate() != 1; }],\n  [d3.time.format(\"%a %d\"), function(d) { return d.getDay() && d.getDate() != 1; }],\n  [d3.time.format(\"%H\"), function(d) { return d.getHours(); }],   // [abh] Make the \"auto-scaling\" time formats use 24-hour hours instead of 12-hours and AM/PM\n  [d3.time.format(\"%I:%M\"), function(d) { return d.getMinutes(); }],\n  [d3.time.format(\":%S\"), function(d) { return d.getSeconds(); }],\n  [d3.time.format(\".%L\"), function(d) { return d.getMilliseconds(); }]\n];\n\nvar d3_time_scaleLinear = d3.scale.linear(),\n    d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);\n\nd3_time_scaleLocalMethods.year = function(extent, m) {\n  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);\n};\n\nd3.time.scale = function() {\n  return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n};\nvar d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {\n  return [m[0].utc, m[1]];\n});\n\nvar d3_time_scaleUTCFormats = [\n  [d3.time.format.utc(\"%Y\"), function(d) { return true; }],\n  [d3.time.format.utc(\"%B\"), function(d) { return d.getUTCMonth(); }],\n  [d3.time.format.utc(\"%b %d\"), function(d) { return d.getUTCDate() != 1; }],\n  [d3.time.format.utc(\"%a %d\"), function(d) { return d.getUTCDay() && d.getUTCDate() != 1; }],\n  [d3.time.format.utc(\"%H\"), function(d) { return d.getUTCHours(); }],  // [abh] Make the \"auto-scaling\" time formats use 24-hour hours instead of 12-hours and AM/PM\n  [d3.time.format.utc(\"%I:%M\"), function(d) { return d.getUTCMinutes(); }],\n  [d3.time.format.utc(\":%S\"), function(d) { return d.getUTCSeconds(); }],\n  [d3.time.format.utc(\".%L\"), function(d) { return d.getUTCMilliseconds(); }]\n];\n\nvar d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);\n\nfunction d3_time_scaleUTCSetYear(y) {\n  var d = new Date(Date.UTC(y, 0, 1));\n  d.setUTCFullYear(y); // Y2K fail\n  return d;\n}\n\nfunction d3_time_scaleUTCGetYear(d) {\n  var y = d.getUTCFullYear(),\n      d0 = d3_time_scaleUTCSetYear(y),\n      d1 = d3_time_scaleUTCSetYear(y + 1);\n  return y + (d - d0) / (d1 - d0);\n}\n\nd3_time_scaleUTCMethods.year = function(extent, m) {\n  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);\n};\n\nd3.time.scale.utc = function() {\n  return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);\n};\n})();\n",
      "language": "JavaScript"
    },
    "index.html": {
      "type": "text/html",
      "filename": "index.html",
      "raw_url": "https://gist.github.com/raw/3637711/eaa325abaf8448fb2c367174d304d838ddcce7ca/index.html",
      "size": 37271,
      "content": "<!DOCTYPE html>\n<html>\n  <head>\n    <title>Clustered Network</title>\n    <script src=\"./d3.v2.js\"></script>\n    <link href='http://fonts.googleapis.com/css?family=Gudea:700,400italic,400' rel='stylesheet' type='text/css'>\n    <style type=\"text/css\">\nsvg {\n  border: 1px solid #ccc;\n}\nbody {\n  font: 10px 'Gudea', sans-serif;\n}\ntext {\n  font-family: 'Gudea', sans-serif;\n  font-size: 9pt;\n}\ncircle.node {\n  fill: lightsteelblue;\n  stroke: #555;\n  stroke-width: 3px;\n}\ncircle.leaf {\n  stroke: #fff;\n  stroke-width: 1.5px;\n}\ncircle.link-expanded {\n  stroke: #555;\n  stroke-width: 3px;\n  stroke-dasharray: 2px 4px;\n}\ncircle.helper {\n  stroke-width: 0;\n  fill: #333;\n  opacity: 0.6;\n}\ncircle.center-of-mass {\n  fill: white;\n  stroke: red;\n  stroke-width: 5px;\n}\npath.hull {\n  fill: lightsteelblue;\n  fill-opacity: 0.3;\n}\npath.hlink {\n  stroke: #333;\n  stroke-opacity: 0.5;\n  fill: none;\n  pointer-events: none;\n}\npath.trace-alpha {\n  stroke: #0ee;\n  stroke-opacity: 0.8;\n  stroke-width: 1.5px;\n  fill: none;\n  pointer-events: none;\n}\npath.trace-c2 {\n  stroke: #3bb;\n  stroke-opacity: 0.8;\n  stroke-width: 1.5px;\n  fill: none;\n  pointer-events: none;\n}\nline.link {\n  stroke: red;\n  stroke-opacity: 0.7;\n  pointer-events: none;\n}\n    </style>\n  </head>\n  <body>\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"controls\" visibility=\"hidden\">\n  <g visibility=\"visible\">\n    <rect x=\"0\" y=\"0.55\" opacity=\"0.6\" fill=\"#FFFFFF\" stroke=\"#231F20\" stroke-miterlimit=\"10\" width=\"192\" height=\"22\"/>\n    <text transform=\"matrix(1 0 0 1 4.5066 15.343)\"  >Debug level:</text>\n    <g id=\"slider-debug-level\">\n      <line id=\"slider-x-debug-level\" fill=\"none\" stroke=\"#939598\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" x1=\"73.5\" y1=\"11.05\" x2=\"160.5\" y2=\"11.05\"/>\n      <rect id=\"sliderpos-debug-level\" x=\"77\" y=\"3.55\" fill=\"#58595B\" stroke=\"#231F20\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" width=\"4\" height=\"15\"/>\n            <text id=\"sliderval-debug-level\" transform=\"matrix(1 0 0 1 164.6638 15.343)\"  >?????</text>\n    </g>\n  </g>\n</svg>\n\n<script type=\"text/javascript\" src=\"http://gerhobbelt.github.com/bl.ocks.org-hack/fixit.js\" ></script>\n\n    <script type=\"text/javascript\">\nvar width = 960,        // svg width\n    height = 500,       // svg height\n    dr = 4,             // default point radius\n    off = 15,           // cluster hull offset\n\t\tcycle_curvep = 0.5, // cyclic ~ self-referential links: determines the 'radius' of the bezier path constructed for the link\n    expand = {},        // expanded clusters\n    data, net, force1, force2, hullg, hull, linkg, helper_linkg, link, hlink, nodeg, helper_nodeg, node, hnode,\n    debug = 3,          // 0: disable, 1: all, 2: only force2 + curves, 3: curves only\n    alpha_trace = [], alpha_line, alpha_scale, debug_g,\n    c2_trace = [], c2_line, c2_scale, debug_g;\n\n\t\t//for (var gn = 0; gn < 20; gn++) expand[gn] = 2;\n\t\t\nalpha_line = d3.svg.line()\n  .x(function(d, i) {\n    return i + 10;\n  })\n  .y(function(d, i) {\n    return d;\n  });\n\nalpha_scale = d3.scale.pow().exponent(-1.0).domain([5,.005]).range([10, height - 10]).clamp(true);\n\nc2_scale = d3.scale.log().domain([0.01, width * height]).range([10, height - 10]).clamp(true);\n\nc2_line = d3.svg.line()\n  .x(function(d, i) {\n    return i + 10;\n  })\n  .y(function(d, i) {\n    return d;\n  });\n\nvar curve = d3.svg.line()\n  .interpolate(\"cardinal-closed\")\n  .tension(.85);\n\nvar fill = d3.scale.category20();\n\nfunction noop() { return false; }\n\nfunction nodeid(n) {\n  return n.size > 0 ? \"_g_\" + n.group + \"_\" + n.expansion : n.name;\n}\n\nfunction linkid(l) {\n  var u = nodeid(l.source),\n      v = nodeid(l.target);\n  return u<v ? u+\"|\"+v : v+\"|\"+u;\n}\n\nfunction getGroup(n) { return n.group; }\n\nfunction cycleState(d) {\n  var g = d.group, s = expand[g] || 0;\n  // it's no use 'expanding the intergroup links only' for nodes which only have 1 outside link for real:\n  if (d.ig_link_count < 2)\n    s = (s ? 0 : 2);\n  else {\n    s++; s %= 3;\n  }\n  return expand[g] = s;\n}\n\n// constructs the network to visualize\nfunction network(data, prev) {\n  expand = expand || {};\n  var gm = {},    // group map\n      nm = {},    // node map\n      nml = {},   // node map for left-side 'link path helper nodes'\n      nmr = {},   // node map for right-side 'link path helper nodes'\n      nmc = {},   // node map for cyclic ~ self-referencing 'link path helper nodes'\n      nmimg = {}, // node map for cloned nodes for force2\n      lm = {},    // link maps - lm ~ lml-lmm-lmr\n      lml = {},\n      lmm = {},\n      lmr = {},\n      lmc = {},\n      gn = {},                  // previous group nodes\n      gc = {},                  // previous group centroids\n      nodes = [],               // output nodes\n      links = [],               // output links\n      helper_nodes = [],        // helper force graph nodes\n      helper_links = [];        // helper force graph links\n      helper_render_links = []; // helper force graph links\n  var k;\n\n  // process previous nodes for reuse or centroid calculation\n  if (prev) {\n    prev.nodes.forEach(function(n) {\n      var i = getGroup(n), o;\n      if (n.size > 0) {\n        gn[i] = n;\n        n.size = 0;\n        n.ig_link_count = 0;\n        n.link_count = 0;\n        n.first_link = null;\n        n.first_link_target = null;\n      } else {\n        o = gc[i] || (gc[i] = {x:0,y:0,count:0});\n        o.x += n.x;\n        o.y += n.y;\n        o.count += 1; // we count regular nodes here, so .count is a measure for the number of nodes in the group\n      }\n    });\n  }\n\n  // determine nodes\n  for (k=0; k < data.nodes.length; ++k) {\n    var n = data.nodes[k],\n        i = getGroup(n),\n        expansion = expand[i] || 0,\n        l = gm[i] || (gm[i]=gn[i]) || (gm[i]={group:i, size:0, nodes:[], ig_link_count:0, link_count:0, expansion: expansion, fixed: n.fixed || 0}),\n        img;\n\n    // we need to create a NEW object when expansion changes from 0->1 for a group node\n    // in order to break the references from the d3 selections, so that the next time\n    // this group node will indeed land in the 'enter()' set\n    if (l.expansion != expansion) {\n      l = gn[i] = gm[i] = {group:l.group, x:l.x, y: l.y, size:l.size, nodes:l.nodes, ig_link_count:l.ig_link_count, link_count:l.link_count, expansion: expansion, fixed: l.fixed};\n    }\n\n    if (expansion == 2) {\n      // the node should be directly visible\n      nm[nodeid(n)] = n;\n\t\t\tif (!n.fixed) n.fixed = 0; // make sure .fixed member is set/numeric\n      img = {ref: n, x: n.x, y: n.y, size: n.size || 0, fixed: n.fixed | 1, id: nodeid(n)};\n      nmimg[nodeid(n)] = img;\n      nodes.push(n);\n      helper_nodes.push(img);\n      if (gn[i]) {\n        // place new nodes at cluster location (plus jitter)\n        n.x = gn[i].x + Math.random();\n        n.y = gn[i].y + Math.random();\n      }\n    } else {\n      // the node is part of a collapsed cluster\n      if (l.size == 0) {\n        // if new cluster, add to set and position at centroid of leaf nodes\n        nm[nodeid(n)] = l;\n        l.size = 1;                     // hack to make nodeid() work correctly for the new group node\n        nm[nodeid(l)] = l;\n        img = {ref: l, x: l.x, y: l.y, size: l.size || 0, fixed: l.fixed | 1, id: nodeid(l)};\n        nmimg[nodeid(l)] = img;\n        l.size = 0;                     // undo hack\n        nmimg[nodeid(n)] = img;\n        nodes.push(l);\n        helper_nodes.push(img);\n        if (gc[i]) {\n          l.x = gc[i].x / gc[i].count;\n          l.y = gc[i].y / gc[i].count;\n        }\n      } else {\n        // have element node point to group node:\n        nm[nodeid(n)] = l; // l = shortcut for: nm[nodeid(l)];\n        nmimg[nodeid(n)] = nmimg[nodeid(l)];\n      }\n      l.nodes.push(n);\n    }\n    // always count group size as we also use it to tweak the force graph strengths/distances\n    l.size += 1;\n    n.group_data = l;\n    n.link_count = 0;\n    n.first_link = null;\n    n.first_link_target = null;\n  }\n\n  // determine links\n  for (k=0; k<data.links.length; ++k) {\n    var e = data.links[k],\n        u = getGroup(e.source),\n        v = getGroup(e.target),\n        rui, rvi, ui, vi, lu, rv, ustate, vstate, uimg, vimg,\n        i, ix,\n        l, ll, l_, lr;\n    if (u != v) {\n      gm[u].ig_link_count++;\n      gm[v].ig_link_count++;\n    }\n    ustate = expand[u] || 0;\n    vstate = expand[v] || 0;\n    // while d3.layout.force does convert link.source and link.target NUMERIC values to direct node references,\n    // it doesn't for other attributes, such as .real_source, so we do not use indexes in nm[] but direct node\n    // references to skip the d3.layout.force implicit links conversion later on and ensure that both .source/.target\n    // and .real_source/.real_target are of the same type and pointing at valid nodes.\n    rui = nodeid(e.source);\n    rvi = nodeid(e.target);\n    u = nm[rui];\n    v = nm[rvi];\n    if (u == v) {\n      // skip non-original links from node to same (A-A); they are rendered as 0-length lines anyhow. Less links in array = faster animation.\n\t\t\tif (ustate < 2)\n\t\t\t  continue;\n\t\t\t\n\t\t\t// self-referential 'links' are produced as 2 links+1 helper node; this is a generalized approach so we\n\t\t\t// can support multiple self-referential links as thanks to the force layout\n\t\t\t// those helpers will all be in different places, hence the link 'path' for each\n\t\t\t// parallel link will be different.\n\t\t\tui = nodeid(u);\n\t\t\ti = ui+\"|\"+ui+\"|\"+k;\n\t\t\tl = lm[i] || (lm[i] = {source:u, target:u, size:0, distance: 0});\n\t\t\tl.cyclic = true;\n\t\t\tix = i;\n\t\t\t// link(u,v) ==> u -> lu -> u\n\t\t\tlu = nmc[ix] || (nmc[ix] = data.helpers.cyclic[ix] || (data.helpers.cyclic[ix] = {ref: u, id: \"_ch_\" + ix, size: -1, link_ref: l, cyclic_helper: true}));\n\t\t\tuimg = nmimg[ui];\n\t\t\tl_ = lmc[ix] || (lmc[ix] = {g_ref: l, ref: e, id: \"c\"+ix, source:uimg, target: lu, real_source:u, size: 0, distance: 0, cyclic: true});\n\t\t\tl.size += 1;\n\t\t\tl_.size += 1;\n      continue;\n    }\n    // 'links' are produced as 3 links+2 helper nodes; this is a generalized approach so we\n    // can support multiple links between element nodes and/or groups, always, as each\n    // 'original link' gets its own set of 2 helper nodes and thanks to the force layout\n    // those helpers will all be in different places, hence the link 'path' for each\n    // parallel link will be different.\n    ui = nodeid(u);\n    vi = nodeid(v);\n    i = (ui < vi ? ui+\"|\"+vi : vi+\"|\"+ui);\n    l = lm[i] || (lm[i] = {source:u, target:v, size:0, distance: 0});\n    if (ustate == 1) {\n      ui = rui;\n    }\n    if (vstate == 1) {\n      vi = rvi;\n    }\n    ix = (ui < vi ? ui+\"|\"+vi+\"|\"+ustate+\"|\"+vstate : vi+\"|\"+ui+\"|\"+vstate+\"|\"+ustate);\n    ix = (ui < vi ? ui+\"|\"+vi : vi+\"|\"+ui);\n    // link(u,v) ==> u -> lu -> rv -> v\n    lu = nml[ix] || (nml[ix] = data.helpers.left[ix]  || (data.helpers.left[ix]  = {ref: u, id: \"_lh_\" + ix, size: -1, link_ref: l}));\n    rv = nmr[ix] || (nmr[ix] = data.helpers.right[ix] || (data.helpers.right[ix] = {ref: v, id: \"_rh_\" + ix, size: -1, link_ref: l}));\n    uimg = nmimg[ui];\n    vimg = nmimg[vi];\n    ll = lml[ix] || (lml[ix] = {g_ref: l, ref: e, id: \"l\"+ix, source:uimg, target:  lu, real_source:u, real_target:v, size:0, distance: 0, left_seg  : true});\n    l_ = lmm[ix] || (lmm[ix] = {g_ref: l, ref: e, id: \"m\"+ix, source:  lu, target:  rv, real_source:u, real_target:v, size:0, distance: 0, middle_seg: true});\n    lr = lmr[ix] || (lmr[ix] = {g_ref: l, ref: e, id: \"r\"+ix, source:  rv, target:vimg, real_source:u, real_target:v, size:0, distance: 0, right_seg : true});\n    l.size += 1;\n    ll.size += 1;\n    l_.size += 1;\n    lr.size += 1;\n\n    // these are only useful for single-linked nodes, but we don't care; here we have everything we need at minimum cost.\n    if (l.size == 1) {\n      u.link_count++;\n      v.link_count++;\n      u.first_link = l;\n      v.first_link = l;\n      u.first_link_target = v;\n      v.first_link_target = u;\n    }\n  }\n\n  for (k in lm) { links.push(lm[k]); }\n  for (k in lml) { helper_links.push(lml[k]); }\n  for (k in lmm) { helper_links.push(lmm[k]); helper_render_links.push(lmm[k]); }\n  for (k in lmr) { helper_links.push(lmr[k]); }\n  for (k in lmc) { helper_links.push(lmc[k]); helper_render_links.push(lmc[k]); }\n  for (k in nml) { helper_nodes.push(nml[k]); }\n  for (k in nmr) { helper_nodes.push(nmr[k]); }\n  for (k in nmc) { helper_nodes.push(nmc[k]); }\n  //for (k in nmc) { nodes.push(nmc[k]); }\n\n  return {nodes: nodes, links: links, helper_nodes: helper_nodes, helper_links: helper_links, helper_render_links: helper_render_links};\n}\n\nfunction convexHulls(nodes, offset) {\n  var hulls = {};\n\n  // create point sets\n  for (var k=0; k<nodes.length; ++k) {\n    var n = nodes[k];\n    if (n.size) continue;\n    var i = getGroup(n),\n        l = hulls[i] || (hulls[i] = []);\n    l.push([n.x - offset, n.y - offset]);\n    l.push([n.x - offset, n.y + offset]);\n    l.push([n.x + offset, n.y - offset]);\n    l.push([n.x + offset, n.y + offset]);\n  }\n\n  // create convex hulls\n  var hullset = [];\n  for (i in hulls) {\n    hullset.push({group: i, path: d3.geom.hull(hulls[i])});\n  }\n\n  return hullset;\n}\n\nfunction drawCluster(d) {\n  return curve(d.path); // 0.8\n}\n\n// these functions call init(); by declaring them here,\n// they don't have the old init() as a closure any more.\n// This should save us some memory and cycles when using\n// this in a long-running setting.\n\nfunction on_hull_click(d) {\n  if (debug == 1) console.log(\"node click\", d, arguments, this, expand[d.group]);\n  // clicking on 'path helper nodes' shouln't expand/collapse the group node:\n  if (d.size < 0)\n    return;\n  cycleState(d);\n  init();\n}\n\nfunction on_node_click(d) {\n  if (debug == 1) console.log(\"node click\", d, arguments, this, expand[d.group]);\n  // clicking on 'path helper nodes' shouln't expand/collapse the group node:\n  if (d.size < 0)\n    return;\n  cycleState(d);\n  init();\n}\n\n// --------------------------------------------------------\n\nvar vis = d3.select(\"svg\")\n  .attr(\"width\", width)\n  .attr(\"height\", height);\n\nvar debug_ui = vis.select(\"#slider-debug-level\");\ndebug_ui.select(\"#sliderval-debug-level\").text(debug);\nvar dbg = debug_ui.select(\"#slider-x-debug-level\");\nx1 = +dbg.attr(\"x1\");\nx2 = +dbg.attr(\"x2\");\nvar debug_ui_scale = d3.scale.linear().domain([0,3]).range([+dbg.attr(\"x1\")+3.5, +dbg.attr(\"x2\")-3.5-4]).clamp(true);\n\n// as per http://bl.ocks.org/1557377; correction for latest d3 lib: origin(Object) doesn't cut it.\nvar slider_drag = d3.behavior.drag()\n/*\n        .origin(function(d, i) {\n            // must return {x: value, y: value} object\n            var owner = this.ownerSVGElement;\n            var rect = owner.getBoundingClientRect();\n            // (window.scrollX || window.scrollY) ?\n            //return {x: rect.left - this.clientLeft, y: rect.top - this.clientTop};\n            return {x: rect.left, y: rect.top};\n        })\n*/\n  .on(\"drag\", slider_dragmove);\n\ndebug_ui.select(\"#sliderpos-debug-level\")\n  .attr(\"x\", debug_ui_scale(debug))\n  .call(slider_drag);\n\nfunction slider_dragmove(d) {\n  if (!isFinite(d3.event.x))\n    return;\n  var dv = debug_ui_scale.invert(d3.event.x);\n  dv = Math.round(dv);\n  d3.select(this)\n    .attr(\"x\", debug_ui_scale(dv));\n  debug_ui.select(\"#sliderval-debug-level\").text(dv);\n  if (dv != debug) {\n    debug = dv;\n\n    helper_nodeg\n      .selectAll(\"*\")\n        .remove();\n    linkg\n      .selectAll(\"*\")\n        .remove();\n    vis.select(\"#center-of-mass\")\n      .attr(\"display\", (debug == 1) ? null : \"none\");\n    debug_g\n      .attr(\"display\", debug ? null : \"none\");\n\n    init();\n  }\n}\n\ndebug_g = vis.append(\"g\");\ndebug_g\n  .append(\"path\")\n  .attr(\"class\", \"trace-alpha\");\ndebug_g\n  .append(\"path\")\n  .attr(\"class\", \"trace-c2\");\n\nvar pathgen = d3.svg.line().interpolate(\"basis\");\nvar cycle_pathgen = d3.svg.line().interpolate(\"basis\");\n\nd3.json(\"miserables-with-cycles.json\", function(json) {\n  /*\n  JSON layout:\n\n  {\n    \"nodes\": [\n      {\n        \"name\"  : \"bla\",    // in this code, this is expected to be a globally unique string (as it's used for the id via nodeid())\n        \"group\" : 1         // group ID (number)\n      },\n      ...\n    ],\n    \"links\": [\n      {\n        \"source\" : 1,       // nodes[] index (number; is immediately converted to direct nodes[index] reference)\n        \"target\" : 0,       // nodes[] index (number; is immediately converted to direct nodes[index] reference)\n        \"value\"  : 1        // [not used in this force layout]\n      },\n      ...\n    ]\n  }\n  */\n  data = json;\n  for (var i=0; i<data.links.length; ++i) {\n    o = data.links[i];\n    o.source = data.nodes[o.source];\n    o.target = data.nodes[o.target];\n  }\n  // prepare data struct to also carry our 'path helper nodes':\n  data.helpers = {left: {}, right: {}, cyclic: {}};\n\n  hullg = vis.append(\"g\");\n  //if (debug && debug < 3) {\n    linkg = vis.append(\"g\");\n    helper_nodeg = vis.append(\"g\");\n  //}\n  helper_linkg = vis.append(\"g\");\n  nodeg = vis.append(\"g\");\n  //if (debug == 1) {\n    node = vis.append(\"g\")\n        .attr(\"id\", \"center-of-mass\")\n      .append(\"circle\")\n        .attr(\"class\", \"center-of-mass\")\n        .attr(\"visibility\", (debug == 1) ? \"visible\" : \"hidden\")\n        .attr(\"r\", 10);\n  //}\n\n  init();\n\n  vis.attr(\"opacity\", 1e-6)\n    .transition()\n    .duration(1000)\n    .attr(\"opacity\", 1);\n});\n\nfunction init() {\n  if (force1) force1.stop();\n\n  net = network(data, net);\n\n  force1 = d3.layout.force()\n      .nodes(net.nodes)\n      .links(net.links)\n      .size([width, height])\n      .linkDistance(function(l, i) {\n        //return 300;\n        var n1 = l.source, n2 = l.target,\n            g1 = n1.group_data || n1, g2 = n2.group_data || n2,\n            n1_is_group = n1.size || 0, n2_is_group = n2.size || 0,\n            rv = 300;\n        // larger distance for bigger groups:\n        // both between single nodes and _other_ groups (where size of own node group still counts),\n        // and between two group nodes.\n        //\n        // reduce distance for groups with very few outer links,\n        // again both in expanded and grouped form, i.e. between individual nodes of a group and\n        // nodes of another group or other group node or between two group nodes.\n        //\n        // The latter was done to keep the single-link groups close.\n        if (n1.group == n2.group) {\n          if ((n1.link_count < 2 && !n1_is_group) || (n2.link_count < 2 && !n2_is_group)) {\n            // 'real node' singles: these don't need a big distance to make the distance, if you whumsayin' ;-)\n            rv = 2;\n          } else if (!n1_is_group && !n2_is_group) {\n            rv = 2;\n          } else if (g1.link_count < 4 || g2.link_count < 4) {\n            rv = 100;\n          }\n        } else {\n          if (!n1_is_group && !n2_is_group) {\n            rv = 50;\n          } else if ((n1_is_group && n2_is_group) && (g1.link_count < 4 || g2.link_count < 4)) {\n            // 'real node' singles: these don't need a big distance to make the ditance, if you whumsayin' ;-)\n            rv = 100;\n          } else if ((n1_is_group && g1.link_count < 2) || (n2_is_group && g2.link_count < 2)) {\n            // 'real node' singles: these don't need a big distance to make the ditance, if you whumsayin' ;-)\n            rv = 30;\n          } else if (!n1_is_group || !n2_is_group) {\n            rv = 100;\n          }\n        }\n        return l.distance = rv;\n      })\n      .gravity(1.0)             // gravity+charge tweaked to ensure good 'grouped' view (e.g. green group not smack between blue&orange, ...\n      .charge(function(d, i) {  // ... charge is important to turn single-linked groups to the outside\n        if (d.size > 0) {\n          return -5000;  // group node\n        } else {\n          // 'regular node'\n          return -1000;\n        }\n      })\n      .friction(0.7)   // friction adjusted to get dampened display: less bouncy bouncy ball [Swedish Chef, anyone?]\n      .on(\"end\", function() {\n        // done\n      })\n      .on(\"start\", function() {\n        // zip nada\n      })\n      .start();\n\n  /*\n  And here's the crazy idea for allowing AND rendering multiple links between 2 nodes, etc., as the initial attempt\n  to include the 'helper' nodes in the basic 'force' failed dramatically from a visual PoV: we 'overlay' the basic\n  nodes+links force with a SECOND force layout which 'augments' the original force layout by having it 'layout' all\n  the helper nodes (with their links) between the 'fixed' REAL nodes, which are laid out by the original force.\n\n  This way, we also have the freedom to apply a completely different force field setup to the helpers (no gravity\n  as it doesn't make sense for helpers, different charge values, etc.).\n  */\n  force2 = d3.layout.force()\n      .nodes(net.helper_nodes)\n      .links(net.helper_links)\n      .size([width, height])\n      .linkDistance(function(l, i) {\n        var n1 = l.real_source, n2 = l.real_target, rv,\n            lr = l.g_ref,\n            n1r, n2r,\n            dx, dy;\n\t\t\t\tif (l.cyclic)\n\t\t\t\t  return 15;\n        if (lr.source.size > 0 || lr.target.size > 0)\n          return 20;\n        return 1;\n      })\n      .gravity(0.0)   // just a tad of gravidy to help keep those curvy buttocks decent\n      .charge(function(d, i) {\n        // helper nodes have a medium-to-high charge, depending on the number of links the related force link represents.\n        // Hence bundles of links fro A->B will have helper nodes with huge charges: better spreading of the link paths.\n        //\n        // Unless we're looking at helpers for links between 'real nodes', NOT GROUPS: in that case we want to keep\n        // the lines are straight as posssible as there would only be one relation for A->B anyway, so we lower the charge\n        // for such nodes and helpers.\n        if (d.fixed)\n          return -10;\n        var l = d.link_ref,\n            c = l.link_count || 1;\n        if (l.source.size > 0 || l.target.size > 0)\n          return -30;\n        return -1;\n      })\n      .friction(0.95)\n      .start()\n      .stop();          // and immediately stop! force.tick will drive this one every tick!\n\n  hullg.selectAll(\"path.hull\").remove();\n  hull = hullg.selectAll(\"path.hull\")\n      .data(convexHulls(net.nodes, off))\n      .enter().append(\"path\")\n        .attr(\"class\", \"hull\")\n        .attr(\"d\", drawCluster)\n        .style(\"fill\", function(d) { return fill(d.group); })\n        .on(\"click\", on_hull_click);\n\n  if (debug == 1) {\n    link = linkg.selectAll(\"line.link\").data(net.links, linkid);\n    link.exit().remove();\n    link.enter().append(\"line\")\n        .attr(\"class\", \"link\")\n        .attr(\"x1\", function(d) { return d.source.x; })\n        .attr(\"y1\", function(d) { return d.source.y; })\n        .attr(\"x2\", function(d) { return d.target.x; })\n        .attr(\"y2\", function(d) { return d.target.y; });\n    // both existing and enter()ed links may have changed stroke width due to expand state change somewhere:\n    link.style(\"stroke-width\", function(d) { return d.size || 1; });\n  }\n\n  hlink = helper_linkg.selectAll(\"path.hlink\").data(net.helper_render_links, function(d) {\n    return d.id;\n  });\n  hlink.exit().remove();\n  hlink.enter().append(\"path\")\n      .attr(\"class\", \"hlink\");\n  // both existing and enter()ed links may have changed stroke width due to expand state change somewhere:\n  hlink.style(\"stroke-width\", function(d) { return d.size || 1; });\n\n\n  if (debug && debug < 3) {\n    hnode = helper_nodeg.selectAll(\"circle.node\").data(net.helper_nodes, function(d) {\n      return d.id;\n    });\n    hnode.exit().remove();\n    hnode.enter().append(\"circle\")\n        // if (d.size) -- d.size > 0 when d is a group node.\n        // d.size < 0 when d is a 'path helper node'.\n        .attr(\"class\", function(d) {\n          return \"node\" + (d.size > 0 ? \"\" : d.size < 0 ? \" helper\" : \" leaf\");\n        })\n        .attr(\"r\", function(d) {\n          return d.size > 0 ? d.size + dr : d.size < 0 ? 2 : dr + 1;\n        })\n        .attr(\"cx\", function(d) { return d.x; })\n        .attr(\"cy\", function(d) { return d.y; })\n        .style(\"fill\", function(d) { return fill(d.group); });\n  }\n\n  node = nodeg.selectAll(\"circle.node\").data(net.nodes, nodeid);\n  node.exit().remove();\n  node.enter().append(\"circle\")\n      // if (d.size) -- d.size > 0 when d is a group node.\n      // d.size < 0 when d is a 'path helper node'.\n      .attr(\"class\", function(d) {\n        return \"node\" + (d.size > 0 ? d.expansion ? \" link-expanded\" : \"\" : \" leaf\");\n      })\n      .attr(\"r\", function(d) {\n        return d.size > 0 ? d.size + dr : dr + 1;\n      })\n      .attr(\"cx\", function(d) { return d.x; })\n      .attr(\"cy\", function(d) { return d.y; })\n      .style(\"fill\", function(d) { return fill(d.group); })\n      .on(\"click\", on_node_click);\n\n  node.call(force1.drag);\n\n\tvar force1_drag = force1.drag(); // WORKS IN EXTENDED D#.js ONLY!\n\t\n  var drag_in_progress = false;\n  var change_squared = width * height;\n\t\n\tfunction on_drag_start(d) {\n    if (debug == 1) console.log(\"node drag START\", d, arguments, this, expand[d.group]);\n\t\t\n\t\tdrag_in_progress = true;\n\t}\n\t\n\tfunction on_drag_end(d) {\n    if (debug == 1) console.log(\"node drag END\", d, arguments, this, expand[d.group]);\n\t\t\n\t\tdrag_in_progress = false;\n\t\t\n\t\t// When CTRL key is pressed, we PIN the dragged node to the current location.\n\t\t// When SHIFT key is pressed, we PIN the entire expanded group to the current location. (only when node is a non-group one, i.e. in expanded group mode.\n\t\t// When neither have been pressed, we RELEASE the PIN on the node.\n\t\t// (To release the PIN on a group, click to cycle the group expand state: switching back to group node (state=0/1) releases the group PIN.)\n\t\tvar e = d3.event.sourceEvent;\n\t\tif (e.ctrlKey || e.shiftKey) {\n\t\t  d.fixed |= 0x04;\n\t\t} else {\n\t\t  d.fixed &= ~0x04;\n\t\t}\n    var g = getGroup(d);\n\t\tvar s = expand[g] || 0;\n\t\tif (e.shiftKey && s == 2) {\n\t\t\tnet.nodes.forEach(function(d, i) {\n\t\t\t  if (getGroup(d) == g) {\n\t\t\t\t  d.fixed |= 0x08;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\tforce1_drag\n\t\t.on(\"dragstart\", on_drag_start)\n\t\t.on(\"drag\", function(d) {\n\t\t  //\n\t\t})\n\t\t.on(\"dragend\", on_drag_end);\n\n  // CPU load redux for the fix, part 3: jumpstart the annealing process again when the user moves the mouse outside the node,\n  // when we believe the drag is still going on; even when it isn't anymore, but D3 doesn't inform us about that!\n  node\n    .on(\"mouseout.ger_fix\", function(d) {\n      if (debug == 1) console.log(\"mouseout.ger_fix\", this, arguments, d.fixed, drag_in_progress);\n      if (drag_in_progress) {\n        force1.resume();\n      }\n    });\n\n  var resume_threshold = 0.05;\n\n  force1.on(\"tick\", function(e) {\n    if (debug) {\n      alpha_trace.push(alpha_scale(e.alpha));\n      if (alpha_trace.length > width - 20)\n        alpha_trace.shift();\n      debug_g.select(\"path.trace-alpha\")\n          .attr(\"d\", alpha_line(alpha_trace));\n\n      c2_trace.push(c2_scale(change_squared));\n      if (c2_trace.length > width - 20)\n        c2_trace.shift();\n      debug_g.select(\"path.trace-c2\")\n          .attr(\"d\", c2_line(c2_trace));\n    }\n\n    /*\n    Force all nodes with only one link to point outwards.\n\n    To do this, we first calculate the center mass (okay, we wing it, we fake node 'weight'),\n    then see whether the target node for links from single-link nodes is closer to the\n    center-of-mass than us, and if it isn't, we push the node outwards.\n    */\n    var center = {x: 0, y: 0, weight: 0}, singles = [], centroids = {},\n        size, c, k, mx, my, dx, dy, alpha;\n\n    net.nodes.forEach(function(n) {\n      var w = Math.max(1, n.size || 0, n.weight || 0),\n          i = getGroup(n),\n          gc = centroids[i] || (centroids[i] = { x:0, y:0, weight: 0});\n\n      center.x += w * n.x;\n      center.y += w * n.y;\n      center.weight += w;\n\n      gc.x += w * n.x;\n      gc.y += w * n.y;\n      gc.weight += w;\n\n      if (n.size > 0 ? n.link_count < 4 : n.group_data.link_count < 3)\n        singles.push(n);\n    });\n\n    size = force1.size();\n\n    mx = size[0] / 2;\n    my = size[1] / 2;\n\n    for (k in centroids) {\n      var gc = centroids[k];\n      gc.x /= gc.weight;\n      gc.y /= gc.weight;\n    }\n\n    singles.forEach(function(n) {\n      var l = n.first_link, n2 = n.first_link_target,\n          proj, ax, bx, ay, by, k, x, y, alpha, rej, power,\n          dx, dy,\n          n_is_group = n.size || 0,\n          ng = n.group_data || n,\n          c2,\n          w = Math.max(1, n.size || 0, n.weight || 0),\n          i = getGroup(n),\n          gc = centroids[i];\n\n      // haven't decided what to do for unconnected nodes, yet...\n      if (!l)\n        return;\n\n      // apply amplification of the 'original' alpha:\n      // 1.0 for singles and double-connected nodes, close to 0 for highly connected nodes, rapidly decreasing.\n      // Use this as we want to give those 'non-singles' a little bit of the same 'push out' treatment.\n      // Reduce effect for 'real nodes' which are singles: they need much less encouragement!\n      power = Math.max(2, n_is_group ? n.link_count : n.group_data.link_count);\n      power = 2 / power;\n\n      alpha = e.alpha * power;\n\n      // undo/revert gravity forces (or as near as we can get, here)\n      //\n      // revert for truely single nodes, revert just a wee little bit for dual linked nodes,\n      // only reduce ever so slighty for nodes with few links (~ 3) that made it into this\n      // 'singles' selection\n      if (k = alpha * force1.gravity() * (0.8 + power)) {\n        dx = (mx - n.x) * k;\n        dy = (my - n.y) * k;\n        n.x -= dx;\n        n.y -= dy;\n\n        center.x -= dx * w;\n        center.y -= dy * w;\n        gc.x -= dx * w;\n        gc.y -= dy * w;\n      }\n    });\n\n    // move the entire graph so that its center of mass sits at the center, period.\n    center.x /= center.weight;\n    center.y /= center.weight;\n\n    if (debug == 1) {\n      c = vis.selectAll(\"circle.center-of-mass\")\n          .attr(\"cx\", center.x)\n          .attr(\"cy\", center.y);\n    }\n\n    dx = mx - center.x;\n    dy = my - center.y;\n\n    alpha = e.alpha * 5;\n    dx *= alpha;\n    dy *= alpha;\n\n    net.nodes.forEach(function(n) {\n      n.x += dx;\n      n.y += dy;\n    });\n\n\n    change_squared = 0;\n\n    // fixup .px/.py so drag behaviour and annealing get the correct values, as\n    // force.tick() would expect .px and .py to be the .x and .y of yesterday.\n    net.nodes.forEach(function(n) {\n      // restrain all nodes to window area\n      var k, dx, dy,\n          r = (n.size > 0 ? n.size + dr : dr + 1) + 2 /* styled border outer thickness and a bit */;\n\n      dx = 0;\n      if (n.x < r)\n        dx = r - n.x;\n      else if (n.x > size[0] - r)\n        dx = size[0] - r - n.x;\n\n      dy = 0;\n      if (n.y < r)\n        dy = r - n.y;\n      else if (n.y > size[1] - r)\n        dy = size[1] - r - n.y;\n\n      k = 1.2;\n\n      n.x += dx * k;\n      n.y += dy * k;\n      // restraining completed.......................\n\n      // fixes 'elusive' node behaviour when hovering with the mouse (related to force.drag)\n      if (n.fixed) {\n        // 'elusive behaviour' ~ move mouse near node and node would take off, i.e. act as an elusive creature.\n        n.x = n.px;\n        n.y = n.py;\n      }\n      n.px = n.x;\n      n.py = n.y;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n\t\t\n\t\t// also restrain helper nodes to within the visible area --> link paths are almost always ket in-view:\n    net.helper_nodes.forEach(function(n) {\n      // restrain all nodes to window area\n      var k, dx, dy,\n          r = (n.size > 0 ? n.size : 1) + 5 /* heuristic */;\n\n      dx = 0;\n      if (n.x < r)\n        dx = r - n.x;\n      else if (n.x > size[0] - r)\n        dx = size[0] - r - n.x;\n\n      dy = 0;\n      if (n.y < r)\n        dy = r - n.y;\n      else if (n.y > size[1] - r)\n        dy = size[1] - r - n.y;\n\n      k = 1.2;\n\n      n.x += dx * k;\n      n.y += dy * k;\n      // restraining completed.......................\n\n      n.px = n.x;\n      n.py = n.y;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n\t\t\n    if (!isFinite(change_squared))\n      change_squared = width * height;\n\n    // kick the force2 to also do a bit of annealing alongside:\n    // to make it do something, we need to surround it alpha-tweaking stuff, though.\n    force2.resume();\n    force2.tick();\n    force2.stop();\n\n    // fast stop + the drag fix, part 2:\n    if (change_squared < .05) {\n      if (debug == 1) console.log(\"fast stop: CPU load redux\");\n      force1.stop();\n      // fix part 4: monitor D3 resetting the drag marker:\n      if (drag_in_progress) {\n        if (debug == 1) console.log(\"START monitor drag in progress\", drag_in_progress);\n        d3.timer(function() {\n          force1.resume();\n          if (debug == 1) console.log(\"monitor drag in progress: drag ENDED\", drag_in_progress);\n          // Quit monitoring as soon as we noticed the drag ENDED.\n          // Note: we continue to monitor at +500ms intervals beyond the last tick\n          //       as this timer function ALWAYS kickstarts the force layout again\n          //       through force.resume().\n          //       d3.timer() API only accepts an initial delay; we can't set this\n          //       thing to scan, say, every 500msecs until the drag is done,\n          //       so we do it that way, via the revived force.tick process.\n          return true;\n        }, 500);\n      }\n    } else if (change_squared > net.nodes.length * 0.1 * resume_threshold && e.alpha < resume_threshold) {\n      // jolt the alpha (and the visual) when there's still a lot of change when we hit the alpha threshold.\n      force1.alpha(e.alpha *= 2); //force.resume(), but now with decreasing alpha starting value so the jolts don't get so big.\n\n      // And 'dampen out' the trigger point, so it becomes harder and harder to trigger the threshold.\n      // This is done to cope with those instable (forever rotating, etc.) layouts...\n      resume_threshold *= 0.75;\n    } else {\n      //console.log(\"fast stop tracking: \", change_squared, net.nodes.length * 0.1 * resume_threshold, e.alpha, resume_threshold);\n    }\n\n    //--------------------------------------------------------------------\n\n    if (!hull.empty()) {\n      hull.data(convexHulls(net.nodes, off))\n          .attr(\"d\", drawCluster);\n    }\n\n    if (debug == 1) {\n      link.attr(\"x1\", function(d) { return d.source.x; })\n          .attr(\"y1\", function(d) { return d.source.y; })\n          .attr(\"x2\", function(d) { return d.target.x; })\n          .attr(\"y2\", function(d) { return d.target.y; });\n    }\n\n    node.attr(\"cx\", function(d) { return d.x; })\n        .attr(\"__name__\", function(d) { return d.name || \"xxx\"; })\n        .attr(\"cy\", function(d) { return d.y; });\n  });\n\n\n\n  var log_count = 100;\n\n\n\n\n  force2.on(\"tick\", function(e) {\n    /*\n      Update all 'real'=fixed nodes.\n    */\n    net.helper_nodes.forEach(function(n) {\n      var o;\n      if (n.fixed) {\n        o = n.ref;\n        n.px = n.x = o.x;\n        n.py = n.y = o.y;\n      }\n    });\n    net.helper_links.forEach(function(l) {\n      var o = l.g_ref;\n      l.distance = o.distance;\n    });\n\n    // NOTE: force2 is fully driven by force(1), but still there's need for 'fast stop' handling in here\n    //       as our force2 may be more 'joyous' in animating the links that force is animating the nodes\n    //       themselves. Hence we also take the delta movement of the helper nodes into account!\n    net.helper_nodes.forEach(function(n) {\n      // skip the 'fixed' buggers: those are already accounted for in force.tick!\n      if (n.fixed)\n        return;\n\n      // plus copy for faster stop check\n      change_squared += (n.qx - n.x) * (n.qx - n.x);\n      change_squared += (n.qy - n.y) * (n.qy - n.y);\n      n.qx = n.x;\n      n.qy = n.y;\n    });\n    if (!isFinite(change_squared))\n      change_squared = width * height;\n\n    //--------------------------------------------------------------------\n\n    var logged = false;\n\n    hlink.attr(\"d\", function(d) {\n      if (isFinite(d.real_source.x)) {\n\t\t\t  var linedata, dx, dy, f;\n\t\t\t  if (d.cyclic) {\n\t\t\t\t  // construct round-ish bezier from node to helper and back again:\n\t\t\t\t  dx = d.target.x - d.real_source.x;\n\t\t\t\t  dy = d.target.y - d.real_source.y;\n\t\t\t\t\tlinedata = [\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y],\n\t\t\t\t\t\t\t[d.target.x - cycle_curvep * dy, d.target.y + cycle_curvep * dx], \n\t\t\t\t\t\t\t[d.target.x + cycle_curvep * dx, d.target.y + cycle_curvep * dy], \n\t\t\t\t\t\t\t[d.target.x + cycle_curvep * dy, d.target.y - cycle_curvep * dx],\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y]\n\t\t\t\t\t];\n\t\t\t\t\treturn cycle_pathgen(linedata);\n\t\t\t\t} else {\n\t\t\t\t\tlinedata = [\n\t\t\t\t\t\t\t[d.real_source.x, d.real_source.y],\n\t\t\t\t\t\t\t[d.source.x, d.source.y],\n\t\t\t\t\t\t\t[d.target.x, d.target.y],\n\t\t\t\t\t\t\t[d.real_target.x, d.real_target.y]\n\t\t\t\t\t];\n\t\t\t\t\treturn pathgen(linedata);\n\t\t\t\t}\n      } else {\n        if (!logged) {\n          console.log(\"boom\");\n          logged = true;\n        }\n        return null;\n      }\n    });\n\n    if (debug && debug < 3) {\n      hnode.attr(\"cx\", function(d) { return d.x; })\n           .attr(\"cy\", function(d) { return d.y; });\n    }\n  });\n}\n\n    </script>\n  </body>\n</html>\n",
      "language": "HTML"
    },
    "miserables-with-cycles.json": {
      "type": "application/json",
      "filename": "miserables-with-cycles.json",
      "raw_url": "https://gist.github.com/raw/3637711/c91a8d1202a110db75592f919aa899c624610c72/miserables-with-cycles.json",
      "size": 12446,
      "content": "{\n\"nodes\":[\n{\"name\":\"Myriel\",\"group\":1},\n{\"name\":\"Napoleon\",\"group\":1},\n{\"name\":\"Mlle.Baptistine\",\"group\":1},\n{\"name\":\"Mme.Magloire\",\"group\":1},\n{\"name\":\"CountessdeLo\",\"group\":1},\n{\"name\":\"Geborand\",\"group\":1},\n{\"name\":\"Champtercier\",\"group\":1},\n{\"name\":\"Cravatte\",\"group\":1},\n{\"name\":\"Count\",\"group\":1},\n{\"name\":\"OldMan\",\"group\":1},\n{\"name\":\"Labarre\",\"group\":2},\n{\"name\":\"Valjean\",\"group\":2},\n{\"name\":\"Marguerite\",\"group\":3},\n{\"name\":\"Mme.deR\",\"group\":2},\n{\"name\":\"Isabeau\",\"group\":2},\n{\"name\":\"Gervais\",\"group\":2},\n{\"name\":\"Tholomyes\",\"group\":3},\n{\"name\":\"Listolier\",\"group\":3},\n{\"name\":\"Fameuil\",\"group\":3},\n{\"name\":\"Blacheville\",\"group\":3},\n{\"name\":\"Favourite\",\"group\":3},\n{\"name\":\"Dahlia\",\"group\":3},\n{\"name\":\"Zephine\",\"group\":3},\n{\"name\":\"Fantine\",\"group\":3},\n{\"name\":\"Mme.Thenardier\",\"group\":4},\n{\"name\":\"Thenardier\",\"group\":4},\n{\"name\":\"Cosette\",\"group\":5},\n{\"name\":\"Javert\",\"group\":4},\n{\"name\":\"Fauchelevent\",\"group\":0},\n{\"name\":\"Bamatabois\",\"group\":2},\n{\"name\":\"Perpetue\",\"group\":3},\n{\"name\":\"Simplice\",\"group\":2},\n{\"name\":\"Scaufflaire\",\"group\":2},\n{\"name\":\"Woman1\",\"group\":2},\n{\"name\":\"Judge\",\"group\":2},\n{\"name\":\"Champmathieu\",\"group\":2},\n{\"name\":\"Brevet\",\"group\":2},\n{\"name\":\"Chenildieu\",\"group\":2},\n{\"name\":\"Cochepaille\",\"group\":2},\n{\"name\":\"Pontmercy\",\"group\":4},\n{\"name\":\"Boulatruelle\",\"group\":6},\n{\"name\":\"Eponine\",\"group\":4},\n{\"name\":\"Anzelma\",\"group\":4},\n{\"name\":\"Woman2\",\"group\":5},\n{\"name\":\"MotherInnocent\",\"group\":0},\n{\"name\":\"Gribier\",\"group\":0},\n{\"name\":\"Jondrette\",\"group\":7},\n{\"name\":\"Mme.Burgon\",\"group\":7},\n{\"name\":\"Gavroche\",\"group\":8},\n{\"name\":\"Gillenormand\",\"group\":5},\n{\"name\":\"Magnon\",\"group\":5},\n{\"name\":\"Mlle.Gillenormand\",\"group\":5},\n{\"name\":\"Mme.Pontmercy\",\"group\":5},\n{\"name\":\"Mlle.Vaubois\",\"group\":5},\n{\"name\":\"Lt.Gillenormand\",\"group\":5},\n{\"name\":\"Marius\",\"group\":8},\n{\"name\":\"BaronessT\",\"group\":5},\n{\"name\":\"Mabeuf\",\"group\":8},\n{\"name\":\"Enjolras\",\"group\":8},\n{\"name\":\"Combeferre\",\"group\":8},\n{\"name\":\"Prouvaire\",\"group\":8},\n{\"name\":\"Feuilly\",\"group\":8},\n{\"name\":\"Courfeyrac\",\"group\":8},\n{\"name\":\"Bahorel\",\"group\":8},\n{\"name\":\"Bossuet\",\"group\":8},\n{\"name\":\"Joly\",\"group\":8},\n{\"name\":\"Grantaire\",\"group\":8},\n{\"name\":\"MotherPlutarch\",\"group\":9},\n{\"name\":\"Gueulemer\",\"group\":4},\n{\"name\":\"Babet\",\"group\":4},\n{\"name\":\"Claquesous\",\"group\":4},\n{\"name\":\"Montparnasse\",\"group\":4},\n{\"name\":\"Toussaint\",\"group\":5},\n{\"name\":\"Child1\",\"group\":10},\n{\"name\":\"Child2\",\"group\":10},\n{\"name\":\"Brujon\",\"group\":4},\n{\"name\":\"Mme.Hucheloup\",\"group\":8}\n],\"links\":[\n{\"source\":1,\"target\":0,\"value\":1},\n{\"source\":2,\"target\":0,\"value\":8},\n{\"source\":3,\"target\":0,\"value\":10},\n{\"source\":3,\"target\":2,\"value\":6},\n{\"source\":4,\"target\":0,\"value\":1},\n{\"source\":5,\"target\":0,\"value\":1},\n{\"source\":6,\"target\":0,\"value\":1},\n{\"source\":7,\"target\":0,\"value\":1},\n{\"source\":8,\"target\":0,\"value\":2},\n{\"source\":9,\"target\":0,\"value\":1},\n{\"source\":11,\"target\":10,\"value\":1},\n{\"source\":11,\"target\":3,\"value\":3},\n{\"source\":11,\"target\":2,\"value\":3},\n{\"source\":11,\"target\":0,\"value\":5},\n{\"source\":12,\"target\":11,\"value\":1},\n{\"source\":13,\"target\":11,\"value\":1},\n{\"source\":14,\"target\":11,\"value\":1},\n{\"source\":15,\"target\":11,\"value\":1},\n{\"source\":17,\"target\":16,\"value\":4},\n{\"source\":18,\"target\":16,\"value\":4},\n{\"source\":18,\"target\":17,\"value\":4},\n{\"source\":19,\"target\":16,\"value\":4},\n{\"source\":19,\"target\":17,\"value\":4},\n{\"source\":19,\"target\":18,\"value\":4},\n{\"source\":20,\"target\":16,\"value\":3},\n{\"source\":20,\"target\":17,\"value\":3},\n{\"source\":20,\"target\":18,\"value\":3},\n{\"source\":20,\"target\":19,\"value\":4},\n{\"source\":21,\"target\":16,\"value\":3},\n{\"source\":21,\"target\":17,\"value\":3},\n{\"source\":21,\"target\":18,\"value\":3},\n{\"source\":21,\"target\":19,\"value\":3},\n{\"source\":21,\"target\":20,\"value\":5},\n{\"source\":22,\"target\":16,\"value\":3},\n{\"source\":22,\"target\":17,\"value\":3},\n{\"source\":22,\"target\":18,\"value\":3},\n{\"source\":22,\"target\":19,\"value\":3},\n{\"source\":22,\"target\":20,\"value\":4},\n{\"source\":22,\"target\":21,\"value\":4},\n{\"source\":23,\"target\":16,\"value\":3},\n{\"source\":23,\"target\":17,\"value\":3},\n{\"source\":23,\"target\":18,\"value\":3},\n{\"source\":23,\"target\":19,\"value\":3},\n{\"source\":23,\"target\":20,\"value\":4},\n{\"source\":23,\"target\":21,\"value\":4},\n{\"source\":23,\"target\":22,\"value\":4},\n{\"source\":23,\"target\":12,\"value\":2},\n{\"source\":23,\"target\":11,\"value\":9},\n{\"source\":24,\"target\":23,\"value\":2},\n{\"source\":24,\"target\":11,\"value\":7},\n{\"source\":25,\"target\":24,\"value\":13},\n{\"source\":25,\"target\":23,\"value\":1},\n{\"source\":25,\"target\":11,\"value\":12},\n{\"source\":26,\"target\":24,\"value\":4},\n{\"source\":26,\"target\":11,\"value\":31},\n{\"source\":26,\"target\":16,\"value\":1},\n{\"source\":26,\"target\":25,\"value\":1},\n{\"source\":27,\"target\":11,\"value\":17},\n{\"source\":27,\"target\":23,\"value\":5},\n{\"source\":27,\"target\":25,\"value\":5},\n{\"source\":27,\"target\":24,\"value\":1},\n{\"source\":27,\"target\":26,\"value\":1},\n{\"source\":28,\"target\":11,\"value\":8},\n{\"source\":28,\"target\":27,\"value\":1},\n{\"source\":29,\"target\":23,\"value\":1},\n{\"source\":29,\"target\":27,\"value\":1},\n{\"source\":29,\"target\":11,\"value\":2},\n{\"source\":30,\"target\":23,\"value\":1},\n{\"source\":31,\"target\":30,\"value\":2},\n{\"source\":31,\"target\":11,\"value\":3},\n{\"source\":31,\"target\":23,\"value\":2},\n{\"source\":31,\"target\":27,\"value\":1},\n{\"source\":32,\"target\":11,\"value\":1},\n{\"source\":33,\"target\":11,\"value\":2},\n{\"source\":33,\"target\":27,\"value\":1},\n{\"source\":34,\"target\":11,\"value\":3},\n{\"source\":34,\"target\":29,\"value\":2},\n{\"source\":35,\"target\":11,\"value\":3},\n{\"source\":35,\"target\":34,\"value\":3},\n{\"source\":35,\"target\":29,\"value\":2},\n{\"source\":36,\"target\":34,\"value\":2},\n{\"source\":36,\"target\":35,\"value\":2},\n{\"source\":36,\"target\":11,\"value\":2},\n{\"source\":36,\"target\":29,\"value\":1},\n{\"source\":37,\"target\":34,\"value\":2},\n{\"source\":37,\"target\":35,\"value\":2},\n{\"source\":37,\"target\":36,\"value\":2},\n{\"source\":37,\"target\":11,\"value\":2},\n{\"source\":37,\"target\":29,\"value\":1},\n{\"source\":38,\"target\":34,\"value\":2},\n{\"source\":38,\"target\":35,\"value\":2},\n{\"source\":38,\"target\":36,\"value\":2},\n{\"source\":38,\"target\":37,\"value\":2},\n{\"source\":38,\"target\":11,\"value\":2},\n{\"source\":38,\"target\":29,\"value\":1},\n{\"source\":39,\"target\":25,\"value\":1},\n{\"source\":40,\"target\":25,\"value\":1},\n{\"source\":41,\"target\":24,\"value\":2},\n{\"source\":41,\"target\":25,\"value\":3},\n{\"source\":42,\"target\":41,\"value\":2},\n{\"source\":42,\"target\":25,\"value\":2},\n{\"source\":42,\"target\":24,\"value\":1},\n{\"source\":43,\"target\":11,\"value\":3},\n{\"source\":43,\"target\":26,\"value\":1},\n{\"source\":43,\"target\":27,\"value\":1},\n{\"source\":44,\"target\":28,\"value\":3},\n{\"source\":44,\"target\":11,\"value\":1},\n{\"source\":45,\"target\":28,\"value\":2},\n{\"source\":47,\"target\":46,\"value\":1},\n{\"source\":48,\"target\":47,\"value\":2},\n{\"source\":48,\"target\":25,\"value\":1},\n{\"source\":48,\"target\":27,\"value\":1},\n{\"source\":48,\"target\":11,\"value\":1},\n{\"source\":49,\"target\":26,\"value\":3},\n{\"source\":49,\"target\":11,\"value\":2},\n{\"source\":50,\"target\":49,\"value\":1},\n{\"source\":50,\"target\":24,\"value\":1},\n{\"source\":51,\"target\":49,\"value\":9},\n{\"source\":51,\"target\":26,\"value\":2},\n{\"source\":51,\"target\":11,\"value\":2},\n{\"source\":52,\"target\":51,\"value\":1},\n{\"source\":52,\"target\":39,\"value\":1},\n{\"source\":53,\"target\":51,\"value\":1},\n{\"source\":54,\"target\":51,\"value\":2},\n{\"source\":54,\"target\":49,\"value\":1},\n{\"source\":54,\"target\":26,\"value\":1},\n{\"source\":55,\"target\":51,\"value\":6},\n{\"source\":55,\"target\":49,\"value\":12},\n{\"source\":55,\"target\":39,\"value\":1},\n{\"source\":55,\"target\":54,\"value\":1},\n{\"source\":55,\"target\":26,\"value\":21},\n{\"source\":55,\"target\":11,\"value\":19},\n{\"source\":55,\"target\":16,\"value\":1},\n{\"source\":55,\"target\":25,\"value\":2},\n{\"source\":55,\"target\":41,\"value\":5},\n{\"source\":55,\"target\":48,\"value\":4},\n{\"source\":56,\"target\":49,\"value\":1},\n{\"source\":56,\"target\":55,\"value\":1},\n{\"source\":57,\"target\":55,\"value\":1},\n{\"source\":57,\"target\":41,\"value\":1},\n{\"source\":57,\"target\":48,\"value\":1},\n{\"source\":58,\"target\":55,\"value\":7},\n{\"source\":58,\"target\":48,\"value\":7},\n{\"source\":58,\"target\":27,\"value\":6},\n{\"source\":58,\"target\":57,\"value\":1},\n{\"source\":58,\"target\":11,\"value\":4},\n{\"source\":59,\"target\":58,\"value\":15},\n{\"source\":59,\"target\":55,\"value\":5},\n{\"source\":59,\"target\":48,\"value\":6},\n{\"source\":59,\"target\":57,\"value\":2},\n{\"source\":60,\"target\":48,\"value\":1},\n{\"source\":60,\"target\":58,\"value\":4},\n{\"source\":60,\"target\":59,\"value\":2},\n{\"source\":61,\"target\":48,\"value\":2},\n{\"source\":61,\"target\":58,\"value\":6},\n{\"source\":61,\"target\":60,\"value\":2},\n{\"source\":61,\"target\":59,\"value\":5},\n{\"source\":61,\"target\":57,\"value\":1},\n{\"source\":61,\"target\":55,\"value\":1},\n{\"source\":62,\"target\":55,\"value\":9},\n{\"source\":62,\"target\":58,\"value\":17},\n{\"source\":62,\"target\":59,\"value\":13},\n{\"source\":62,\"target\":48,\"value\":7},\n{\"source\":62,\"target\":57,\"value\":2},\n{\"source\":62,\"target\":41,\"value\":1},\n{\"source\":62,\"target\":61,\"value\":6},\n{\"source\":62,\"target\":60,\"value\":3},\n{\"source\":63,\"target\":59,\"value\":5},\n{\"source\":63,\"target\":48,\"value\":5},\n{\"source\":63,\"target\":62,\"value\":6},\n{\"source\":63,\"target\":57,\"value\":2},\n{\"source\":63,\"target\":58,\"value\":4},\n{\"source\":63,\"target\":61,\"value\":3},\n{\"source\":63,\"target\":60,\"value\":2},\n{\"source\":63,\"target\":55,\"value\":1},\n{\"source\":64,\"target\":55,\"value\":5},\n{\"source\":64,\"target\":62,\"value\":12},\n{\"source\":64,\"target\":48,\"value\":5},\n{\"source\":64,\"target\":63,\"value\":4},\n{\"source\":64,\"target\":58,\"value\":10},\n{\"source\":64,\"target\":61,\"value\":6},\n{\"source\":64,\"target\":60,\"value\":2},\n{\"source\":64,\"target\":59,\"value\":9},\n{\"source\":64,\"target\":57,\"value\":1},\n{\"source\":64,\"target\":11,\"value\":1},\n{\"source\":65,\"target\":63,\"value\":5},\n{\"source\":65,\"target\":64,\"value\":7},\n{\"source\":65,\"target\":48,\"value\":3},\n{\"source\":65,\"target\":62,\"value\":5},\n{\"source\":65,\"target\":58,\"value\":5},\n{\"source\":65,\"target\":61,\"value\":5},\n{\"source\":65,\"target\":60,\"value\":2},\n{\"source\":65,\"target\":59,\"value\":5},\n{\"source\":65,\"target\":57,\"value\":1},\n{\"source\":65,\"target\":55,\"value\":2},\n{\"source\":66,\"target\":64,\"value\":3},\n{\"source\":66,\"target\":58,\"value\":3},\n{\"source\":66,\"target\":59,\"value\":1},\n{\"source\":66,\"target\":62,\"value\":2},\n{\"source\":66,\"target\":65,\"value\":2},\n{\"source\":66,\"target\":48,\"value\":1},\n{\"source\":66,\"target\":63,\"value\":1},\n{\"source\":66,\"target\":61,\"value\":1},\n{\"source\":66,\"target\":60,\"value\":1},\n{\"source\":67,\"target\":57,\"value\":3},\n{\"source\":68,\"target\":25,\"value\":5},\n{\"source\":68,\"target\":11,\"value\":1},\n{\"source\":68,\"target\":24,\"value\":1},\n{\"source\":68,\"target\":27,\"value\":1},\n{\"source\":68,\"target\":48,\"value\":1},\n{\"source\":68,\"target\":41,\"value\":1},\n{\"source\":69,\"target\":25,\"value\":6},\n{\"source\":69,\"target\":68,\"value\":6},\n{\"source\":69,\"target\":11,\"value\":1},\n{\"source\":69,\"target\":24,\"value\":1},\n{\"source\":69,\"target\":27,\"value\":2},\n{\"source\":69,\"target\":48,\"value\":1},\n{\"source\":69,\"target\":41,\"value\":1},\n{\"source\":70,\"target\":25,\"value\":4},\n{\"source\":70,\"target\":69,\"value\":4},\n{\"source\":70,\"target\":68,\"value\":4},\n{\"source\":70,\"target\":11,\"value\":1},\n{\"source\":70,\"target\":24,\"value\":1},\n{\"source\":70,\"target\":27,\"value\":1},\n{\"source\":70,\"target\":41,\"value\":1},\n{\"source\":70,\"target\":58,\"value\":1},\n{\"source\":71,\"target\":27,\"value\":1},\n{\"source\":71,\"target\":69,\"value\":2},\n{\"source\":71,\"target\":68,\"value\":2},\n{\"source\":71,\"target\":70,\"value\":2},\n{\"source\":71,\"target\":11,\"value\":1},\n{\"source\":71,\"target\":48,\"value\":1},\n{\"source\":71,\"target\":41,\"value\":1},\n{\"source\":71,\"target\":25,\"value\":1},\n{\"source\":72,\"target\":26,\"value\":2},\n{\"source\":72,\"target\":27,\"value\":1},\n{\"source\":72,\"target\":11,\"value\":1},\n{\"source\":73,\"target\":48,\"value\":2},\n{\"source\":74,\"target\":48,\"value\":2},\n{\"source\":74,\"target\":73,\"value\":3},\n{\"source\":75,\"target\":69,\"value\":3},\n{\"source\":75,\"target\":68,\"value\":3},\n{\"source\":75,\"target\":25,\"value\":3},\n{\"source\":75,\"target\":48,\"value\":1},\n{\"source\":75,\"target\":41,\"value\":1},\n{\"source\":75,\"target\":70,\"value\":1},\n{\"source\":75,\"target\":71,\"value\":1},\n{\"source\":76,\"target\":64,\"value\":1},\n{\"source\":76,\"target\":65,\"value\":1},\n{\"source\":76,\"target\":66,\"value\":1},\n{\"source\":76,\"target\":63,\"value\":1},\n{\"source\":76,\"target\":62,\"value\":1},\n{\"source\":76,\"target\":48,\"value\":1},\n{\"source\":76,\"target\":58,\"value\":1},\n{\"source\":40,\"target\":40,\"value\":2,\"cyclic\":1},\n{\"source\":40,\"target\":40,\"value\":3,\"cyclic\":1},\n{\"source\":65,\"target\":65,\"value\":1,\"cyclic\":1},\n{\"source\":66,\"target\":66,\"value\":1,\"cyclic\":1},\n{\"source\":67,\"target\":67,\"value\":1,\"cyclic\":1},\n{\"source\":68,\"target\":68,\"value\":1,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":2,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":3,\"cyclic\":1},\n{\"source\":46,\"target\":46,\"value\":1,\"cyclic\":1},\n{\"source\":73,\"target\":73,\"value\":3,\"cyclic\":1},\n{\"source\":74,\"target\":74,\"value\":1,\"cyclic\":1},\n{\"source\":47,\"target\":47,\"value\":2,\"cyclic\":1}\n]\n}",
      "language": "JSON"
    }
  },
  "git_push_url": "git@gist.github.com:3637711.git",
  "updated_at": "2012-09-09T07:55:39Z",
  "url": "https://api.github.com/gists/3637711",
  "id": "3637711"
}
