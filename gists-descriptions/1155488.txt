{
  "forks": [

  ],
  "user": {
    "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
    "login": "RyanBalfanz",
    "url": "https://api.github.com/users/RyanBalfanz",
    "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
    "id": 133278
  },
  "history": [
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "version": "a58ed55f9f198dcfeb90636c8a3f3605b251c33c",
      "committed_at": "2011-08-19T17:55:05Z",
      "url": "https://api.github.com/gists/1155488/a58ed55f9f198dcfeb90636c8a3f3605b251c33c"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "version": "cb5f52474d6530a4a0f3d7e9264cce2b577e06f4",
      "committed_at": "2011-08-19T17:50:29Z",
      "url": "https://api.github.com/gists/1155488/cb5f52474d6530a4a0f3d7e9264cce2b577e06f4"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 11,
        "additions": 11,
        "deletions": 0
      },
      "version": "2ed93222a7d88bac0cabeee2bad5f69b84a60507",
      "committed_at": "2011-08-19T17:49:37Z",
      "url": "https://api.github.com/gists/1155488/2ed93222a7d88bac0cabeee2bad5f69b84a60507"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "version": "7e4c22b402ac4513985659a3f3c94623a167ec9b",
      "committed_at": "2011-08-19T17:42:43Z",
      "url": "https://api.github.com/gists/1155488/7e4c22b402ac4513985659a3f3c94623a167ec9b"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 9,
        "additions": 4,
        "deletions": 5
      },
      "version": "1fdafaa2b09f4dc91c382c74bf7490b3d86bc992",
      "committed_at": "2011-08-19T17:35:34Z",
      "url": "https://api.github.com/gists/1155488/1fdafaa2b09f4dc91c382c74bf7490b3d86bc992"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 4,
        "additions": 2,
        "deletions": 2
      },
      "version": "e6285514eb92c0a260ca7772a2eda699ad543bc3",
      "committed_at": "2011-08-18T23:12:07Z",
      "url": "https://api.github.com/gists/1155488/e6285514eb92c0a260ca7772a2eda699ad543bc3"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 6,
        "additions": 3,
        "deletions": 3
      },
      "version": "e8f9894a9f88051d35de262c8211161e84d18790",
      "committed_at": "2011-08-18T23:11:11Z",
      "url": "https://api.github.com/gists/1155488/e8f9894a9f88051d35de262c8211161e84d18790"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "version": "319db7d2158bd82a02b49656d62b4c31129611b1",
      "committed_at": "2011-08-18T23:09:42Z",
      "url": "https://api.github.com/gists/1155488/319db7d2158bd82a02b49656d62b4c31129611b1"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 6,
        "additions": 3,
        "deletions": 3
      },
      "version": "2a5c44d38063688c4c8336a95b1051339893762a",
      "committed_at": "2011-08-18T23:08:22Z",
      "url": "https://api.github.com/gists/1155488/2a5c44d38063688c4c8336a95b1051339893762a"
    },
    {
      "user": {
        "gravatar_id": "035f4ca4b642ae727fa9c6344c2d88b5",
        "login": "RyanBalfanz",
        "url": "https://api.github.com/users/RyanBalfanz",
        "avatar_url": "https://secure.gravatar.com/avatar/035f4ca4b642ae727fa9c6344c2d88b5?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "id": 133278
      },
      "change_status": {
        "total": 2,
        "additions": 1,
        "deletions": 1
      },
      "version": "b0862177ebece2223355ee0200aaa5f7772e76ed",
      "committed_at": "2011-08-18T23:06:22Z",
      "url": "https://api.github.com/gists/1155488/b0862177ebece2223355ee0200aaa5f7772e76ed"
    }
  ],
  "description": "Goodbye-Mint",
  "comments": 0,
  "created_at": "2011-08-18T23:02:41Z",
  "public": true,
  "html_url": "https://gist.github.com/1155488",
  "git_pull_url": "git://gist.github.com/1155488.git",
  "files": {
    "chart.css": {
      "type": "text/css",
      "filename": "chart.css",
      "size": 1055,
      "raw_url": "https://gist.github.com/raw/1155488/1063e19b7c6032f2819061c5702c55617c676d8a/chart.css",
      "content": "html \t{\n\theight: 100%;\n\t-webkit-box-shadow: inset 0 0 20px 0 rgba(0,0,0,0.2);\n\t-moz-box-shadow: inset 0 0 20px 0 rgba(0,0,0,0.2);\n\t-webkit-font-smoothing: antialiased;\n\tpadding: 0;\n\tmargin: 0;\n\tfont-family: 'HelveticaNeue', Helvetica, Arial Sans-serif;\n\tfont-size: 13px;\n\tcolor: #555555;\n}\n\nbody {\n\tpadding: 0;\n\tmargin: 0;\n\tfont: 10px sans-serif;\n}\n\n.rule line {\n\tstroke: #eee;\n\tshape-rendering: crispEdges;\n}\n\n.rule line.axis {\n\tstroke: #000;\n}\n\n.line {\n\tfill: none;\n\tstroke: #379f6a;\n\tstroke-width: 1.5px;\n}\n\ncircle.line {\n\tfill: #fff;\n}\n\n#main\t{\n\twidth: 960px;\n\tmargin: 0 auto;\n}\n\n#chartContainer\t{\n\twidth: 90%;\n\theight: 450px;\n\tborder: 10px solid rgba(255,255,255,1);\n\t-webkit-box-shadow: 0 0 5px 0 rgba(0,0,0,0.3);\n\t-moz-box-shadow: 0 0 5px 0 rgba(0,0,0,0.3);\n}\n\nh1\t{\n\tfont-size: 30px;\n\tline-height: 30px;\n\tmargin: 20px 0;\n\ttext-shadow: 0 -2px 2px rgba(0,0,0,0.1);\n\tcolor: #379f6a;\n}\n\nsvg {\n\tpadding: 0;\n\tmargin: 20px auto;\n}\n\nli\t{\n\tfont-size: 1.25em;\n\tpadding-bottom: 10px\n}\n\n#notes {\n\twidth: 33%;\n\theight: 100%;\n\tmargin-right: 40px;\n\tfloat: left;\n}",
      "language": "CSS"
    },
    "chart.js": {
      "type": "application/javascript",
      "filename": "chart.js",
      "size": 1622,
      "raw_url": "https://gist.github.com/raw/1155488/ba2208e0ae72d18f4d903ca3edbe497173fd7e8d/chart.js",
      "content": "function randomBounded(from, to){\n return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\nvar data = d3.range(20).map(function(i) {\n  return {x: i / 19, y: (i / 19)};\n});\n\nvar w = 450,\n    h = 275,\n    p = 20,\n    x = d3.scale.linear().domain([0, 1]).range([0, w]),\n    y = d3.scale.linear().domain([0, 1]).range([h, 0]);\n\nvar vis = d3.select(\"#chartContainer\")\n    .data([data])\n  .append(\"svg:svg\")\n    .attr(\"width\", w + p * 2)\n    .attr(\"height\", h + p * 2)\n  .append(\"svg:g\")\n    .attr(\"transform\", \"translate(\" + p + \",\" + p + \")\");\n\nvar rules = vis.selectAll(\"g.rule\")\n    .data(x.ticks(10))\n  .enter().append(\"svg:g\")\n    .attr(\"class\", \"rule\");\n\nrules.append(\"svg:line\")\n    .attr(\"x1\", x)\n    .attr(\"x2\", x)\n    .attr(\"y1\", 0)\n    .attr(\"y2\", h - 1);\n\nrules.append(\"svg:line\")\n    .attr(\"class\", function(d) { return d ? null : \"axis\"; })\n    .attr(\"y1\", y)\n    .attr(\"y2\", y)\n    .attr(\"x1\", 0)\n    .attr(\"x2\", w + 1);\n\nrules.append(\"svg:text\")\n    .attr(\"x\", x)\n    .attr(\"y\", h + 3)\n    .attr(\"dy\", \".71em\")\n    .attr(\"text-anchor\", \"middle\")\n    .text(x.tickFormat(10));\n\nrules.append(\"svg:text\")\n    .attr(\"y\", y)\n    .attr(\"x\", -3)\n    .attr(\"dy\", \".35em\")\n    .attr(\"text-anchor\", \"end\")\n    .text(y.tickFormat(10));\n\nvis.append(\"svg:path\")\n    .attr(\"class\", \"line\")\n    .attr(\"d\", d3.svg.line()\n    .x(function(d) { return x(d.x); })\n    .y(function(d) { return y(d.y); }));\n\nvis.selectAll(\"circle.line\")\n    .data(data)\n  .enter().append(\"svg:circle\")\n    .attr(\"class\", \"line\")\n    .attr(\"cx\", function(d) { return x(d.x); })\n    .attr(\"cy\", function(d) { return y(d.y); })\n    .attr(\"r\", 3.5);",
      "language": "JavaScript"
    },
    "d3.js": {
      "type": "application/javascript",
      "filename": "d3.js",
      "size": 93517,
      "raw_url": "https://gist.github.com/raw/1155488/f8350c76cfcfaf87dfef1ae46ee8a1420c99818f/d3.js",
      "content": "(function(){d3 = {version: \"1.27.2\"}; // semver\nif (!Date.now) Date.now = function() {\n  return +new Date;\n};\nif (!Object.create) Object.create = function(o) {\n  /** @constructor */ function f() {}\n  f.prototype = o;\n  return new f;\n};\nvar d3_array = d3_arraySlice; // conversion for NodeLists\n\nfunction d3_arrayCopy(psuedoarray) {\n  var i = -1, n = psuedoarray.length, array = [];\n  while (++i < n) array.push(psuedoarray[i]);\n  return array;\n}\n\nfunction d3_arraySlice(psuedoarray) {\n  return Array.prototype.slice.call(psuedoarray);\n}\n\ntry {\n  d3_array(document.documentElement.childNodes)[0].nodeType;\n} catch(e) {\n  d3_array = d3_arrayCopy;\n}\nd3.functor = function(v) {\n  return typeof v === \"function\" ? v : function() { return v; };\n};\n// A getter-setter method that preserves the appropriate `this` context.\nd3.rebind = function(object, method) {\n  return function() {\n    var x = method.apply(object, arguments);\n    return arguments.length ? object : x;\n  };\n};\nd3.ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n};\nd3.descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : 0;\n};\nd3.min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n  }\n  return a;\n};\nd3.max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n  if (arguments.length === 1) {\n    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  } else {\n    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n  }\n  return a;\n};\nd3.sum = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1;\n\n  if (arguments.length === 1) {\n    while (++i < n) if (!isNaN(a = +array[i])) s += a;\n  } else {\n    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\n  }\n\n  return s;\n};\n// R-7 per <http://en.wikipedia.org/wiki/Quantile>\nd3.quantile = function(values, p) {\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = values[h - 1],\n      e = H - h;\n  return e ? v + e * (values[h] - v) : v;\n};\nd3.zip = function() {\n  if (!(n = arguments.length)) return [];\n  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {\n    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {\n      zip[j] = arguments[j][i];\n    }\n  }\n  return zips;\n};\n\nfunction d3_zipLength(d) {\n  return d.length;\n}\n// Locate the insertion point for x in a to maintain sorted order. The\n// arguments lo and hi may be used to specify a subset of the array which should\n// be considered; by default the entire array is used. If x is already present\n// in a, the insertion point will be before (to the left of) any existing\n// entries. The return value is suitable for use as the first argument to\n// `array.splice` assuming that a is already sorted.\n//\n// The returned insertion point i partitions the array a into two halves so that\n// all v < x for v in a[lo:i] for the left side and all v >= x for v in a[i:hi]\n// for the right side.\nd3.bisectLeft = function(a, x, lo, hi) {\n  if (arguments.length < 3) lo = 0;\n  if (arguments.length < 4) hi = a.length;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n};\n\n// Similar to bisectLeft, but returns an insertion point which comes after (to\n// the right of) any existing entries of x in a.\n//\n// The returned insertion point i partitions the array into two halves so that\n// all v <= x for v in a[lo:i] for the left side and all v > x for v in a[i:hi]\n// for the right side.\nd3.bisect =\nd3.bisectRight = function(a, x, lo, hi) {\n  if (arguments.length < 3) lo = 0;\n  if (arguments.length < 4) hi = a.length;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (x < a[mid]) hi = mid;\n    else lo = mid + 1;\n  }\n  return lo;\n};\nd3.first = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) > 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.last = function(array, f) {\n  var i = 0,\n      n = array.length,\n      a = array[0],\n      b;\n  if (arguments.length === 1) f = d3.ascending;\n  while (++i < n) {\n    if (f.call(array, a, b = array[i]) <= 0) {\n      a = b;\n    }\n  }\n  return a;\n};\nd3.nest = function() {\n  var nest = {},\n      keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup;\n\n  function map(array, depth) {\n    if (depth >= keys.length) return rollup\n        ? rollup.call(nest, array) : (sortValues\n        ? array.sort(sortValues)\n        : array);\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        object,\n        o = {};\n\n    while (++i < n) {\n      if ((keyValue = key(object = array[i])) in o) {\n        o[keyValue].push(object);\n      } else {\n        o[keyValue] = [object];\n      }\n    }\n\n    for (keyValue in o) {\n      o[keyValue] = map(o[keyValue], depth);\n    }\n\n    return o;\n  }\n\n  function entries(map, depth) {\n    if (depth >= keys.length) return map;\n\n    var a = [],\n        sortKey = sortKeys[depth++],\n        key;\n\n    for (key in map) {\n      a.push({key: key, values: entries(map[key], depth)});\n    }\n\n    if (sortKey) a.sort(function(a, b) {\n      return sortKey(a.key, b.key);\n    });\n\n    return a;\n  }\n\n  nest.map = function(array) {\n    return map(array, 0);\n  };\n\n  nest.entries = function(array) {\n    return entries(map(array, 0), 0);\n  };\n\n  nest.key = function(d) {\n    keys.push(d);\n    return nest;\n  };\n\n  // Specifies the order for the most-recently specified key.\n  // Note: only applies to entries. Map keys are unordered!\n  nest.sortKeys = function(order) {\n    sortKeys[keys.length - 1] = order;\n    return nest;\n  };\n\n  // Specifies the order for leaf values.\n  // Applies to both maps and entries array.\n  nest.sortValues = function(order) {\n    sortValues = order;\n    return nest;\n  };\n\n  nest.rollup = function(f) {\n    rollup = f;\n    return nest;\n  };\n\n  return nest;\n};\nd3.keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\nd3.values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\nd3.entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\nd3.permute = function(array, indexes) {\n  var permutes = [],\n      i = -1,\n      n = indexes.length;\n  while (++i < n) permutes[i] = array[indexes[i]];\n  return permutes;\n};\nd3.merge = function(arrays) {\n  return Array.prototype.concat.apply([], arrays);\n};\nd3.split = function(array, f) {\n  var arrays = [],\n      values = [],\n      value,\n      i = -1,\n      n = array.length;\n  if (arguments.length < 2) f = d3_splitter;\n  while (++i < n) {\n    if (f.call(values, value = array[i], i)) {\n      values = [];\n    } else {\n      if (!values.length) arrays.push(values);\n      values.push(value);\n    }\n  }\n  return arrays;\n};\n\nfunction d3_splitter(d) {\n  return d == null;\n}\nfunction d3_collapse(s) {\n  return s.replace(/(^\\s+)|(\\s+$)/g, \"\").replace(/\\s+/g, \" \");\n}\n//\n// Note: assigning to the arguments array simultaneously changes the value of\n// the corresponding argument!\n//\n// TODO The `this` argument probably shouldn't be the first argument to the\n// callback, anyway, since it's redundant. However, that will require a major\n// version bump due to backwards compatibility, so I'm not changing it right\n// away.\n//\nfunction d3_call(callback) {\n  callback.apply(this, (arguments[0] = this, arguments));\n  return this;\n}\n/**\n * @param {number} start\n * @param {number=} stop\n * @param {number=} step\n */\nd3.range = function(start, stop, step) {\n  if (arguments.length === 1) { stop = start; start = 0; }\n  if (step == null) step = 1;\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       i = -1,\n       j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\nd3.requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\[\\]\\(\\)\\.\\{\\}]/g;\nd3.round = function(x, n) {\n  return n\n      ? Math.round(x * Math.pow(10, n)) * Math.pow(10, -n)\n      : Math.round(x);\n};\nd3.xhr = function(url, mime, callback) {\n  var req = new XMLHttpRequest;\n  if (arguments.length < 3) callback = mime;\n  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);\n  req.open(\"GET\", url, true);\n  req.onreadystatechange = function() {\n    if (req.readyState === 4) callback(req.status < 300 ? req : null);\n  };\n  req.send(null);\n};\nd3.text = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseText);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.json = function(url, callback) {\n  d3.text(url, \"application/json\", function(text) {\n    callback(text ? JSON.parse(text) : null);\n  });\n};\nd3.html = function(url, callback) {\n  d3.text(url, \"text/html\", function(text) {\n    if (text != null) { // Treat empty string as valid HTML.\n      var range = document.createRange();\n      range.selectNode(document.body);\n      text = range.createContextualFragment(text);\n    }\n    callback(text);\n  });\n};\nd3.xml = function(url, mime, callback) {\n  function ready(req) {\n    callback(req && req.responseXML);\n  }\n  if (arguments.length < 3) {\n    callback = mime;\n    mime = null;\n  }\n  d3.xhr(url, mime, ready);\n};\nd3.ns = {\n\n  prefix: {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: \"http://www.w3.org/1999/xhtml\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  },\n\n  qualify: function(name) {\n    var i = name.indexOf(\":\");\n    return i < 0 ? name : {\n      space: d3.ns.prefix[name.substring(0, i)],\n      local: name.substring(i + 1)\n    };\n  }\n\n};\n/** @param {...string} types */\nd3.dispatch = function(types) {\n  var dispatch = {},\n      type;\n  for (var i = 0, n = arguments.length; i < n; i++) {\n    type = arguments[i];\n    dispatch[type] = d3_dispatch(type);\n  }\n  return dispatch;\n};\n\nfunction d3_dispatch(type) {\n  var dispatch = {},\n      listeners = [];\n\n  dispatch.add = function(listener) {\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i].listener == listener) return dispatch; // already registered\n    }\n    listeners.push({listener: listener, on: true});\n    return dispatch;\n  };\n\n  dispatch.remove = function(listener) {\n    for (var i = 0; i < listeners.length; i++) {\n      var l = listeners[i];\n      if (l.listener == listener) {\n        l.on = false;\n        listeners = listeners.slice(0, i).concat(listeners.slice(i + 1));\n        break;\n      }\n    }\n    return dispatch;\n  };\n\n  dispatch.dispatch = function() {\n    var ls = listeners; // defensive reference\n    for (var i = 0, n = ls.length; i < n; i++) {\n      var l = ls[i];\n      if (l.on) l.listener.apply(this, arguments);\n    }\n  };\n\n  return dispatch;\n};\n// TODO align\nd3.format = function(specifier) {\n  var match = d3_format_re.exec(specifier),\n      fill = match[1] || \" \",\n      sign = match[3] || \"\",\n      zfill = match[5],\n      width = +match[6],\n      comma = match[7],\n      precision = match[8],\n      type = match[9],\n      percentage = false,\n      integer = false;\n\n  if (precision) precision = precision.substring(1);\n\n  if (zfill) {\n    fill = \"0\"; // TODO align = \"=\";\n    if (comma) width -= Math.floor((width - 1) / 4);\n  }\n\n  switch (type) {\n    case \"n\": comma = true; type = \"g\"; break;\n    case \"%\": percentage = true; type = \"f\"; break;\n    case \"p\": percentage = true; type = \"r\"; break;\n    case \"d\": integer = true; precision = \"0\"; break;\n  }\n\n  type = d3_format_types[type] || d3_format_typeDefault;\n\n  return function(value) {\n    var number = percentage ? value * 100 : +value,\n        negative = (number < 0) && (number = -number) ? \"\\u2212\" : sign;\n\n    // Return the empty string for floats formatted as ints.\n    if (integer && (number % 1)) return \"\";\n\n    // Convert the input value to the desired precision.\n    value = type(number, precision);\n\n    // If the fill character is 0, the sign and group is applied after the fill.\n    if (zfill) {\n      var length = value.length + negative.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n    }\n\n    // Otherwise (e.g., space-filling), the sign and group is applied before.\n    else {\n      if (comma) value = d3_format_group(value);\n      value = negative + value;\n      var length = value.length;\n      if (length < width) value = new Array(width - length + 1).join(fill) + value;\n    }\n    if (percentage) value += \"%\";\n\n    return value;\n  };\n};\n\n// [[fill]align][sign][#][0][width][,][.precision][type]\nvar d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n\nvar d3_format_types = {\n  g: function(x, p) { return x.toPrecision(p); },\n  e: function(x, p) { return x.toExponential(p); },\n  f: function(x, p) { return x.toFixed(p); },\n  r: function(x, p) {\n    var n = 1 + Math.floor(1e-15 + Math.log(x) / Math.LN10);\n    return d3.round(x, p - n).toFixed(Math.max(0, p - n));\n  }\n};\n\nfunction d3_format_typeDefault(x) {\n  return x + \"\";\n}\n\n// Apply comma grouping for thousands.\nfunction d3_format_group(value) {\n  var i = value.lastIndexOf(\".\"),\n      f = i >= 0 ? value.substring(i) : (i = value.length, \"\"),\n      t = [];\n  while (i > 0) t.push(value.substring(i -= 3, i + 3));\n  return t.reverse().join(\",\") + f;\n}\n/*\n * TERMS OF USE - EASING EQUATIONS\n *\n * Open source under the BSD License.\n *\n * Copyright 2001 Robert Penner\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of contributors may be used to\n *   endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar d3_ease_quad = d3_ease_poly(2),\n    d3_ease_cubic = d3_ease_poly(3);\n\nvar d3_ease = {\n  linear: function() { return d3_ease_linear; },\n  poly: d3_ease_poly,\n  quad: function() { return d3_ease_quad; },\n  cubic: function() { return d3_ease_cubic; },\n  sin: function() { return d3_ease_sin; },\n  exp: function() { return d3_ease_exp; },\n  circle: function() { return d3_ease_circle; },\n  elastic: d3_ease_elastic,\n  back: d3_ease_back,\n  bounce: function() { return d3_ease_bounce; }\n};\n\nvar d3_ease_mode = {\n  \"in\": function(f) { return f; },\n  \"out\": d3_ease_reverse,\n  \"in-out\": d3_ease_reflect,\n  \"out-in\": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }\n};\n\nd3.ease = function(name) {\n  var i = name.indexOf(\"-\"),\n      t = i >= 0 ? name.substring(0, i) : name,\n      m = i >= 0 ? name.substring(i + 1) : \"in\";\n  return d3_ease_mode[m](d3_ease[t].apply(null, Array.prototype.slice.call(arguments, 1)));\n};\n\nfunction d3_ease_reverse(f) {\n  return function(t) {\n    return 1 - f(1 - t);\n  };\n}\n\nfunction d3_ease_reflect(f) {\n  return function(t) {\n    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n  };\n}\n\nfunction d3_ease_linear(t) {\n  return t;\n}\n\nfunction d3_ease_poly(e) {\n  return function(t) {\n    return Math.pow(t, e);\n  }\n}\n\nfunction d3_ease_sin(t) {\n  return 1 - Math.cos(t * Math.PI / 2);\n}\n\nfunction d3_ease_exp(t) {\n  return t ? Math.pow(2, 10 * (t - 1)) - 1e-3 : 0;\n}\n\nfunction d3_ease_circle(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction d3_ease_elastic(a, p) {\n  var s;\n  if (arguments.length < 2) p = 0.45;\n  if (arguments.length < 1) { a = 1; s = p / 4; }\n  else s = p / (2 * Math.PI) * Math.asin(1 / a);\n  return function(t) {\n    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);\n  };\n}\n\nfunction d3_ease_back(s) {\n  if (!s) s = 1.70158;\n  return function(t) {\n    return t * t * ((s + 1) * t - s);\n  };\n}\n\nfunction d3_ease_bounce(t) {\n  return t < 1 / 2.75 ? 7.5625 * t * t\n      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75\n      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375\n      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n}\nd3.event = null;\nd3.interpolate = function(a, b) {\n  var i = d3.interpolators.length, f;\n  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n  return f;\n};\n\nd3.interpolateNumber = function(a, b) {\n  b -= a;\n  return function(t) { return a + b * t; };\n};\n\nd3.interpolateRound = function(a, b) {\n  b -= a;\n  return function(t) { return Math.round(a + b * t); };\n};\n\nd3.interpolateString = function(a, b) {\n  var m, // current match\n      i, // current index\n      j, // current index (for coallescing)\n      s0 = 0, // start index of current string prefix\n      s1 = 0, // end index of current string prefix\n      s = [], // string constants and placeholders\n      q = [], // number interpolators\n      n, // q.length\n      o;\n\n  // Reset our regular expression!\n  d3_interpolate_number.lastIndex = 0;\n\n  // Find all numbers in b.\n  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\n    if (m.index) s.push(b.substring(s0, s1 = m.index));\n    q.push({i: s.length, x: m[0]});\n    s.push(null);\n    s0 = d3_interpolate_number.lastIndex;\n  }\n  if (s0 < b.length) s.push(b.substring(s0));\n\n  // Find all numbers in a.\n  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\n    o = q[i];\n    if (o.x == m[0]) { // The numbers match, so coallesce.\n      if (o.i) {\n        if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i - 1] += o.x;\n          s.splice(o.i, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i - 1] += o.x + s[o.i + 1];\n          s.splice(o.i, 2);\n          for (j = i + 1; j < n; ++j) q[j].i -= 2;\n        }\n      } else {\n          if (s[o.i + 1] == null) { // This match is followed by another number.\n          s[o.i] = o.x;\n        } else { // This match is followed by a string, so coallesce twice.\n          s[o.i] = o.x + s[o.i + 1];\n          s.splice(o.i + 1, 1);\n          for (j = i + 1; j < n; ++j) q[j].i--;\n        }\n      }\n      q.splice(i, 1);\n      n--;\n      i--;\n    } else {\n      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n    }\n  }\n\n  // Remove any numbers in b not found in a.\n  while (i < n) {\n    o = q.pop();\n    if (s[o.i + 1] == null) { // This match is followed by another number.\n      s[o.i] = o.x;\n    } else { // This match is followed by a string, so coallesce twice.\n      s[o.i] = o.x + s[o.i + 1];\n      s.splice(o.i + 1, 1);\n    }\n    n--;\n  }\n\n  // Special optimization for only a single match.\n  if (s.length === 1) {\n    return s[0] == null ? q[0].x : function() { return b; };\n  }\n\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return function(t) {\n    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n    return s.join(\"\");\n  };\n};\n\nd3.interpolateRgb = function(a, b) {\n  a = d3.rgb(a);\n  b = d3.rgb(b);\n  var ar = a.r,\n      ag = a.g,\n      ab = a.b,\n      br = b.r - ar,\n      bg = b.g - ag,\n      bb = b.b - ab;\n  return function(t) {\n    return \"rgb(\" + Math.round(ar + br * t)\n        + \",\" + Math.round(ag + bg * t)\n        + \",\" + Math.round(ab + bb * t)\n        + \")\";\n  };\n};\n\n// interpolates HSL space, but outputs RGB string (for compatibility)\nd3.interpolateHsl = function(a, b) {\n  a = d3.hsl(a);\n  b = d3.hsl(b);\n  var h0 = a.h,\n      s0 = a.s,\n      l0 = a.l,\n      h1 = b.h - h0,\n      s1 = b.s - s0,\n      l1 = b.l - l0;\n  return function(t) {\n    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();\n  };\n};\n\nd3.interpolateArray = function(a, b) {\n  var x = [],\n      c = [],\n      na = a.length,\n      nb = b.length,\n      n0 = Math.min(a.length, b.length),\n      i;\n  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n  for (; i < na; ++i) c[i] = a[i];\n  for (; i < nb; ++i) c[i] = b[i];\n  return function(t) {\n    for (i = 0; i < n0; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nd3.interpolateObject = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n  for (k in a) {\n    if (k in b) {\n      i[k] = d3_interpolateByName(k)(a[k], b[k]);\n    } else {\n      c[k] = a[k];\n    }\n  }\n  for (k in b) {\n    if (!(k in a)) {\n      c[k] = b[k];\n    }\n  }\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n}\n\nvar d3_interpolate_number = /[-+]?(?:\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)(?:[eE][-]?\\d+)?/g,\n    d3_interpolate_rgb = {background: 1, fill: 1, stroke: 1};\n\nfunction d3_interpolateByName(n) {\n  return n in d3_interpolate_rgb || /\\bcolor\\b/.test(n)\n      ? d3.interpolateRgb\n      : d3.interpolate;\n}\n\nd3.interpolators = [\n  d3.interpolateObject,\n  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },\n  function(a, b) { return (typeof b === \"string\") && d3.interpolateString(String(a), b); },\n  function(a, b) { return (b in d3_rgb_names || /^(#|rgb\\(|hsl\\()/.test(b)) && d3.interpolateRgb(String(a), b); },\n  function(a, b) { return (typeof b === \"number\") && d3.interpolateNumber(+a, b); }\n];\nfunction d3_uninterpolateNumber(a, b) {\n  b = 1 / (b - (a = +a));\n  return function(x) { return (x - a) * b; };\n}\n\nfunction d3_uninterpolateClamp(a, b) {\n  b = 1 / (b - (a = +a));\n  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };\n}\nd3.rgb = function(r, g, b) {\n  return arguments.length === 1\n      ? d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb)\n      : d3_rgb(~~r, ~~g, ~~b);\n};\n\nfunction d3_rgb(r, g, b) {\n  return new d3_Rgb(r, g, b);\n}\n\nfunction d3_Rgb(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n}\n\nd3_Rgb.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  var r = this.r,\n      g = this.g,\n      b = this.b,\n      i = 30;\n  if (!r && !g && !b) return d3_rgb(i, i, i);\n  if (r && r < i) r = i;\n  if (g && g < i) g = i;\n  if (b && b < i) b = i;\n  return d3_rgb(\n    Math.min(255, Math.floor(r / k)),\n    Math.min(255, Math.floor(g / k)),\n    Math.min(255, Math.floor(b / k)));\n};\n\nd3_Rgb.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_rgb(\n    Math.max(0, Math.floor(k * this.r)),\n    Math.max(0, Math.floor(k * this.g)),\n    Math.max(0, Math.floor(k * this.b)));\n};\n\nd3_Rgb.prototype.hsl = function() {\n  return d3_rgb_hsl(this.r, this.g, this.b);\n};\n\nd3_Rgb.prototype.toString = function() {\n  return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n};\n\nfunction d3_rgb_hex(v) {\n  return v < 0x10 ? \"0\" + v.toString(16) : v.toString(16);\n}\n\nfunction d3_rgb_parse(format, rgb, hsl) {\n  var r = 0, // red channel; int in [0, 255]\n      g = 0, // green channel; int in [0, 255]\n      b = 0, // blue channel; int in [0, 255]\n      m1, // CSS color specification match\n      m2, // CSS color specification type (e.g., rgb)\n      name;\n\n  /* Handle hsl, rgb. */\n  m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n  if (m1) {\n    m2 = m1[2].split(\",\");\n    switch (m1[1]) {\n      case \"hsl\": {\n        return hsl(\n          parseFloat(m2[0]), // degrees\n          parseFloat(m2[1]) / 100, // percentage\n          parseFloat(m2[2]) / 100 // percentage\n        );\n      }\n      case \"rgb\": {\n        return rgb(\n          d3_rgb_parseNumber(m2[0]),\n          d3_rgb_parseNumber(m2[1]),\n          d3_rgb_parseNumber(m2[2])\n        );\n      }\n    }\n  }\n\n  /* Named colors. */\n  if (name = d3_rgb_names[format]) return rgb(name.r, name.g, name.b);\n\n  /* Hexadecimal colors: #rgb and #rrggbb. */\n  if (format != null && format.charAt(0) === \"#\") {\n    if (format.length === 4) {\n      r = format.charAt(1); r += r;\n      g = format.charAt(2); g += g;\n      b = format.charAt(3); b += b;\n    } else if (format.length === 7) {\n      r = format.substring(1, 3);\n      g = format.substring(3, 5);\n      b = format.substring(5, 7);\n    }\n    r = parseInt(r, 16);\n    g = parseInt(g, 16);\n    b = parseInt(b, 16);\n  }\n\n  return rgb(r, g, b);\n}\n\nfunction d3_rgb_hsl(r, g, b) {\n  var min = Math.min(r /= 255, g /= 255, b /= 255),\n      max = Math.max(r, g, b),\n      d = max - min,\n      h,\n      s,\n      l = (max + min) / 2;\n  if (d) {\n    s = l < .5 ? d / (max + min) : d / (2 - max - min);\n    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n    else if (g == max) h = (b - r) / d + 2;\n    else h = (r - g) / d + 4;\n    h *= 60;\n  } else {\n    s = h = 0;\n  }\n  return d3_hsl(h, s, l);\n}\n\nfunction d3_rgb_parseNumber(c) { // either integer or percentage\n  var f = parseFloat(c);\n  return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n}\n\nvar d3_rgb_names = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n};\n\nfor (var d3_rgb_name in d3_rgb_names) {\n  d3_rgb_names[d3_rgb_name] = d3_rgb_parse(\n      d3_rgb_names[d3_rgb_name],\n      d3_rgb,\n      d3_hsl_rgb);\n}\nd3.hsl = function(h, s, l) {\n  return arguments.length === 1\n      ? d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl)\n      : d3_hsl(+h, +s, +l);\n};\n\nfunction d3_hsl(h, s, l) {\n  return new d3_Hsl(h, s, l);\n}\n\nfunction d3_Hsl(h, s, l) {\n  this.h = h;\n  this.s = s;\n  this.l = l;\n}\n\nd3_Hsl.prototype.brighter = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, this.l / k);\n};\n\nd3_Hsl.prototype.darker = function(k) {\n  k = Math.pow(0.7, arguments.length ? k : 1);\n  return d3_hsl(this.h, this.s, k * this.l);\n};\n\nd3_Hsl.prototype.rgb = function() {\n  return d3_hsl_rgb(this.h, this.s, this.l);\n};\n\nd3_Hsl.prototype.toString = function() {\n  return \"hsl(\" + this.h + \",\" + this.s * 100 + \"%,\" + this.l * 100 + \"%)\";\n};\n\nfunction d3_hsl_rgb(h, s, l) {\n  var m1,\n      m2;\n\n  /* Some simple corrections for h, s and l. */\n  h = h % 360; if (h < 0) h += 360;\n  s = s < 0 ? 0 : s > 1 ? 1 : s;\n  l = l < 0 ? 0 : l > 1 ? 1 : l;\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n  m1 = 2 * l - m2;\n\n  function v(h) {\n    if (h > 360) h -= 360;\n    else if (h < 0) h += 360;\n    if (h < 60) return m1 + (m2 - m1) * h / 60;\n    if (h < 180) return m2;\n    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n    return m1;\n  }\n\n  function vv(h) {\n    return Math.round(v(h) * 255);\n  }\n\n  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n}\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return d3_array(n.querySelectorAll(s)); };\n\n// Use Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0]; };\n  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };\n}\n\nvar d3_root = d3_selection([[document]]);\nd3_root[0].parentNode = document.documentElement;\n\n// TODO fast singleton implementation!\nd3.select = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_root.select(selector)\n      : d3_selection([[selector]]); // assume node\n};\n\nd3.selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? d3_root.selectAll(selector)\n      : d3_selection([d3_array(selector)]); // assume node[]\n};\n\nfunction d3_selection(groups) {\n\n  function select(select) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        group,\n        node;\n    for (var j = 0, m = groups.length; j < m; j++) {\n      group = groups[j];\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          subgroup.push(subnode = select(node));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  }\n\n  function selectAll(selectAll) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    for (var j = 0, m = groups.length; j < m; j++) {\n      group = groups[j];\n      for (var i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = selectAll(node));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  }\n\n  // TODO select(function)?\n  groups.select = function(selector) {\n    return select(function(node) {\n      return d3_select(selector, node);\n    });\n  };\n\n  // TODO selectAll(function)?\n  groups.selectAll = function(selector) {\n    return selectAll(function(node) {\n      return d3_selectAll(selector, node);\n    });\n  };\n\n  // TODO preserve null elements to maintain index?\n  groups.filter = function(filter) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    for (var j = 0, m = groups.length; j < m; j++) {\n      group = groups[j];\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n\n  groups.map = function(map) {\n    var group,\n        node;\n    for (var j = 0, m = groups.length; j < m; j++) {\n      group = groups[j];\n      for (var i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) node.__data__ = map.call(node, node.__data__, i);\n      }\n    }\n    return groups;\n  };\n\n  // TODO data(null) for clearing data?\n  groups.data = function(data, join) {\n    var enter = [],\n        update = [],\n        exit = [];\n\n    function bind(group, groupData) {\n      var i = 0,\n          n = group.length,\n          m = groupData.length,\n          n0 = Math.min(n, m),\n          n1 = Math.max(n, m),\n          updateNodes = [],\n          enterNodes = [],\n          exitNodes = [],\n          node,\n          nodeData;\n\n      if (join) {\n        var nodeByKey = {},\n            keys = [],\n            key,\n            j = groupData.length;\n\n        for (i = 0; i < n; i++) {\n          key = join.call(node = group[i], node.__data__, i);\n          if (key in nodeByKey) {\n            exitNodes[j++] = node; // duplicate key\n          } else {\n            nodeByKey[key] = node;\n          }\n          keys.push(key);\n        }\n\n        for (i = 0; i < m; i++) {\n          node = nodeByKey[key = join.call(groupData, nodeData = groupData[i], i)];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n            enterNodes[i] = exitNodes[i] = null;\n          } else {\n            enterNodes[i] = d3_selection_enterNode(nodeData);\n            updateNodes[i] = exitNodes[i] = null;\n          }\n          delete nodeByKey[key];\n        }\n\n        for (i = 0; i < n; i++) {\n          if (keys[i] in nodeByKey) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (; i < n0; i++) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n            enterNodes[i] = exitNodes[i] = null;\n          } else {\n            enterNodes[i] = d3_selection_enterNode(nodeData);\n            updateNodes[i] = exitNodes[i] = null;\n          }\n        }\n        for (; i < m; i++) {\n          enterNodes[i] = d3_selection_enterNode(groupData[i]);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n        for (; i < n1; i++) {\n          exitNodes[i] = group[i];\n          enterNodes[i] = updateNodes[i] = null;\n        }\n      }\n\n      enterNodes.parentNode\n          = updateNodes.parentNode\n          = exitNodes.parentNode\n          = group.parentNode;\n\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n\n    var i = -1,\n        n = groups.length,\n        group;\n    if (typeof data === \"function\") {\n      while (++i < n) {\n        bind(group = groups[i], data.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = groups[i], data);\n      }\n    }\n\n    var selection = d3_selection(update);\n    selection.enter = function() {\n      return d3_selectionEnter(enter);\n    };\n    selection.exit = function() {\n      return d3_selection(exit);\n    };\n    return selection;\n  };\n\n  // TODO mask forEach? or rename for eachData?\n  // TODO offer the same semantics for map, reduce, etc.?\n  groups.each = function(callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      var group = groups[j];\n      for (var i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) callback.call(node, node.__data__, i);\n      }\n    }\n    return groups;\n  };\n\n  function first(callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      var group = groups[j];\n      for (var i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return callback.call(node, node.__data__, i);\n      }\n    }\n    return null;\n  }\n\n  groups.empty = function() {\n    return !first(function() { return true; });\n  };\n\n  groups.node = function() {\n    return first(function() { return this; });\n  };\n\n  groups.attr = function(name, value) {\n    name = d3.ns.qualify(name);\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 2) {\n      return first(name.local\n          ? function() { return this.getAttributeNS(name.space, name.local); }\n          : function() { return this.getAttribute(name); });\n    }\n\n    /** @this {Element} */\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n\n    /** @this {Element} */\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n\n    /** @this {Element} */\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n\n    /** @this {Element} */\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n\n    /** @this {Element} */\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name);\n      else this.setAttribute(name, x);\n    }\n\n    /** @this {Element} */\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local);\n      else this.setAttributeNS(name.space, name.local, x);\n    }\n\n    return groups.each(value == null\n        ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n        ? (name.local ? attrFunctionNS : attrFunction)\n        : (name.local ? attrConstantNS : attrConstant)));\n  };\n\n  groups.classed = function(name, value) {\n    var re = new RegExp(\"(^|\\\\s+)\" + d3.requote(name) + \"(\\\\s+|$)\", \"g\");\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 2) {\n      return first(function() {\n        if (c = this.classList) return c.contains(name);\n        var c = this.className;\n        re.lastIndex = 0;\n        return re.test(c.baseVal != null ? c.baseVal : c);\n      });\n    }\n\n    /** @this {Element} */\n    function classedAdd() {\n      if (c = this.classList) return c.add(name);\n      var c = this.className,\n          cb = c.baseVal != null,\n          cv = cb ? c.baseVal : c;\n      re.lastIndex = 0;\n      if (!re.test(cv)) {\n        cv = d3_collapse(cv + \" \" + name);\n        if (cb) c.baseVal = cv;\n        else this.className = cv;\n      }\n    }\n\n    /** @this {Element} */\n    function classedRemove() {\n      if (c = this.classList) return c.remove(name);\n      var c = this.className,\n          cb = c.baseVal != null,\n          cv = cb ? c.baseVal : c;\n      cv = d3_collapse(cv.replace(re, \" \"));\n      if (cb) c.baseVal = cv;\n      else this.className = cv;\n    }\n\n    /** @this {Element} */\n    function classedFunction() {\n      (value.apply(this, arguments)\n          ? classedAdd\n          : classedRemove).call(this);\n    }\n\n    return groups.each(typeof value === \"function\"\n        ? classedFunction : value\n        ? classedAdd\n        : classedRemove);\n  };\n\n  groups.style = function(name, value, priority) {\n    if (arguments.length < 3) priority = \"\";\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 2) {\n      return first(function() {\n        return window.getComputedStyle(this, null).getPropertyValue(name);\n      });\n    }\n\n    /** @this {Element} */\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n\n    /** @this {Element} */\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n\n    /** @this {Element} */\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name);\n      else this.style.setProperty(name, x, priority);\n    }\n\n    return groups.each(value == null\n        ? styleNull : (typeof value === \"function\"\n        ? styleFunction : styleConstant));\n  };\n\n  groups.property = function(name, value) {\n    name = d3.ns.qualify(name);\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 2) {\n      return first(function() {\n        return this[name];\n      });\n    }\n\n    /** @this {Element} */\n    function propertyNull() {\n      delete this[name];\n    }\n\n    /** @this {Element} */\n    function propertyConstant() {\n      this[name] = value;\n    }\n\n    /** @this {Element} */\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name];\n      else this[name] = x;\n    }\n\n    return groups.each(value == null\n        ? propertyNull : (typeof value === \"function\"\n        ? propertyFunction : propertyConstant));\n  };\n\n  groups.text = function(value) {\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 1) {\n      return first(function() {\n        return this.textContent;\n      });\n    }\n\n    /** @this {Element} */\n    function textConstant() {\n      this.textContent = value;\n    }\n\n    /** @this {Element} */\n    function textFunction() {\n      this.textContent = value.apply(this, arguments);\n    }\n\n    return groups.each(typeof value === \"function\"\n        ? textFunction : textConstant);\n  };\n\n  groups.html = function(value) {\n\n    // If no value is specified, return the first value.\n    if (arguments.length < 1) {\n      return first(function() {\n        return this.innerHTML;\n      });\n    }\n\n    /** @this {Element} */\n    function htmlConstant() {\n      this.innerHTML = value;\n    }\n\n    /** @this {Element} */\n    function htmlFunction() {\n      this.innerHTML = value.apply(this, arguments);\n    }\n\n    return groups.each(typeof value === \"function\"\n        ? htmlFunction : htmlConstant);\n  };\n\n  // TODO append(node)?\n  // TODO append(function)?\n  groups.append = function(name) {\n    name = d3.ns.qualify(name);\n\n    function append(node) {\n      return node.appendChild(document.createElement(name));\n    }\n\n    function appendNS(node) {\n      return node.appendChild(document.createElementNS(name.space, name.local));\n    }\n\n    return select(name.local ? appendNS : append);\n  };\n\n  // TODO insert(node, function)?\n  // TODO insert(function, string)?\n  // TODO insert(function, function)?\n  groups.insert = function(name, before) {\n    name = d3.ns.qualify(name);\n\n    function insert(node) {\n      return node.insertBefore(\n          document.createElement(name),\n          d3_select(before, node));\n    }\n\n    function insertNS(node) {\n      return node.insertBefore(\n          document.createElementNS(name.space, name.local),\n          d3_select(before, node));\n    }\n\n    return select(name.local ? insertNS : insert);\n  };\n\n  // TODO remove(selector)?\n  // TODO remove(node)?\n  // TODO remove(function)?\n  groups.remove = function() {\n    return groups.each(function() {\n      var parent = this.parentNode;\n      if (parent) parent.removeChild(this);\n    });\n  };\n\n  groups.sort = function(comparator) {\n    comparator = d3_selection_comparator.apply(this, arguments);\n    for (var j = 0, m = groups.length; j < m; j++) {\n      var group = groups[j];\n      group.sort(comparator);\n      for (var i = 1, n = group.length, prev = group[0]; i < n; i++) {\n        var node = group[i];\n        if (node) {\n          if (prev) prev.parentNode.insertBefore(node, prev.nextSibling);\n          prev = node;\n        }\n      }\n    }\n    return groups;\n  };\n\n  // type can be namespaced, e.g., \"click.foo\"\n  // listener can be null for removal\n  groups.on = function(type, listener, capture) {\n    if (arguments.length < 3) capture = false;\n\n    // parse the type specifier\n    var i = type.indexOf(\".\"),\n        typo = i === -1 ? type : type.substring(0, i),\n        name = \"__on\" + type;\n\n    // remove the old event listener, and add the new event listener\n    return groups.each(function(d, i) {\n      if (this[name]) this.removeEventListener(typo, this[name], capture);\n      if (listener) this.addEventListener(typo, this[name] = l, capture);\n\n      // wrapped event listener that preserves i\n      var node = this;\n      function l(e) {\n        var o = d3.event; // Events can be reentrant (e.g., focus).\n        d3.event = e;\n        try {\n          listener.call(this, node.__data__, i);\n        } finally {\n          d3.event = o;\n        }\n      }\n    });\n  };\n\n  // TODO slice?\n\n  groups.transition = function() {\n    return d3_transition(groups);\n  };\n\n  groups.call = d3_call;\n\n  return groups;\n}\n\nfunction d3_selectionEnter(groups) {\n\n  function select(select) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        group,\n        node;\n    for (var j = 0, m = groups.length; j < m; j++) {\n      group = groups[j];\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          subgroup.push(subnode = select(group.parentNode));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  }\n\n  // TODO append(node)?\n  // TODO append(function)?\n  groups.append = function(name) {\n    name = d3.ns.qualify(name);\n\n    function append(node) {\n      return node.appendChild(document.createElement(name));\n    }\n\n    function appendNS(node) {\n      return node.appendChild(document.createElementNS(name.space, name.local));\n    }\n\n    return select(name.local ? appendNS : append);\n  };\n\n  // TODO insert(node, function)?\n  // TODO insert(function, string)?\n  // TODO insert(function, function)?\n  groups.insert = function(name, before) {\n    name = d3.ns.qualify(name);\n\n    function insert(node) {\n      return node.insertBefore(\n          document.createElement(name),\n          d3_select(before, node));\n    }\n\n    function insertNS(node) {\n      return node.insertBefore(\n          document.createElementNS(name.space, name.local),\n          d3_select(before, node));\n    }\n\n    return select(name.local ? insertNS : insert);\n  };\n\n  return groups;\n}\n\nfunction d3_selection_comparator(comparator) {\n  if (!arguments.length) comparator = d3.ascending;\n  return function(a, b) {\n    return comparator(a && a.__data__, b && b.__data__);\n  };\n}\n\nfunction d3_selection_enterNode(data) {\n  return {__data__: data};\n}\nd3.transition = d3_root.transition;\n\nvar d3_transitionId = 0,\n    d3_transitionInheritId = 0;\n\nfunction d3_transition(groups) {\n  var transition = {},\n      transitionId = d3_transitionInheritId || ++d3_transitionId,\n      tweens = {},\n      interpolators = [],\n      remove = false,\n      event = d3.dispatch(\"start\", \"end\"),\n      stage = [],\n      delay = [],\n      duration = [],\n      durationMax,\n      ease = d3.ease(\"cubic-in-out\");\n\n  //\n  // Be careful with concurrent transitions!\n  //\n  // Say transition A causes an exit. Before A finishes, a transition B is\n  // created, and believes it only needs to do an update, because the elements\n  // haven't been removed yet (which happens at the very end of the exit\n  // transition).\n  //\n  // Even worse, what if either transition A or B has a staggered delay? Then,\n  // some elements may be removed, while others remain. Transition B does not\n  // know to enter the elements because they were still present at the time\n  // the transition B was created (but not yet started).\n  //\n  // To prevent such confusion, we only trigger end events for transitions if\n  // the transition ending is the only one scheduled for the given element.\n  // Similarly, we only allow one transition to be active for any given\n  // element, so that concurrent transitions do not overwrite each other's\n  // properties.\n  //\n  // TODO Support transition namespaces, so that transitions can proceed\n  // concurrently on the same element if needed. Hopefully, this is rare!\n  //\n\n  groups.each(function() {\n    (this.__transition__ || (this.__transition__ = {})).owner = transitionId;\n  });\n\n  function step(elapsed) {\n    var clear = true,\n        k = -1;\n    groups.each(function() {\n      if (stage[++k] === 2) return; // ended\n      var t = (elapsed - delay[k]) / duration[k],\n          tx = this.__transition__,\n          te, // ease(t)\n          tk, // tween key\n          ik = interpolators[k];\n\n      // Check if the (un-eased) time is outside the range [0,1].\n      if (t < 1) {\n        clear = false;\n        if (t < 0) return;\n      } else {\n        t = 1;\n      }\n\n      // Determine the stage of this transition.\n      // 0 - Not yet started.\n      // 1 - In progress.\n      // 2 - Ended.\n      if (stage[k]) {\n        if (!tx || tx.active !== transitionId) {\n          stage[k] = 2;\n          return;\n        }\n      } else if (!tx || tx.active > transitionId) {\n        stage[k] = 2;\n        return;\n      } else {\n        stage[k] = 1;\n        event.start.dispatch.apply(this, arguments);\n        ik = interpolators[k] = {};\n        tx.active = transitionId;\n        for (tk in tweens) {\n          if (te = tweens[tk].apply(this, arguments)) {\n            ik[tk] = te;\n          }\n        }\n      }\n\n      // Apply the interpolators!\n      te = ease(t);\n      for (tk in ik) ik[tk].call(this, te);\n\n      // Handle ending transitions.\n      if (t === 1) {\n        stage[k] = 2;\n        if (tx.active === transitionId) {\n          var owner = tx.owner;\n          if (owner === transitionId) {\n            delete this.__transition__;\n            if (remove && this.parentNode) this.parentNode.removeChild(this);\n          }\n          d3_transitionInheritId = transitionId;\n          event.end.dispatch.apply(this, arguments);\n          d3_transitionInheritId = 0;\n          tx.owner = owner;\n        }\n      }\n    });\n    return clear;\n  }\n\n  transition.delay = function(value) {\n    var delayMin = Infinity,\n        k = -1;\n    if (typeof value === \"function\") {\n      groups.each(function(d, i) {\n        var x = delay[++k] = +value.apply(this, arguments);\n        if (x < delayMin) delayMin = x;\n      });\n    } else {\n      delayMin = +value;\n      groups.each(function(d, i) {\n        delay[++k] = delayMin;\n      });\n    }\n    d3_timer(step, delayMin);\n    return transition;\n  };\n\n  transition.duration = function(value) {\n    var k = -1;\n    if (typeof value === \"function\") {\n      durationMax = 0;\n      groups.each(function(d, i) {\n        var x = duration[++k] = +value.apply(this, arguments);\n        if (x > durationMax) durationMax = x;\n      });\n    } else {\n      durationMax = +value;\n      groups.each(function(d, i) {\n        duration[++k] = durationMax;\n      });\n    }\n    return transition;\n  };\n\n  transition.ease = function(value) {\n    ease = typeof value === \"function\" ? value : d3.ease.apply(d3, arguments);\n    return transition;\n  };\n\n  transition.attrTween = function(name, tween) {\n\n    /** @this {Element} */\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n\n    /** @this {Element} */\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n\n    tweens[\"attr.\" + name] = name.local ? attrTweenNS : attrTween;\n    return transition;\n  };\n\n  transition.attr = function(name, value) {\n    return transition.attrTween(name, d3_transitionTween(value));\n  };\n\n  transition.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = null;\n\n    /** @this {Element} */\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n\n    tweens[\"style.\" + name] = styleTween;\n    return transition;\n  };\n\n  transition.style = function(name, value, priority) {\n    if (arguments.length < 3) priority = null;\n    return transition.styleTween(name, d3_transitionTween(value), priority);\n  };\n\n  transition.text = function(value) {\n    tweens.text = function(d, i) {\n      this.textContent = typeof value === \"function\"\n          ? value.call(this, d, i)\n          : value;\n    };\n    return transition;\n  };\n\n  transition.select = function(query) {\n    var k, t = d3_transition(groups.select(query)).ease(ease);\n    k = -1; t.delay(function(d, i) { return delay[++k]; });\n    k = -1; t.duration(function(d, i) { return duration[++k]; });\n    return t;\n  };\n\n  transition.selectAll = function(query) {\n    var k, t = d3_transition(groups.selectAll(query)).ease(ease);\n    k = -1; t.delay(function(d, i) { return delay[i ? k : ++k]; })\n    k = -1; t.duration(function(d, i) { return duration[i ? k : ++k]; });\n    return t;\n  };\n\n  transition.remove = function() {\n    remove = true;\n    return transition;\n  };\n\n  transition.each = function(type, listener) {\n    event[type].add(listener);\n    return transition;\n  };\n\n  transition.call = d3_call;\n\n  return transition.delay(0).duration(250);\n}\n\nfunction d3_transitionTween(b) {\n  return typeof b === \"function\"\n      ? function(d, i, a) { var v = b.call(this, d, i) + \"\"; return a != v && d3.interpolate(a, v); }\n      : (b = b + \"\", function(d, i, a) { return a != b && d3.interpolate(a, b); });\n}\nvar d3_timer_queue = null,\n    d3_timer_interval, // is an interval (or frame) active?\n    d3_timer_timeout; // is a timeout active?\n\n// The timer will continue to fire until callback returns true.\nd3.timer = function(callback) {\n  d3_timer(callback, 0);\n};\n\nfunction d3_timer(callback, delay) {\n  var now = Date.now(),\n      found = false,\n      t0,\n      t1 = d3_timer_queue;\n\n  if (!isFinite(delay)) return;\n\n  // See if the callback's already in the queue.\n  while (t1) {\n    if (t1.callback === callback) {\n      t1.then = now;\n      t1.delay = delay;\n      found = true;\n      break;\n    }\n    t0 = t1;\n    t1 = t1.next;\n  }\n\n  // Otherwise, add the callback to the queue.\n  if (!found) d3_timer_queue = {\n    callback: callback,\n    then: now,\n    delay: delay,\n    next: d3_timer_queue\n  };\n\n  // Start animatin'!\n  if (!d3_timer_interval) {\n    d3_timer_timeout = clearTimeout(d3_timer_timeout);\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nfunction d3_timer_step() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (elapsed > t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  var delay = d3_timer_flush() - now;\n  if (delay > 24) {\n    if (isFinite(delay)) {\n      clearTimeout(d3_timer_timeout);\n      d3_timer_timeout = setTimeout(d3_timer_step, delay);\n    }\n    d3_timer_interval = 0;\n  } else {\n    d3_timer_interval = 1;\n    d3_timer_frame(d3_timer_step);\n  }\n}\n\nd3.timer.flush = function() {\n  var elapsed,\n      now = Date.now(),\n      t1 = d3_timer_queue;\n\n  while (t1) {\n    elapsed = now - t1.then;\n    if (!t1.delay) t1.flush = t1.callback(elapsed);\n    t1 = t1.next;\n  }\n\n  d3_timer_flush();\n};\n\n// Flush after callbacks, to avoid concurrent queue modification.\nfunction d3_timer_flush() {\n  var t0 = null,\n      t1 = d3_timer_queue,\n      then = Infinity;\n  while (t1) {\n    if (t1.flush) {\n      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\n    } else {\n      then = Math.min(then, t1.then + t1.delay);\n      t1 = (t0 = t1).next;\n    }\n  }\n  return then;\n}\n\nvar d3_timer_frame = window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.oRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || function(callback) { setTimeout(callback, 17); };\nd3.scale = {};\n\nfunction d3_scaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\nfunction d3_scale_nice(domain, nice) {\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      dx;\n\n  if (x1 < x0) {\n    dx = i0; i0 = i1; i1 = dx;\n    dx = x0; x0 = x1; x1 = dx;\n  }\n\n  nice = nice(x1 - x0);\n  domain[i0] = nice.floor(x0);\n  domain[i1] = nice.ceil(x1);\n  return domain;\n}\n\nfunction d3_scale_niceDefault() {\n  return Math;\n}\nd3.scale.linear = function() {\n  var domain = [0, 1],\n      range = [0, 1],\n      interpolate = d3.interpolate,\n      clamp = false,\n      output,\n      input;\n\n  function rescale() {\n    var linear = domain.length == 2 ? d3_scale_bilinear : d3_scale_polylinear,\n        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n    output = linear(domain, range, uninterpolate, interpolate);\n    input = linear(range, domain, uninterpolate, d3.interpolate);\n    return scale;\n  }\n\n  function scale(x) {\n    return output(x);\n  }\n\n  // Note: requires range is coercible to number!\n  scale.invert = function(y) {\n    return input(y);\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.map(Number);\n    return rescale();\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return rescale();\n  };\n\n  scale.rangeRound = function(x) {\n    return scale.range(x).interpolate(d3.interpolateRound);\n  };\n\n  scale.clamp = function(x) {\n    if (!arguments.length) return clamp;\n    clamp = x;\n    return rescale();\n  };\n\n  scale.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolate = x;\n    return rescale();\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(domain, m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(domain, m);\n  };\n\n  scale.nice = function() {\n    d3_scale_nice(domain, d3_scale_linearNice);\n    return rescale();\n  };\n\n  return rescale();\n};\n\nfunction d3_scale_linearRebind(scale, linear) {\n  scale.range = d3.rebind(scale, linear.range);\n  scale.rangeRound = d3.rebind(scale, linear.rangeRound);\n  scale.interpolate = d3.rebind(scale, linear.interpolate);\n  scale.clamp = d3.rebind(scale, linear.clamp);\n  return scale;\n};\n\nfunction d3_scale_linearNice(dx) {\n  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n  return {\n    floor: function(x) { return Math.floor(x / dx) * dx; },\n    ceil: function(x) { return Math.ceil(x / dx) * dx; }\n  };\n}\n\n// TODO Dates? Ugh.\nfunction d3_scale_linearTickRange(domain, m) {\n  var extent = d3_scaleExtent(domain),\n      span = extent[1] - extent[0],\n      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n      err = m / span * step;\n\n  // Filter ticks to get closer to the desired count.\n  if (err <= .15) step *= 10;\n  else if (err <= .35) step *= 5;\n  else if (err <= .75) step *= 2;\n\n  // Round start and stop values to step interval.\n  extent[0] = Math.ceil(extent[0] / step) * step;\n  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive\n  extent[2] = step;\n  return extent;\n}\n\nfunction d3_scale_linearTicks(domain, m) {\n  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n}\n\nfunction d3_scale_linearTickFormat(domain, m) {\n  return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\n}\nfunction d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n  var u = uninterpolate(domain[0], domain[1]),\n      i = interpolate(range[0], range[1]);\n  return function(x) {\n    return i(u(x));\n  };\n}\nfunction d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n  var u = [],\n      i = [],\n      j = 0,\n      n = domain.length;\n\n  while (++j < n) {\n    u.push(uninterpolate(domain[j - 1], domain[j]));\n    i.push(interpolate(range[j - 1], range[j]));\n  }\n\n  return function(x) {\n    var j = d3.bisect(domain, x, 1, domain.length - 1) - 1;\n    return i[j](u[j](x));\n  };\n}\nd3.scale.log = function() {\n  var linear = d3.scale.linear(),\n      log = d3_scale_log,\n      pow = log.pow;\n\n  function scale(x) {\n    return linear(log(x));\n  }\n\n  scale.invert = function(x) {\n    return pow(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(pow);\n    log = x[0] < 0 ? d3_scale_logn : d3_scale_log;\n    pow = log.pow;\n    linear.domain(x.map(log));\n    return scale;\n  };\n\n  scale.nice = function() {\n    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n    return scale;\n  };\n\n  scale.ticks = function() {\n    var extent = d3_scaleExtent(linear.domain()),\n        ticks = [];\n    if (extent.every(isFinite)) {\n      var i = Math.floor(extent[0]),\n          j = Math.ceil(extent[1]),\n          u = pow(extent[0]),\n          v = pow(extent[1]);\n      if (log === d3_scale_logn) {\n        ticks.push(pow(i));\n        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n      } else {\n        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n        ticks.push(pow(i));\n      }\n      for (i = 0; ticks[i] < u; i++) {} // strip small values\n      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values\n      ticks = ticks.slice(i, j);\n    }\n    return ticks;\n  };\n\n  scale.tickFormat = function() {\n    return d3_scale_logTickFormat;\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n};\n\nfunction d3_scale_log(x) {\n  return Math.log(x) / Math.LN10;\n}\n\nfunction d3_scale_logn(x) {\n  return -Math.log(-x) / Math.LN10;\n}\n\nd3_scale_log.pow = function(x) {\n  return Math.pow(10, x);\n};\n\nd3_scale_logn.pow = function(x) {\n  return -Math.pow(10, -x);\n};\n\nfunction d3_scale_logTickFormat(d) {\n  return d.toPrecision(1);\n}\nd3.scale.pow = function() {\n  var linear = d3.scale.linear(),\n      exponent = 1,\n      powp = Number,\n      powb = powp;\n\n  function scale(x) {\n    return linear(powp(x));\n  }\n\n  scale.invert = function(x) {\n    return powb(linear.invert(x));\n  };\n\n  scale.domain = function(x) {\n    if (!arguments.length) return linear.domain().map(powb);\n    var pow = (x[0] || x[x.length - 1]) < 0 ? d3_scale_pown : d3_scale_pow;\n    powp = pow(exponent);\n    powb = pow(1 / exponent);\n    linear.domain(x.map(powp));\n    return scale;\n  };\n\n  scale.ticks = function(m) {\n    return d3_scale_linearTicks(scale.domain(), m);\n  };\n\n  scale.tickFormat = function(m) {\n    return d3_scale_linearTickFormat(scale.domain(), m);\n  };\n\n  scale.nice = function() {\n    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n  };\n\n  scale.exponent = function(x) {\n    if (!arguments.length) return exponent;\n    var domain = scale.domain();\n    exponent = x;\n    return scale.domain(domain);\n  };\n\n  return d3_scale_linearRebind(scale, linear);\n};\n\nfunction d3_scale_pow(e) {\n  return function(x) {\n    return Math.pow(x, e);\n  };\n}\n\nfunction d3_scale_pown(e) {\n  return function(x) {\n    return -Math.pow(-x, e);\n  };\n}\nd3.scale.sqrt = function() {\n  return d3.scale.pow().exponent(.5);\n};\nd3.scale.ordinal = function() {\n  var domain = [],\n      index = {},\n      range = [],\n      rangeBand = 0;\n\n  function scale(x) {\n    var i = x in index ? index[x] : (index[x] = domain.push(x) - 1);\n    return range[i % range.length];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x;\n    index = {};\n    var i = -1, j = -1, n = domain.length; while (++i < n) {\n      x = domain[i];\n      if (!(x in index)) index[x] = ++j;\n    }\n    return scale;\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    return scale;\n  };\n\n  scale.rangePoints = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (domain.length - 1 + padding);\n    range = domain.length == 1\n        ? [(start + stop) / 2]\n        : d3.range(start + step * padding / 2, stop + step / 2, step);\n    rangeBand = 0;\n    return scale;\n  };\n\n  scale.rangeBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        step = (stop - start) / (domain.length + padding);\n    range = d3.range(start + step * padding, stop, step);\n    rangeBand = step * (1 - padding);\n    return scale;\n  };\n\n  scale.rangeRoundBands = function(x, padding) {\n    if (arguments.length < 2) padding = 0;\n    var start = x[0],\n        stop = x[1],\n        diff = stop - start,\n        step = Math.floor(diff / (domain.length + padding)),\n        err = diff - (domain.length - padding) * step;\n    range = d3.range(start + Math.round(err / 2), stop, step);\n    rangeBand = Math.round(step * (1 - padding));\n    return scale;\n  };\n\n  scale.rangeBand = function() {\n    return rangeBand;\n  };\n\n  return scale;\n};\n/*\n * This product includes color specifications and designs developed by Cynthia\n * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.\n */\n\nd3.scale.category10 = function() {\n  return d3.scale.ordinal().range(d3_category10);\n};\n\nd3.scale.category20 = function() {\n  return d3.scale.ordinal().range(d3_category20);\n};\n\nd3.scale.category20b = function() {\n  return d3.scale.ordinal().range(d3_category20b);\n};\n\nd3.scale.category20c = function() {\n  return d3.scale.ordinal().range(d3_category20c);\n};\n\nvar d3_category10 = [\n  \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n  \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"\n];\n\nvar d3_category20 = [\n  \"#1f77b4\", \"#aec7e8\",\n  \"#ff7f0e\", \"#ffbb78\",\n  \"#2ca02c\", \"#98df8a\",\n  \"#d62728\", \"#ff9896\",\n  \"#9467bd\", \"#c5b0d5\",\n  \"#8c564b\", \"#c49c94\",\n  \"#e377c2\", \"#f7b6d2\",\n  \"#7f7f7f\", \"#c7c7c7\",\n  \"#bcbd22\", \"#dbdb8d\",\n  \"#17becf\", \"#9edae5\"\n];\n\nvar d3_category20b = [\n  \"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\",\n  \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\",\n  \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\",\n  \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\",\n  \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\"\n];\n\nvar d3_category20c = [\n  \"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\",\n  \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\",\n  \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\",\n  \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\",\n  \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\"\n];\nd3.scale.quantile = function() {\n  var domain = [],\n      range = [],\n      thresholds = [];\n\n  function rescale() {\n    var k = 0,\n        n = domain.length,\n        q = range.length;\n    thresholds.length = Math.max(0, q - 1);\n    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n  }\n\n  function scale(x) {\n    if (isNaN(x = +x)) return NaN;\n    return range[d3.bisect(thresholds, x)];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return domain;\n    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);\n    rescale();\n    return scale;\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    rescale();\n    return scale;\n  };\n\n  scale.quantiles = function() {\n    return thresholds;\n  };\n\n  return scale;\n};\nd3.scale.quantize = function() {\n  var x0 = 0,\n      x1 = 1,\n      kx = 2,\n      i = 1,\n      range = [0, 1];\n\n  function scale(x) {\n    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n  }\n\n  scale.domain = function(x) {\n    if (!arguments.length) return [x0, x1];\n    x0 = x[0];\n    x1 = x[1];\n    kx = range.length / (x1 - x0);\n    return scale;\n  };\n\n  scale.range = function(x) {\n    if (!arguments.length) return range;\n    range = x;\n    kx = range.length / (x1 - x0);\n    i = range.length - 1;\n    return scale;\n  };\n\n  return scale;\n};\nd3.svg = {};\nd3.svg.arc = function() {\n  var innerRadius = d3_svg_arcInnerRadius,\n      outerRadius = d3_svg_arcOuterRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  function arc() {\n    var r0 = innerRadius.apply(this, arguments),\n        r1 = outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n        da = a1 - a0,\n        df = da < Math.PI ? \"0\" : \"1\",\n        c0 = Math.cos(a0),\n        s0 = Math.sin(a0),\n        c1 = Math.cos(a1),\n        s1 = Math.sin(a1);\n    return da >= d3_svg_arcMax\n      ? (r0\n      ? \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"M0,\" + r0\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,1 0,\" + (-r0)\n      + \"A\" + r0 + \",\" + r0 + \" 0 1,1 0,\" + r0\n      + \"Z\"\n      : \"M0,\" + r1\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + (-r1)\n      + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1\n      + \"Z\")\n      : (r0\n      ? \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L\" + r0 * c1 + \",\" + r0 * s1\n      + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0\n      + \"Z\"\n      : \"M\" + r1 * c0 + \",\" + r1 * s0\n      + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1\n      + \"L0,0\"\n      + \"Z\");\n  }\n\n  arc.innerRadius = function(v) {\n    if (!arguments.length) return innerRadius;\n    innerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.outerRadius = function(v) {\n    if (!arguments.length) return outerRadius;\n    outerRadius = d3.functor(v);\n    return arc;\n  };\n\n  arc.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return arc;\n  };\n\n  arc.centroid = function() {\n    var r = (innerRadius.apply(this, arguments)\n        + outerRadius.apply(this, arguments)) / 2,\n        a = (startAngle.apply(this, arguments)\n        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\n    return [Math.cos(a) * r, Math.sin(a) * r];\n  };\n\n  return arc;\n};\n\nvar d3_svg_arcOffset = -Math.PI / 2,\n    d3_svg_arcMax = 2 * Math.PI - 1e-6;\n\nfunction d3_svg_arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction d3_svg_arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction d3_svg_arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction d3_svg_line(projection) {\n  var x = d3_svg_lineX,\n      y = d3_svg_lineY,\n      interpolate = \"linear\",\n      interpolator = d3_svg_lineInterpolators[interpolate],\n      tension = .7;\n\n  function line(d) {\n    return d.length < 1 ? null : \"M\" + interpolator(projection(d3_svg_linePoints(this, d, x, y)), tension);\n  }\n\n  line.x = function(v) {\n    if (!arguments.length) return x;\n    x = v;\n    return line;\n  };\n\n  line.y = function(v) {\n    if (!arguments.length) return y;\n    y = v;\n    return line;\n  };\n\n  line.interpolate = function(v) {\n    if (!arguments.length) return interpolate;\n    interpolator = d3_svg_lineInterpolators[interpolate = v];\n    return line;\n  };\n\n  line.tension = function(v) {\n    if (!arguments.length) return tension;\n    tension = v;\n    return line;\n  };\n\n  return line;\n}\n\nd3.svg.line = function() {\n  return d3_svg_line(Object);\n};\n\n// Converts the specified array of data into an array of points\n// (x-y tuples), by evaluating the specified `x` and `y` functions on each\n// data point. The `this` context of the evaluated functions is the specified\n// \"self\" object; each function is passed the current datum and index.\nfunction d3_svg_linePoints(self, d, x, y) {\n  var points = [],\n      i = -1,\n      n = d.length,\n      fx = typeof x === \"function\",\n      fy = typeof y === \"function\",\n      value;\n  if (fx && fy) {\n    while (++i < n) points.push([\n      x.call(self, value = d[i], i),\n      y.call(self, value, i)\n    ]);\n  } else if (fx) {\n    while (++i < n) points.push([x.call(self, d[i], i), y]);\n  } else if (fy) {\n    while (++i < n) points.push([x, y.call(self, d[i], i)]);\n  } else {\n    while (++i < n) points.push([x, y]);\n  }\n  return points;\n}\n\n// The default `x` property, which references d[0].\nfunction d3_svg_lineX(d) {\n  return d[0];\n}\n\n// The default `y` property, which references d[1].\nfunction d3_svg_lineY(d) {\n  return d[1];\n}\n\n// The various interpolators supported by the `line` class.\nvar d3_svg_lineInterpolators = {\n  \"linear\": d3_svg_lineLinear,\n  \"step-before\": d3_svg_lineStepBefore,\n  \"step-after\": d3_svg_lineStepAfter,\n  \"basis\": d3_svg_lineBasis,\n  \"basis-open\": d3_svg_lineBasisOpen,\n  \"basis-closed\": d3_svg_lineBasisClosed,\n  \"bundle\": d3_svg_lineBundle,\n  \"cardinal\": d3_svg_lineCardinal,\n  \"cardinal-open\": d3_svg_lineCardinalOpen,\n  \"cardinal-closed\": d3_svg_lineCardinalClosed,\n  \"monotone\": d3_svg_lineMonotone\n};\n\n// Linear interpolation; generates \"L\" commands.\nfunction d3_svg_lineLinear(points) {\n  var path = [],\n      i = 0,\n      n = points.length,\n      p = points[0];\n  path.push(p[0], \",\", p[1]);\n  while (++i < n) path.push(\"L\", (p = points[i])[0], \",\", p[1]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepBefore(points) {\n  var path = [],\n      i = 0,\n      n = points.length,\n      p = points[0];\n  path.push(p[0], \",\", p[1]);\n  while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n  return path.join(\"\");\n}\n\n// Step interpolation; generates \"H\" and \"V\" commands.\nfunction d3_svg_lineStepAfter(points) {\n  var path = [],\n      i = 0,\n      n = points.length,\n      p = points[0];\n  path.push(p[0], \",\", p[1]);\n  while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n  return path.join(\"\");\n}\n\n// Open cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalOpen(points, tension) {\n  return points.length < 4\n      ? d3_svg_lineLinear(points)\n      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Closed cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinalClosed(points, tension) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),\n        d3_svg_lineCardinalTangents([points[points.length - 2]]\n        .concat(points, [points[1]]), tension));\n}\n\n// Cardinal spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineCardinal(points, tension, closed) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] + d3_svg_lineHermite(points,\n        d3_svg_lineCardinalTangents(points, tension));\n}\n\n// Hermite spline construction; generates \"C\" commands.\nfunction d3_svg_lineHermite(points, tangents) {\n  if (tangents.length < 1\n      || (points.length != tangents.length\n      && points.length != tangents.length + 2)) {\n    return d3_svg_lineLinear(points);\n  }\n\n  var quad = points.length != tangents.length,\n      path = \"\",\n      p0 = points[0],\n      p = points[1],\n      t0 = tangents[0],\n      t = t0,\n      pi = 1;\n\n  if (quad) {\n    path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3)\n        + \",\" + p[0] + \",\" + p[1];\n    p0 = points[1];\n    pi = 2;\n  }\n\n  if (tangents.length > 1) {\n    t = tangents[1];\n    p = points[pi];\n    pi++;\n    path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1])\n        + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n        + \",\" + p[0] + \",\" + p[1];\n    for (var i = 2; i < tangents.length; i++, pi++) {\n      p = points[pi];\n      t = tangents[i];\n      path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1])\n          + \",\" + p[0] + \",\" + p[1];\n    }\n  }\n\n  if (quad) {\n    var lp = points[pi];\n    path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3)\n        + \",\" + lp[0] + \",\" + lp[1];\n  }\n\n  return path;\n}\n\n// Generates tangents for a cardinal spline.\nfunction d3_svg_lineCardinalTangents(points, tension) {\n  var tangents = [],\n      a = (1 - tension) / 2,\n      p0,\n      p1 = points[0],\n      p2 = points[1],\n      i = 1,\n      n = points.length;\n  while (++i < n) {\n    p0 = p1;\n    p1 = p2;\n    p2 = points[i];\n    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n  }\n  return tangents;\n}\n\n// B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasis(points) {\n  if (points.length < 3) return d3_svg_lineLinear(points);\n  var path = [],\n      i = 1,\n      n = points.length,\n      pi = points[0],\n      x0 = pi[0],\n      y0 = pi[1],\n      px = [x0, x0, x0, (pi = points[1])[0]],\n      py = [y0, y0, y0, pi[1]];\n  path.push(x0, \",\", y0);\n  d3_svg_lineBasisBezier(path, px, py);\n  while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  i = -1;\n  while (++i < 2) {\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Open B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisOpen(points) {\n  if (points.length < 4) return d3_svg_lineLinear(points);\n  var path = [],\n      i = -1,\n      n = points.length,\n      pi,\n      px = [0],\n      py = [0];\n  while (++i < 3) {\n    pi = points[i];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)\n    + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n  --i; while (++i < n) {\n    pi = points[i];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\n// Closed B-spline interpolation; generates \"C\" commands.\nfunction d3_svg_lineBasisClosed(points) {\n  var path,\n      i = -1,\n      n = points.length,\n      m = n + 4,\n      pi,\n      px = [],\n      py = [];\n  while (++i < 4) {\n    pi = points[i % n];\n    px.push(pi[0]);\n    py.push(pi[1]);\n  }\n  path = [\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\",\n    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)\n  ];\n  --i; while (++i < m) {\n    pi = points[i % n];\n    px.shift(); px.push(pi[0]);\n    py.shift(); py.push(pi[1]);\n    d3_svg_lineBasisBezier(path, px, py);\n  }\n  return path.join(\"\");\n}\n\nfunction d3_svg_lineBundle(points, tension) {\n  var n = points.length - 1,\n      x0 = points[0][0],\n      y0 = points[0][1],\n      dx = points[n][0] - x0,\n      dy = points[n][1] - y0,\n      i = -1,\n      p,\n      t;\n  while (++i <= n) {\n    p = points[i];\n    t = i / n;\n    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n  }\n  return d3_svg_lineBasis(points);\n}\n\n// Returns the dot product of the given four-element vectors.\nfunction d3_svg_lineDot4(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n// Matrix to transform basis (b-spline) control points to bezier\n// control points. Derived from FvD 11.2.8.\nvar d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],\n    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],\n    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];\n\n// Pushes a \"C\" Bzier curve onto the specified path array, given the\n// two specified four-element arrays which define the control points.\nfunction d3_svg_lineBasisBezier(path, x, y) {\n  path.push(\n      \"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),\n      \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n}\n\n// Computes the slope from points p0 to p1.\nfunction d3_svg_lineSlope(p0, p1) {\n  return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n}\n\n// Compute three-point differences for the given points.\n// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference\nfunction d3_svg_lineFiniteDifferences(points) {\n  var i = 0,\n      j = points.length - 1,\n      m = [],\n      p0 = points[0],\n      p1 = points[1],\n      d = m[0] = d3_svg_lineSlope(p0, p1);\n  while (++i < j) {\n    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));\n  }\n  m[i] = d;\n  return m;\n}\n\n// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite\n// interpolation. Returns an array of tangent vectors. For details, see\n// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation\nfunction d3_svg_lineMonotoneTangents(points) {\n  var tangents = [],\n      d,\n      a,\n      b,\n      s,\n      m = d3_svg_lineFiniteDifferences(points),\n      i = -1,\n      j = points.length - 1;\n\n  // The first two steps are done by computing finite-differences:\n  // 1. Compute the slopes of the secant lines between successive points.\n  // 2. Initialize the tangents at every point as the average of the secants.\n\n  // Then, for each segment\n  while (++i < j) {\n    d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set\n    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to\n    // preserve monotonicity. Ignore step 4 and 5 for those k.\n\n    if (Math.abs(d) < 1e-6) {\n      m[i] = m[i + 1] = 0;\n    } else {\n      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.\n      a = m[i] / d;\n      b = m[i + 1] / d;\n\n      // 5. Prevent overshoot and ensure monotonicity by restricting the\n      // magnitude of vector <ak, bk> to a circle of radius 3.\n      s = a * a + b * b;\n      if (s > 9) {\n        s = d * 3 / Math.sqrt(s);\n        m[i] = s * a;\n        m[i + 1] = s * b;\n      }\n    }\n  }\n\n  // Compute the normalized tangent vector from the slopes. Note that if x is\n  // not monotonic, it's possible that the slope will be infinite, so we protect\n  // against NaN by setting the coordinate to zero.\n  i = -1; while (++i <= j) {\n    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0])\n      / (6 * (1 + m[i] * m[i]));\n    tangents.push([s || 0, m[i] * s || 0]);\n  }\n\n  return tangents;\n}\n\nfunction d3_svg_lineMonotone(points) {\n  return points.length < 3\n      ? d3_svg_lineLinear(points)\n      : points[0] +\n        d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n}\nd3.svg.line.radial = function() {\n  var line = d3_svg_line(d3_svg_lineRadial);\n  line.radius = line.x, delete line.x;\n  line.angle = line.y, delete line.y;\n  return line;\n};\n\nfunction d3_svg_lineRadial(points) {\n  var point,\n      i = -1,\n      n = points.length,\n      r,\n      a;\n  while (++i < n) {\n    point = points[i];\n    r = point[0];\n    a = point[1] + d3_svg_arcOffset;\n    point[0] = r * Math.cos(a);\n    point[1] = r * Math.sin(a);\n  }\n  return points;\n}\nfunction d3_svg_area(projection) {\n  var x0 = d3_svg_lineX,\n      x1 = d3_svg_lineX,\n      y0 = 0,\n      y1 = d3_svg_lineY,\n      interpolate = \"linear\",\n      interpolator = d3_svg_lineInterpolators[interpolate],\n      tension = .7;\n\n  function area(d) {\n    if (d.length < 1) return null;\n    var points0 = d3_svg_linePoints(this, d, x0, y0),\n        points1 = d3_svg_linePoints(this, d, x0 === x1 ? d3_svg_areaX(points0) : x1, y0 === y1 ? d3_svg_areaY(points0) : y1);\n    return \"M\" + interpolator(projection(points1), tension)\n         + \"L\" + interpolator(projection(points0.reverse()), tension)\n         + \"Z\";\n  }\n\n  area.x = function(x) {\n    if (!arguments.length) return x1;\n    x0 = x1 = x;\n    return area;\n  };\n\n  area.x0 = function(x) {\n    if (!arguments.length) return x0;\n    x0 = x;\n    return area;\n  };\n\n  area.x1 = function(x) {\n    if (!arguments.length) return x1;\n    x1 = x;\n    return area;\n  };\n\n  area.y = function(y) {\n    if (!arguments.length) return y1;\n    y0 = y1 = y;\n    return area;\n  };\n\n  area.y0 = function(y) {\n    if (!arguments.length) return y0;\n    y0 = y;\n    return area;\n  };\n\n  area.y1 = function(y) {\n    if (!arguments.length) return y1;\n    y1 = y;\n    return area;\n  };\n\n  area.interpolate = function(x) {\n    if (!arguments.length) return interpolate;\n    interpolator = d3_svg_lineInterpolators[interpolate = x];\n    return area;\n  };\n\n  area.tension = function(x) {\n    if (!arguments.length) return tension;\n    tension = x;\n    return area;\n  };\n\n  return area;\n}\n\nd3.svg.area = function() {\n  return d3_svg_area(Object);\n};\n\nfunction d3_svg_areaX(points) {\n  return function(d, i) {\n    return points[i][0];\n  };\n}\n\nfunction d3_svg_areaY(points) {\n  return function(d, i) {\n    return points[i][1];\n  };\n}\nd3.svg.area.radial = function() {\n  var area = d3_svg_area(d3_svg_lineRadial);\n  area.radius = area.x, delete area.x;\n  area.innerRadius = area.x0, delete area.x0;\n  area.outerRadius = area.x1, delete area.x1;\n  area.angle = area.y, delete area.y;\n  area.startAngle = area.y0, delete area.y0;\n  area.endAngle = area.y1, delete area.y1;\n  return area;\n};\nd3.svg.chord = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      radius = d3_svg_chordRadius,\n      startAngle = d3_svg_arcStartAngle,\n      endAngle = d3_svg_arcEndAngle;\n\n  // TODO Allow control point to be customized.\n\n  function chord(d, i) {\n    var s = subgroup(this, source, d, i),\n        t = subgroup(this, target, d, i);\n    return \"M\" + s.p0\n      + arc(s.r, s.p1) + (equals(s, t)\n      ? curve(s.r, s.p1, s.r, s.p0)\n      : curve(s.r, s.p1, t.r, t.p0)\n      + arc(t.r, t.p1)\n      + curve(t.r, t.p1, s.r, s.p0))\n      + \"Z\";\n  }\n\n  function subgroup(self, f, d, i) {\n    var subgroup = f.call(self, d, i),\n        r = radius.call(self, subgroup, i),\n        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n    return {\n      r: r,\n      a0: a0,\n      a1: a1,\n      p0: [r * Math.cos(a0), r * Math.sin(a0)],\n      p1: [r * Math.cos(a1), r * Math.sin(a1)]\n    };\n  }\n\n  function equals(a, b) {\n    return a.a0 == b.a0 && a.a1 == b.a1;\n  }\n\n  function arc(r, p) {\n    return \"A\" + r + \",\" + r + \" 0 0,1 \" + p;\n  }\n\n  function curve(r0, p0, r1, p1) {\n    return \"Q 0,0 \" + p1;\n  }\n\n  chord.radius = function(v) {\n    if (!arguments.length) return radius;\n    radius = d3.functor(v);\n    return chord;\n  };\n\n  chord.source = function(v) {\n    if (!arguments.length) return source;\n    source = d3.functor(v);\n    return chord;\n  };\n\n  chord.target = function(v) {\n    if (!arguments.length) return target;\n    target = d3.functor(v);\n    return chord;\n  };\n\n  chord.startAngle = function(v) {\n    if (!arguments.length) return startAngle;\n    startAngle = d3.functor(v);\n    return chord;\n  };\n\n  chord.endAngle = function(v) {\n    if (!arguments.length) return endAngle;\n    endAngle = d3.functor(v);\n    return chord;\n  };\n\n  return chord;\n};\n\nfunction d3_svg_chordSource(d) {\n  return d.source;\n}\n\nfunction d3_svg_chordTarget(d) {\n  return d.target;\n}\n\nfunction d3_svg_chordRadius(d) {\n  return d.radius;\n}\n\nfunction d3_svg_chordStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction d3_svg_chordEndAngle(d) {\n  return d.endAngle;\n}\nd3.svg.diagonal = function() {\n  var source = d3_svg_chordSource,\n      target = d3_svg_chordTarget,\n      projection = d3_svg_diagonalProjection;\n\n  function diagonal(d, i) {\n    var p0 = source.call(this, d, i),\n        p3 = target.call(this, d, i),\n        m = (p0.y + p3.y) / 2,\n        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];\n    p = p.map(projection);\n    return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n  }\n\n  diagonal.source = function(x) {\n    if (!arguments.length) return source;\n    source = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.target = function(x) {\n    if (!arguments.length) return target;\n    target = d3.functor(x);\n    return diagonal;\n  };\n\n  diagonal.projection = function(x) {\n    if (!arguments.length) return projection;\n    projection = x;\n    return diagonal;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalProjection(d) {\n  return [d.x, d.y];\n}\nd3.svg.diagonal.radial = function() {\n  var diagonal = d3.svg.diagonal(),\n      projection = d3_svg_diagonalProjection,\n      projection_ = diagonal.projection;\n\n  diagonal.projection = function(x) {\n    return arguments.length\n        ? projection_(d3_svg_diagonalRadialProjection(projection = x))\n        : projection;\n  };\n\n  return diagonal;\n};\n\nfunction d3_svg_diagonalRadialProjection(projection) {\n  return function() {\n    var d = projection.apply(this, arguments),\n        r = d[0],\n        a = d[1] + d3_svg_arcOffset;\n    return [r * Math.cos(a), r * Math.sin(a)];\n  };\n}\nd3.svg.mouse = function(container) {\n  return d3_svg_mousePoint(container, d3.event);\n};\n\n// https://bugs.webkit.org/show_bug.cgi?id=44083\nvar d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n\nfunction d3_svg_mousePoint(container, e) {\n  var point = (container.ownerSVGElement || container).createSVGPoint();\n  if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {\n    var svg = d3.select(document.body)\n      .append(\"svg:svg\")\n        .style(\"position\", \"absolute\")\n        .style(\"top\", 0)\n        .style(\"left\", 0);\n    var ctm = svg[0][0].getScreenCTM();\n    d3_mouse_bug44083 = !(ctm.f || ctm.e);\n    svg.remove();\n  }\n  if (d3_mouse_bug44083) {\n    point.x = e.pageX;\n    point.y = e.pageY;\n  } else {\n    point.x = e.clientX;\n    point.y = e.clientY;\n  }\n  point = point.matrixTransform(container.getScreenCTM().inverse());\n  return [point.x, point.y];\n};\nd3.svg.touches = function(container) {\n  var touches = d3.event.touches;\n  return touches ? d3_array(touches).map(function(touch) {\n    var point = d3_svg_mousePoint(container, touch);\n    point.identifier = touch.identifier;\n    return point;\n  }) : [];\n};\nd3.svg.symbol = function() {\n  var type = d3_svg_symbolType,\n      size = d3_svg_symbolSize;\n\n  function symbol(d, i) {\n    return (d3_svg_symbols[type.call(this, d, i)]\n        || d3_svg_symbols.circle)\n        (size.call(this, d, i));\n  }\n\n  symbol.type = function(x) {\n    if (!arguments.length) return type;\n    type = d3.functor(x);\n    return symbol;\n  };\n\n  // size of symbol in square pixels\n  symbol.size = function(x) {\n    if (!arguments.length) return size;\n    size = d3.functor(x);\n    return symbol;\n  };\n\n  return symbol;\n};\n\nfunction d3_svg_symbolSize() {\n  return 64;\n}\n\nfunction d3_svg_symbolType() {\n  return \"circle\";\n}\n\n// TODO cross-diagonal?\nvar d3_svg_symbols = {\n  \"circle\": function(size) {\n    var r = Math.sqrt(size / Math.PI);\n    return \"M0,\" + r\n        + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r)\n        + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r\n        + \"Z\";\n  },\n  \"cross\": function(size) {\n    var r = Math.sqrt(size / 5) / 2;\n    return \"M\" + -3 * r + \",\" + -r\n        + \"H\" + -r\n        + \"V\" + -3 * r\n        + \"H\" + r\n        + \"V\" + -r\n        + \"H\" + 3 * r\n        + \"V\" + r\n        + \"H\" + r\n        + \"V\" + 3 * r\n        + \"H\" + -r\n        + \"V\" + r\n        + \"H\" + -3 * r\n        + \"Z\";\n  },\n  \"diamond\": function(size) {\n    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n        rx = ry * d3_svg_symbolTan30;\n    return \"M0,\" + -ry\n        + \"L\" + rx + \",0\"\n        + \" 0,\" + ry\n        + \" \" + -rx + \",0\"\n        + \"Z\";\n  },\n  \"square\": function(size) {\n    var r = Math.sqrt(size) / 2;\n    return \"M\" + -r + \",\" + -r\n        + \"L\" + r + \",\" + -r\n        + \" \" + r + \",\" + r\n        + \" \" + -r + \",\" + r\n        + \"Z\";\n  },\n  \"triangle-down\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + ry\n        + \"L\" + rx +\",\" + -ry\n        + \" \" + -rx + \",\" + -ry\n        + \"Z\";\n  },\n  \"triangle-up\": function(size) {\n    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n        ry = rx * d3_svg_symbolSqrt3 / 2;\n    return \"M0,\" + -ry\n        + \"L\" + rx +\",\" + ry\n        + \" \" + -rx + \",\" + ry\n        + \"Z\";\n  }\n};\n\nd3.svg.symbolTypes = d3.keys(d3_svg_symbols);\n\nvar d3_svg_symbolSqrt3 = Math.sqrt(3),\n    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);\n})();",
      "language": "JavaScript"
    },
    "index.html": {
      "type": "text/html",
      "filename": "index.html",
      "size": 1359,
      "raw_url": "https://gist.github.com/raw/1155488/aa90f14b315b30173ff22c685fb1b78d4bf3a469/index.html",
      "content": "<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>Goodbye, Mint</title>\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"chart.css\"/>\n\t</head>\n\t<body>\n\t\t<div id=\"main\">\n\t\t\t<h1>Goodbye, Mint. Stay Minty.</h1>\n\t\t\t<div id=\"chartContainer\">\n\t\t\t\t<div id=\"notes\">\n\t\t\t\t\t<h2>Notes:</h2>\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>This chart is a fun representation (first-order approximation) of <i>awesomeness</i>, or how life has been since I joined Mint.</li>\n\t\t\t\t\t\t<li>Awesomeness (arb. units) has been scaled such that the value 0.0 corresponds to my start date.</li>\n\t\t\t\t\t\t<li>Time is represented along the abscissa, and normalized to total tenure.</li>\n\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t</div>\n\t\t<script type=\"text/javascript\" src=\"http://cdn.znaflab.com/d3/d3.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"chart.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t  var _gaq = _gaq || [];\n\t\t  _gaq.push(['_setAccount', 'UA-25235982-1']);\n\t\t  _gaq.push(['_setDomainName', '.znaflab.com']);\n\t\t  _gaq.push(['_trackPageview']);\n\t\t  (function() {\n\t\t    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n\t\t    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n\t\t    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n\t\t  })();\n\t\t</script>\n\t</body>\n</html>\n",
      "language": "HTML"
    }
  },
  "git_push_url": "git@gist.github.com:1155488.git",
  "updated_at": "2011-08-18T23:02:41Z",
  "url": "https://api.github.com/gists/1155488",
  "id": "1155488"
}
